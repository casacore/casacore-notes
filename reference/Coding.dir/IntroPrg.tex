\chapter{Introduction to Programming for AIPS++ \label{Coding.IntroToProgramming}}

This chapter \footnote{Originally written by R.T. Duquet and updated by W.K. Young.} provides a
gentle introduction to programming with {\tt aips++} classes.\\
\begin{htmlonly}
\htmladdnormallink{A postscript version of this chapter is available.}{http://tarzan.aoc.nrao.edu/aips++/docs/notes/111.ps.gz}
\end{htmlonly}

\section{A First Program \label{Coding.FirstProgram}}
\index{First AIPS++ Program}
        We will start with a small sample program which prints
the values generated by a simple function.  The object, of course, is
merely to explain the conventions and procedures used in an {\tt aips++}
program 
(The \htmladdnormallink{source code}{../../../code/trial/implement/test/tExample1.cc}
for this program is found in 
\$AIPSROOT/code/trial/implement/test/tExample1.cc). 


\begin{verbatim}
     1  #include <aips/aips.h>
     2  #include <aips/Exceptions.h>
     3  #include <aips/Mathematics/Math.h>
     4  #include <iostream.h>
     5
     6  main(int argc, char **argv)
     7  {
     8   const Int     n(8);
     9   const Float   interval(10.0);
    10   Float   x, y;
    11
    12   try {
    13      for (Int i=0; i<n; i++) {
    14         x = i;
    15         y = i * sin(i / interval);
    16         cout << x << "\t" << y << endl;
    17      }
    18   }
    19
    20   catch (AipsError x) {
    21      cerr << "aipserror: error " << x.getMesg() << endl;
    22      return 1;
    23   }
    24   return 0;
    25  }

\end{verbatim}

The following discussion refers to the line numbers which have been
prepended to the code above:

\begin{description}
\item[1-] Every {\tt aips++} program must contain this line. It declares variable
types Int, Float, etc. plus other goodies used for debugging.


\item[2-] This class handles exceptions for {\tt aips++} programs.


\item[3-] This calls the routine that defines the sine function.  The various C++
vendors do not always provide the expected routines in their math libraries.
This invocation allows the {\tt aips++} routines to call whichever versions are
appropriate.


\item[4-] This is the standard IO for this C++ package. It is not directly
related to {\tt aips++}.


\item[6-] The declaration of the main program must provide for
argument input. The use of argc and argv causes the compiler to issue
a warning in this instance because they are not used. (They will be
used in a later example.)  Note that these data types are NOT written
with a leading capital letter since the compiler wants native-mode
variables in this instance.


\item[8-10-] Note the use of first letter capitals in the type declarations.
These are defined in {\em aips.h}.  Note too the specification of values
on these lines rather than in 
the code body. This is to make it easier to make changes to
the code.  The use of the qualifier {\em const} means that these
parameters cannot be accidentally altered in the code. 

\item[12-] The {\em try} block (code between \{ and \})
define the extend of the code that is to be monitored by the handlers
(defined by the {\em catch} clauses below).

\item[13-] The use of inline declaration of variables ({\em Int i}) in
{\em for} loops is strongly recommended.

\item[20-] The {\em catch} statement intercepts various types of errors. In
this case we are asking the program to report on general errors related
to {\tt aips++}.  Note that the argument {\em x} is NOT related in any way to
the variable {\em x} declared on line 10. 


\item[21-] In this case we are telling the program to print out the fact that
an error has occured on the terminal.
\end{description}

To compile this program one should use the {\em gmake} command which
will report on any errors and which will create an executable module
with the name supplied.  The {\em gmake} macro has built-in knowledge
of the location of each of the included {\em $<$aips/xxxxx$>$} files. 
In order to use {\em gmake}  you must be logged in to one of
a limited number of areas. In particular, you should be in 
{\em \verb+~+/aips++/code/aips/test}


        Assuming the source code was named {\em sample1}
the command would simply be 

{\em gmake NODEP=1 sample1} where the string {\em NODEP=1} merely tells the
compiler to take a short-cut which is quite allright for modules that are not
intended to be part of the {\tt aips++} library.
Note that we did not have to specify the suffix appended to the source
module name. However that suffix must be {\em cc}.

The program is started simply by typing its name: {\em sample1}.  
The output is as follows (note the default format):
\begin{verbatim}
0       0
1       0.0998334
2       0.397339
3       0.886561
4       1.55767
5       2.39713
6       3.38785
7       4.50952
\end{verbatim}
 
\newpage


\section{Second Version}

        We now continue by slightly expanding this program.

First, we will supply input arguments to the program in order to set
various parameters and to determine the type of output desired.

Next, we will replace the scalars {\em x} and {\em y} by a 
class of objects known to {\tt aips++} as a {\em Vector}.  In order to do
this we must include {\em $<$aips/Vector.h$>$}.
As we will see, that the same class can be used to contain different
types of objects. This is known in C++ as a {\em template}.

Elements of a {\em Vector} may be addressed as they are in FORTRAN, that is
by the name of the vector followed by a subscript in parentheses.  {\tt aips++}
however allows some operations to be applied to an entire vector. We will
illustrate this.

Finally, we will provide the possibility of creating
a file in {\tt aips++} format i.e. in a format that can be read by other
{\tt aips++} programs. 
(The \htmladdnormallink{source code}{../../../code/trial/implement/test/tExample2.cc}
for this program is found in 
\$AIPSROOT/code/trial/implement/test/tExample2.cc). 

\begin{verbatim}
   1  #include <aips/aips.h>
   2  #include <aips/IO/AipsIO.h>
   3  #include <aips/IO/AipsIOError.h>
   4  #include <aips/Inputs.h>
   5  #include <aips/Mathematics.h>
   6  #include <aips/Arrays/Vector.h>
   7  #include <iostream.h>
   8
   9  main(int argc, char **argv)
  10  {
  11   Input inputs(1);
  12   inputs.Version("$@w{Revision}$");
  13   inputs.Create("vectorsize","15","Number of vector elements?","Integer");
  14   inputs.Create("usefile","True","Create an AIPS++ File?","Bool");
  15   inputs.Create("file","/tmp/sample2.test","Output file name?","Outfile");
  16   try {
  17      inputs.ReadArguments(argc, argv);
  18
  19      const Int hold = inputs.GetInt("vectorsize");
  20      const Bool usefile = inputs.GetBool("usefile");
  21      const char *filename = inputs.GetString("file");
  22
  23      const Float   interval(10.0);
  24      const uInt    version(1);
  25      Vector<float> x(hold), y(hold);
  26
  27      indgen(x);
  28      y = x * sin(x / interval);
  29      if (usefile) {
  30         AipsIO outfile(filename, AipsIO::Out);
  31         outfile << x << y;
  32      }else{
  33         for (Int i=0; i<x.nelements(); i++) {
  34            cout << x(i) << "\t" << y(i) << endl;
  35         }
  36      }
  37   }
  38
  39
  40   catch (AipsIOError x) {
  41      cerr << "aipsioerror: error " << x.getMesg() << endl;
  42      return 1;
  43   }
  44   catch (AipsError x) {
  45      cerr << "aipserror: error " << x.getMesg() << endl;
  46      return 1;
  47   }
  48
  49   return 0;
  50  }

\end{verbatim}

The following points should be observed concerning this version (as
before, the numbers refer to those prepended to each line of
the listing):

\begin{description}
\item[2-] The {\em AipsIO} class refers to real IO as opposed to the acquisition of
command line arguments which is the role of the {\em Input} class. 

\item[7-] The {\em Vector} class is used to handle {\tt aips++} style of
vectors which differs, of course, from the simple arrays predefined in
the C++ language.

\item[13-15-] The {\em Create} member function of {\em Input} builds from the
command line three parameters referenced as {\em vectorsize},
{\em usefile} and {\em outfile}.  All parameters are optional.
The value stated as the second argument in each case is the
default value suplied for use when the program is started without
that specific parameter.
The third argument is used for prompting (when requested by the program
user - see below). The fourth argument is the type of the parameter's
value. Two additional arguments are optional and are omitted in this sample
program. 

\item[17-] This line supplies the value of each parameter. The default values
will be used unless specific values have been supplied. A
{\em keyword} that doesn't match those anticipated in the program will
be discarded as an error but the program will continue.

\item[19-21-] Each of the parameters read from the input line or supplied by
default is assigned to a {\em const} variable to be used (but not
modified) in the program. Note the use of {\em char} datatype, rather
that a {\em String}, for the variable {\em filename}.

\item[25-] The {\tt aips++} {\em Vector} data type is a {\em template} which means
that vectors may consist of different data types such as {\em Int} or
{\em Float} or {\em Complex}. The space required by the vectors is
assigned at run time so the arrays can be dimensioned on the basis of an
input parameter.  Note the use of the round, rather than the square,
brackets for the dimensions of the Vector.

\item[27-] The function {\em indgen} is supplied as part of the {\em ArrayMath}
class. In this simple case it fills each element of the array specified as
an argument with the integers {\em 0,1,2,3,...,nelements()-1} (In other,
more elaborate cases, it can fill the array with other sequences.)

\item[28-] This Vector statement is the equivalent of a loop operating element by
element.

\item[30-] The definition of the AipsIO item called {\em outfile} within the
{\em if} block prevents the file from being opened unless it is needed.
The type of file (output) is specified in the second argument.  Options
are: {\em  In, Out, Update, Append, New, NewNoReplace, Scratch} and
{\em Delete}.  Note that we did not need to OPEN the file nor do we need to
CLOSE it unless it needs to be rewritten (or reread).  

\item[31-] In this line the {\em $<<$} operator is overloaded so that the output
is an entire vector.
  
\item[33-34-] Here we deliberately use the subscript notation for elements of a 
{\em Vector}. 
 One of the side benefits of using the {\tt aips++} {\em Vector} data type
is that the class contains a function, called {\em nelements()} which
returns the current size of the vector. Its use here is obviously more
flexible and, at the same time, more robust than the use of a constant.

\item[40-43-] A new class of error is caught by these statements.
\end{description}

As before, to compile this program one should use the {\em gmake}
command. Once compiled, the program can be started by simply typing
{\em sample2}. The result is a file in the {\em /tmp} directory.  This
file is {\tt aips++} compliant which means that the information is preceeded
by some {\tt aips++} identification. As noted at the beginning of this section,
the file is in binary format which means, of course, that it is not
suitable for display on a terminal.

  As it runs, the program DOES
display one line on the terminal; that line identifies the version of
the program being run. (The reason this line did not appear in the output
produced by the {\em sample1} program is because we never read the
{\em inputs}.) 

The same program can be started with a request to send output to the
screen i.e. to override the default value of the {\em usefile}
and {\em vectorsize} parameters. When we start it by typing
@*
{\em sample2 usefile=false vectorsize=5} we get the following

\begin{verbatim}
sample2: Version $@w{Revision}$
0       0
1       0.0998334
2       0.397339
3       0.886561
4       1.55767
\end{verbatim}

The version number has NOT been inserted for the string {\em $@w{Revision}$}
because we have not submitted the program to the {\tt aips++} system library.

It my very well happen that you wish to run a program but you do not
remember the names of the arguments nor their expected values.
The solution is to run the program by stating its name
followed by the string {\em help=prompt}. For example, if we type
{\em sample2 help=prompt} we get the following:

\begin{verbatim}
sample2: Version $@w{Revision}$

Number of vector elements? [15]: vectorsize=

Create an {\tt aips++} File? [True]: usefile=

Output file name? [/tmp/sample2.test]: outfile=
\end{verbatim}

Notice the appearance of the text that we inserted as one of the
{\em inputs.Create} arguments. That text is followed by the default
value (also specified as a {\em inputs.Create} argument). Finally we
have the name of the argument.  We can either supply a new value or
merely hit the {\em RETURN} key to accept the default value shown in the
square parentheses.
\newpage
\section{An advanced example}

        The following program is meant to illustrate some further features of
the AIPS++ system.  In particular, we will show a program that was used to test
the development of two functions which read and write an ASCII file.
The file is expected to contain a 2-dimensional array (of any rectangular 
dimensions) of numbers and place the values it contains (regardless of type) 
into a matrix.

        The work will be described in three parts - which correspond to the
three directories that should be used for this type of work. They are:

\begin{enumerate}
\item The directory in which the main routine is composed and compiled. This is
the one that has been used in previous examples. It is:
{\bf \verb+~+/aips/code/aips/test}.

\item A directory in which the {\bf .h} file is defined. This is:
{\bf \verb+~+/aips/code/aips/include}.

\item A directory in which the functions are composed and compiled. This one also
will contain a private library which will be searched automatically by the
{\bf gmake} process. This one is: {\bf \verb+~+/aips++/code/aips/implement}.
\end{enumerate}

\subsection{The main program}

We start with the main program which will simply call a couple of routines to
check the coding 
(The \htmladdnormallink{source code}{../../../code/trial/implement/test/tExample3.cc}
for this program is found in 
\$AIPSROOT/code/trial/implement/test/tExample3.cc). 

\begin{verbatim}
 1  #include <aips/aips.h>
 2  #include <aips/AipsIO.h>
 3  #include <aips/ArrayIO.h>
 4  #include <aips/Input.h>
 5  #include <aips/Math.h>
 6  #include <aips/Matrix.h>
 7  #include <aips/AsciiFileIO.h>
 9  
10  main(int argc, char **argv)
11  {
12   Input inputs(1);
13   inputs.Version("$w{Revision}$");
14   inputs.Usage("Testing Ascii IO routines");
15   inputs.Create("infile1","Input1","Float Input file name?","Infile");
16   inputs.Create("infile2","Input2","Int Input file name?","Infile");
17   inputs.Create("infile3","Input3","Double Input file name?","Infile");
18   inputs.Create("outfile","Output","Output file name?","Outfile");
19   inputs.ReadArguments(argc, argv);
20  
21   const char *filein1 = inputs.GetString("infile1");
22   const char *filein2 = inputs.GetString("infile2");
23   const char *filein3 = inputs.GetString("infile3");
24   const char *fileout = inputs.GetString("outfile");
25  
26   Int rows, cols;
27   try {
28      Matrix <Float> mat1;
29      Matrix <Int> mat2;
30      Matrix <Double> mat3;
31  
32      ReadAsciiFile(filein1, mat1);
33      mat1.shape(rows, cols);
34      cout << "The first Matrix is " << rows << " by " << cols << endl;
35  
36      ReadAsciiFile(filein2, mat2);
37      mat2.shape(rows, cols);
38      cout << "The second Matrix is " << rows << " by " << cols << endl;
39  
40      ReadAsciiFile(filein3, mat3);
41      mat3.shape(rows, cols);
42      cout << "The third Matrix is " << rows << " by " << cols << endl;
43  
44      WriteAsciiFile(fileout, mat1);
45  
46      cout.precision(12);
47      cout << mat1 << mat2 << mat3;
48     }
49  
50   return 0;
51
52    catch (AipsError x) {
53    cerr << "aipserror: error " << x.getMesg() << endl;
54          return 1;
55         }
56
58  }
\end{verbatim}


The following discussion refers to the line numbers which have been prepended 
to the code above:

\begin{description}
\item[7-] This line includes the new routines in the code for {\bf AsciiFileIO}.

\item[15-17-] The program will read 3 different arrays of differing characteristics.

\item[28-30-] The Matrices are declared to be of three differing types but the sizes
of the arrays is not stated.  It will be set dynamically by the subroutines.

\item[32-] The {\bf ReadAsciiFile} function is called to read a matrix of
floating point values.
The type is specified in the declaration of {\bf mat1} which is used as an
argument. The size of the array is still unknown.  Note that the data in the
array may be in integer form but it will be stored as an array of float
values.

\item[33-] The member function {\bf shape} is called to determine the dimensions of
the matrix that was just read.

\item[36-] The same new function, {\bf ReadAsciiFile},  is called to read an array of
integers. The data
may be specified with decimal points and fractional parts but they will be
placed in the matrix as integers.

\item[37-] The member function {\bf shape} is used to get the dimensions of the
matrix {\bf mat2}. Note that these dimensions are quite independent of the
dimesions found for the matrix {\bf mat1}.

\item[40-41-] The same comments hold for a matrix of doubles.

\item[44-] The routine to write the array, {\bf WriteAsciiFile},  need not pass
the dimensions of the array since they can be determined in the same way
as they were in lines 33, 37 and 41. 

\item[46-] The property of cout, {\bf precision}, is used to set the number of decimal
places that will appear in the output (where they are not all zero).  Other
properties of the {\bf format state} may also be set.  For example, one could
set the number of decimal places displayed to a constant (regardless of whether
or not they were all zeroes) by using the statement 
{\bf cout.setf(ios::showpoint)}. 
\end{description}


\newpage
\subsection{The {\bf include} file}

        This file containd the {\bf .h} module.         The working part of
this file is really only two lines long but the required
"boiler-plate" takes up the first 25 lines (approximately). This text
must be included with every file that is intended for the AIPS++
system (i.e. that could be distributed outside of NRAO).  



\newpage

This \htmladdnormallink{include file}{../../../code/trial/implement/test/FileIO.h}
may be found in \$AIPSROOT/code/trial/implememnt/test/FileIO.h.
\begin{verbatim}
  1  //# FileIO.h: this defines ileIO functions, which ...
  2  //# Copyright (C) 1996,1999,2001
  3  //# Associated Universities, Inc. Washington DC, USA.
  4  //#
  5  //# This library is free software; you can redistribute it and/or modify it
  6  //# under the terms of the GNU Library General Public License as published by
  7  //# the Free Software Foundation; either version 2 of the License, or (at your
  8  //# option) any later version.
  9  //#
 10  //# This library is distributed in the hope that it will be useful, but WITHOUT
 11  //# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 12  //# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Library General Public
 13  //# License for more details.
 14  //#
 15  //# You should have received a copy of the GNU Library General Public License
 16  //# along with this library; if not, write to the Free Software Foundation,
 17  //# Inc., 675 Massachusetts Ave, Cambridge, MA 02139, USA.
 18  //#
 19  //# Correspondence concerning AIPS++ should be addressed as follows:
 20  //#        Internet email: aips2-request@nrao.edu.
 21  //#        Postal address: AIPS++ Project Office
 22  //#                        National Radio Astronomy Observatory
 23  //#                        520 Edgemont Road
 24  //#                        Charlottesville, VA 22903-2475 USA
 25  //#
 26  //#
 27  //# $Id$
 28
 29  #if !defined (AIPS_FILEIO_H)
 30  #define AIPS_FILEIO_H
 31
 32  #if defined(_AIX)
 33  #pragma implementation ("AsciiFileIO.cc")
 34  #endif
 35
 36  #include <aips/aips.h>
 37  #include <aips/Arrays/ArrayIO.h>
 38
 39  //# Forward Declarations
 40
 41  // <summary>
 42  Input/output using ASCII format
 43  // </summary>
 44
 45  // <use visibility=local>   or   <use visibility=export>
 46
 47  // <reviewed reviewer="" date="yyyy/mm/dd" tests="" demos="">
 48  // </reviewed>
 49
 50  // <prerequisite>
 51  //   <li> SomeClass
 52  //   <li> SomeOtherClass
 53  //   <li> some concept
 54  // </prerequisite>
 55  //
 56  // <etymology>
 57  // </etymology>
 58  //
 59  // <synopsis>
 60  // </synopsis>
 61  //
 62  // <example>
 63  // </example>
 64  //
 65  // <motivation>
 66  // </motivation>
 67  //
 68  // <templating arg=T>
 69  //    <li>
 70  //    <li>
 71  // </templating>
 72  //
 73  // <thrown>
 74  //    <li>
 75  //    <li>
 76  // </thrown>
 77  //
 78  // <todo asof="yyyy/mm/dd">
 79  //   <li> add this feature
 80  //   <li> fix this bug
 81  //   <li> start discussion of this possible extension
 82  // </todo>
 83
 84 template <class T>
 85    void
 86    readAsciiFile(const char *filein, Matrix<T> &mat){
 87       readAsciiMatrix(mat, filein);
 88    }
 89 template <class T>
 90    void
 91    readAsciiFile(const char *filein, Vector<T> &vec){
 92       readAsciiVector(vec, filein);
 93    }
 94 
 95 //
 96 
 97 template <class T>
 98    void
 99    writeAsciiFile(const char *fileout, const Matrix<T> &mat){
100       writeAsciiMatrix(mat, fileout);
101    }
102 template <class T>
103    void
104    writeAsciiFile(const char *fileout, const Vector<T> &vec){
105       writeAsciiVector(vec, fileout);
106    }
107  #endif
\end{verbatim}
\begin{description}
\item[1-27-] Boilerplate which is to be included in each module.

\item[29-30-]   The code begins with a label that identifies this file. The macros
{\bf if ! defined} and {\bf define} prevent the code from being
loaded more than once in a given program. (Note the {\bf endif} macro at the
end.)

\item[34-] Every header file MUST include this line which, in turn, must NOT be
included with the code for the function.

\item[35-] The Matrix class is included because this header file describes functions
that take a Matrix as an argument.

\item[39-82-]  These lines are the documentation template for each class.  Cxx2html
will read these lines and produce formated HTML for your class/functions.
A more complete description maybe found in the \htmlref{Programmer's Reference
Manual}{Coding.Templates}
If you ever want to check you're code in then you must fill them in.

\item[84-86-] These lines (which, you will note, are a single statement) declare the
function {\bf ReadsAsciiFile} to be a template i.e. to be
defined once for multiple types of argument. The symbol uses here to represent
the argument type is the letter {\bf T} (declared in the pointed brackets with
the keyword {\bf class}).
The function itself is like any other
function declaration except that the Matrix argument
is defined for the multiple types represented by the letter {\bf T}.

The implications of this are important. Since the class is only specified
later on (when the routine is called) the compiler cannot create ahead of time
a module that will be linked with the calling code.  So even though we will 
place these routines in a library, it really is a source library and every
time a module is used it must be compiled at that time!
  
\item[87-89-] The lines declare the second function {\bf WriteAsciiFile}.

\item[91-] This matches the test for label declaration on line 31.
\end{description}


\newpage
\section{The functions}

        The following code defines the two functions.
(The \htmladdnormallink{source code}{../../../code/trial/implement/test/tExample1.cc}
for this program is found in 
\$AIPSROOT/code/trial/implement/test/tExample1.cc). 

\begin{verbatim}
  1  #include <aips/IO/AipsIO.h>
  2  #include <aips/Arrays/ArrayIO.h>
  3  #include <aips/Arrays/ArrayMath.h>
  4  #include <aips/Containers/Block.h>
  5  #include <aips/Inputs/Input.h>
  6  #include <aips/Mathematics/Math.h>
  7  #include <aips/Arrays/Matrix.h>
  8  #include <aips/Arrays/Vector.h>
  9  #include <iostream.h>
 10  #include <fstream.h>             // needed for file IO
 11  #include <strstream.h>           // needed for internal IO
 12
 13
 14   template <class T>
 15   void
 16   ReadAsciiFile(const char *filein, Matrix<T> &mat)
 17     {
 18      const Int      bufSize = 1024, numberSize = 50;
 19            char     buf[bufSize], buf2[numberSize];
 20            uInt     blockSize = 100;
 21            Block<T> temp(blockSize);
 22
 23      ifstream iFile;
 24      iFile.open(filein, ios::in);
 25      if (! iFile) {
 26         cerr << "Cannot open " << filein << "for reading\n"; exit (-1);}
 27
 28      Int rows = 0, cols = 0, saveCols = 0;
 29      uInt havePoint = 0;
 30
 31      while (iFile.getline(buf, bufSize)) {
 32         Int blankLine = 1;
 33         for (Int j1=0;j1<bufSize;j1++) {
 34            if (buf[j1] == '\0') break;
 35            if (buf[j1] != ' ') {blankLine = 0; break;}
 36           }
 37
 38         if (! blankLine) {
 39            if (havePoint > (blockSize - saveCols - 10)) {
 40               blockSize *= 2;
 41               temp.resize(blockSize);
 42              }
 43
 44            rows += 1; cols = 0;
 45            Int ch = 0, startedNew = 0;
 46            for (Int i2=0; i2<bufSize; i2++) {
 47               if (buf[i2] == '\0' || buf[i2] == ' ') {
 48                  if (ch > 0) {
 49                     buf2[ch] = ' ';
 50                     istrstream(buf2,sizeof(buf2)) >>  temp[havePoint];
 51                     havePoint += 1;
 52                     ch = 0;
 53                    }
 54                  startedNew = 0;
 55                  if (buf[i2] == '\0') break;
 56                 }
 57
 58               if (buf[i2] != ' ' && startedNew == 0) {
 59                  cols += 1;
 60                  startedNew = 1;
 61                 }
 62
 63               if (startedNew) buf2[ch++] = buf[i2];
 64              }
 65
 66            if (rows == 1) saveCols = cols;
 67            else if (cols != saveCols) {
 68               cout << "Array is not regular.  Number of elements was "
 69                    << saveCols << " at row 1"
 70                    << " but is " << cols << " at row " << rows << endl;
 71               exit (1);
 72              }
 73           }
 74        }
 75      iFile.close();
 76
 77      mat.resize(rows, cols);
 78      Int k3 = 0;
 79      for (Int i3=0;i3<rows;i3++)
 80         for (Int j3=0;j3<cols;j3++)
 81            mat(i3,j3) = temp[k3++];
 82
 83    }
 84
 85
 86   template <class T>
 87   void
 88   WriteAsciiFile(const char *fileout, Matrix<T> &mat)
 89     {
 90      Int rows, cols;
 91
 92      mat.shape(rows,cols);
 93      ofstream oFile;
 94      oFile.precision(12);
 95      oFile.open(fileout, ios::out);
 96      for (Int i1=0;i1<rows;i1++) {
 97         for (Int j1=0;j1<cols;j1++) {
 98            oFile << mat(i1,j1) << "  ";
 99           }
100          oFile << endl;
101         }
102      }

\end{verbatim}

\begin{description}
\item[10-] The inclusion of {\bf $<$fstream.h$>$} code is used to handle the reading from
and writing to an external file.

\item[11-] The {\bf $<$strstream.h$>$} is used to handle in-memory I/O 
i.e. to read a string that is
already in memory (presumably to read it with a new format).

\item[14-16-] This is the function declaration. The first argument is prefixed with 
the keyword {\bf const} which tells the compiler that this argument is NOT to
be modified by the function code. Note that the type of data to be stored in 
the Matrix is STILL undefined i.e. it is declared to be of whatever type
corresponds to the Matrix used in the calling sequence.

\item[18-] The dimension of the input string (each line of data) is stated as 1024.
A bit overgenerous perhaps, but what the heck!

\item[19-] Two arrays, {\bf buf} and {\bf buf2} of type {\bf char} are used as
described below.

\item[20-] The initial size of the Block that will first contain the values to be read
is stated here.  Unlike previous examples it is NOT a {\bf const} because we
might well need to increase its value during the operation of the routine.

\item[21-] A Block is used used to contain the values initially. This is used, rather
than a Matrix, because a Block can change size during the operation of a 
routine without losing its current content. (And since we have no idea how
large a data set we need to read we must be able to expand.)  A Matrix does
NOT have that ability.  Note that the dimension of a Block is stated within a
FORTAN-like pair of parentheses rather than square brackets!

\item[23-26-] The ASCII file from which we want to read the data is opened.
If the file 
cannot be opened for any reason the program will quit with an error
message.

\item[28-] The dimensions of the Matrix will be {\bf rows} and {\bf cols} whose values 
will be determined by the input. Since we will
only deal with rectangular arrays, the variable {\bf saveCols} will be used to
check that each row has the same number of columns.

\item[29-] The variable {\bf havePoint} will keep track of how full the {\bf temp}
Block is becoming. If the Block is becoming too full, it is expanded 
(doubled) by 
invoking the function {\bf resize} (in lines 39-41).

\item[31-] Reads an input line of up to {\bf bufSize} characters.
If there are no more lines go to the end of the
{\bf while} statement at line 74.

\item[32-36-] Check for a completly blank input line.  If one is found, the variable
{\bf blankLine} will be left at the value 1 (TRUE) and it will be simply skipped
by the test on line 38.

\item[39-] The test for the Block becoming too small makes provision for 10 more than
the next row. If the line holds more values than that, then there are other
problems to worry about!

\item[44-] Each line read (which may contain as many as 1024 characters) is presumed
to contain a complete row. 

\item[45-] The variable {\bf ch} counts the characters in each new variable being
read from the input string.  The variable {\bf startedNew} will be FALSE while 
we are bypassing
an indefinite number of blanks before each value. 

\item[46-] Starts the loop to scan an input line.

\item[47-56-] Check to see if we are at the end of a line or at a blank.  In either 
case see if we have already picked up the characters for a new number. If so,
add a terminating blank to the new number then call the internal IO routine 
to read it into a number in the {\bf temp} array.  Keep track of the number of
points read in this row.  In any case set the flag to bypass any more
blanks on this line.

\item[58-61-] If we have encountered a character and we were skipping blanks set the
{\bf startedNew} flag to TRUE.

\item[63-] If we are reading a new number, place the latest character on a string.

\item[75-] Close the input file.

\item[77-] Now we know the size of the array so go ahead and make the Matrix be the
appropriate size.

\item[78-81-] Transfer the data from the Block to the Matrix. NOTE the round 
parentheses surrounding the Matrix subscripts but the square brackets around
the Block subscript!  AAARGH!

\item[86-88-] This is declaring the second function, {\bf WriteAsciiFile}.

\item[92-] Since we need to handle ANY shape, we need to recover the value of the
{\bf rows} and {\bf cols} variables.

\item[93-] Declare an ASCII ouput file.

\item[94-] Set the precision with which we want to record output values. (The default
is 6 digits.)

\item[95-] Open the output file.

\item[96-98-] Copy the Matrix to the output, placing one space between each value.

\item[100-] Terminate each output line with an EOL (end-of-line aka newline).
\end{description}

\section{Sample Application}

        The previously described program was used to read from (and write to)
an ASCII file.  The input consisted of the following three matrices:


\begin{verbatim}
1.2345678901234  2.3456  3.4567 4.5678 5.6789 6.123456767  7.89789789
   1.1  2.2     3.     4      0      6.666        7.777       
  0     1       2      3      4      5      6


1 2
3 4
5 6


123.45678911234567   456.78   890.12  234.56789123456789
1.23     456.78   8.90    2.34
12.345   678.90   123.56  78.9012
567.89   567.99   345.65  12.3435
\end{verbatim}

        The output produced by the program was:

\begin{verbatim}
The first Matrix is 3 by 7
The second Matrix is 3 by 2
The third Matrix is 4 by 4


Axis Lengths: [3, 7]  (NB: Matrix in Row/Column order)
[1.23456789012, 2.3456, 3.4567, 4.5678, 5.6789, 6.123456767, 7.89789789
 1.1, 2.2, 3, 4, 0, 6.666, 7.777
 0, 1, 2, 3, 4, 5, 6]

Axis Lengths: [3, 2]  (NB: Matrix in Row/Column order)
[1, 2
 3, 4
 5, 6]

Axis Lengths: [4, 4]  (NB: Matrix in Row/Column order)
[123.456787109, 456.779998779, 890.119995117, 234.567886353
 1.23000001907, 456.779998779, 8.89999961853, 2.33999991417
 12.345000267, 678.900024414, 123.559997559, 78.9011993408
 567.890014648, 567.989990234, 345.649993896, 12.3435001373]
\end{verbatim}


        The file written by the program looked like this (the first line is 
shown on two lines because of page-width limitations):

\begin{verbatim}
1.23456788063  2.34559988976  3.45670008659  4.56780004501  5.67889976501
  6.12345695496  7.89789772034  
1.10000002384  2.20000004768  3  4  0  6.66599988937  7.77699995041  
0  1  2  3  4  5  6  
\end{verbatim}

        

\newpage
\section{The Vector modules}
 
        The previous sections of this example demonstrated the use of
{\bf templates}. The next two, briefer, sections will demonstrate 
{\bf polymorphism}, namely the ability to define a function with two or more
sets of different argument types.  In particular, we will add to the definition
of {\bf ReadAsciiFile} a module to read {\bf Vectors} instead of {\bf Matrices}.
The following is the program which calls the new functions
(The \htmladdnormallink{source code}{../../../code/trial/implement/test/tExample4.cc}
for this program is found in 
\$AIPSROOT/code/trial/implement/test/tExample4.cc). 

\begin{verbatim}
  1  #include <aips/aips.h>
  2  #include <aips/IO/AipsIO.h>
  3  #include <aips/Arrays/ArrayIO.h>
  4  #include <aips/Inputs/Input.h>
  5  #include <aips/Mathematics/Math.h>
  6  #include <aips/Arrays/Matrix.h>
  7
  8  main(int argc, char **argv)
  9  {
 10   Input inputs(1);
 11   inputs.Version("$@w{Revision}$");
 12   inputs.Create("infile1","Input1","Float Input file name?","Infile");
 13   inputs.Create("infile2","Input2","Vector Input file name?","Infile");
 14   inputs.Create("outfile","Output","Vector Output file name?","Outfile");
 15   inputs.ReadArguments(argc, argv);
 16
 17   const char *filein1 = inputs.GetString("infile1");
 18   const char *filein2 = inputs.GetString("infile2");
 19   const char *fileout = inputs.GetString("outfile");
 20
 21   Int rows, cols;
 22   try {
 23      Matrix <Float>  mat1;
 24      Vector <Float>  vect1;
 25
 26      readAsciiFile(filein1, mat1);    mat1.shape(rows, cols);
 27      cout << "The Matrix is " << rows << " by " << cols << endl;
 28      readAsciiFile(filein2, vect1);   vect1.shape(rows);
 29      cout << "The Vector is " << rows << " long" << endl;
 30
 31      writeAsciiFile(fileout, vect1);
 32      cout << mat1 << vect1 << endl;
 33   }
 34
 35   catch (AipsIOError x) {
 36      cerr << "aipsioerror: error " << x.getMesg() << endl;
 37      return 1;
 38   }
 39   catch (AipsError x) {
 40      cerr << "aipserror: error " << x.getMesg() << endl;
 41      return 1;
 42   }
 43   return 0;
 44  }
\end{verbatim}

\begin{description}
\item[6-] We inadvertently omitted the reference to {\bf Vectors} but got away with it!
The reason is that the definition of {\bf Vectors} is included in the definition
of {\bf Matrix}.  It is NOT good practice to do this since modules may change.

\item[13-14-] We ask for the Vector (rather than Matrix) name. (A minor point.)

\item[24-] We will only demonstrate {\bf Float} data type for {\bf Vectors} but they will
be defined for the full variety of data types.

\item[28-] We call for {\bf Vector} data. Note that the function {\bf shape} works for
1-dimensional arrays as well as for the 2-dimensional ones.
\end{description}


\newpage
\section{The expanded {\bf include} modules}

        In this module we placed the boiler-plate that was discussed in the 
earlier example but we do not show it merely to save space.

\begin{verbatim}
30  
31  #if !defined (AIPS_ASCIIFILEIO_H)
32  #define AIPS_ASCIIFILEIO_H
33  
34  #include <aips/aips.h>
35  #include <aips/Matrix.h>
36  #include <aips/Vector.h>
37  
38  template <class T>
39     void
40     ReadAsciiFile(const char *filein, Matrix<T> &mat);
41  template <class T>
42     void
43     WriteAsciiFile(const char *fileout, Matrix<T> &mat);
44  
45  template <class T>
46     void
47     ReadAsciiFile(const char *fileout, Vector<T> &vect);
48  template <class T>
49     void
50     WriteAsciiFile(const char *fileout, Vector<T> &vect);
51  
52  #endif
\end{verbatim}

\begin{description}
\item[45-50-] These declarations are similar to the ones for {\bf Matrices} except that
they take {\bf Vectors} as their arguments.  Note that we did NOT have to change
the function name - hence polymorphism!
\end{description}


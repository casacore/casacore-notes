\chapter{System generation}
\label{System generation}
\index{system!generation}

Utilities for installing \aipspp\ and compiling object libraries, executables,
and documentation \footnote{Last change:
$ $Id$ $}.

% ----------------------------------------------------------------------------

\section{\exe{configure}}
\label{configure}
\index{configure@\exe{configure}}
\index{code!distribution!installation|see{\exe{configure}}}
\index{system!installation|see{\exe{configure}}}

\aipspp\ installation script.

\subsection*{Synopsis}

\begin{synopsis}
   \exe{configure}
\end{synopsis}

\subsection*{Description}

\exe{configure} is used as the first step in installing \aipspp, either from
scratch, or to add a new architecture (see \sref{End-user installation}) and
(\sref{Consortium installation}).  In the latter case the installation of the
\exeref{aipsinit} scripts and databases can be skipped.

A copy of \exe{configure} resides in
\file{aips2.nrao.edu:/pub/aips++/code\_ftp} on the \aipspp\ anonymous
\unixexe{ftp} server together with the compressed \unixexe{tar} files which
constitute an \aipspp\ installation kit (see \sref{ftp directories} for a
description of the \aipspp\ ftp directory structure).

Once \exe{configure} has been activated the installation consists of answering
a few questions, most of which have sensible default answers.  \exe{configure}
first ensures that certain utilities that it needs are available.  These are
\gnu\ \unixexe{gzip} and \gnu\ \exereff{make}{gmake}.  If they aren't it
fetches them from the consortium site and if necessary, installs
\unixexe{gzip} temporarily in the current directory.  It then unloads any
compressed \unixexe{tar} files present in the current directory.

\exe{configure} next installs the \exeref{aipsinit} scripts and constructs the
\file{\$AIPSROOT/}\filref{aipshosts} database via a simple inbuilt editor
(\aipspp\ variable names are listed in \sref{variables}).  Once the host
architectures, site-name, and host-names are known, \exe{configure} invokes
\aipsexe{aipsinit} for itself and then creates the \aipspp\ system directory
tree for each architecture.  With a \file{bin} directory now in existence,
\exe{configure} reinstalls \unixexe{gzip} if necessary, and likewise
\exeref{gmake}.

Before \aipsexe{gmake} can be invoked, however, the site-specific
\filref{makedefs} file must be defined.  This contains definitions used by
\aipsexe{gmake} for directories, compiler options and the like.  Generic
definitions are provided in \file{\$AIPSARCH/makedefs} but several of these
have no sensible default and must be defined on a per-installation basis.  If
none already exists, \exe{configure} installs a template \filref{makedefs}
file in \file{\$AIPSSITE} and invites the installer to make the appropriate
entries with a text editor in another window (or by suspending
\exe{configure}).  When the user is satisfied, \exe{configure} checks to make
sure that all definitions are sensible (see \filref{testdefs}), and then
repeats the process for the site-specific \filref{aipsrc}).

At this point the system should have been bootstrapped to a state where a
recursive \aipsexe{gmake} may be used to check-out all code and build the
system, and this \exe{configure} now does (see \sref{System generation}).

\subsection*{Options}

None.

\subsection*{Resources}

Construction of the \file{aipsrc} databases is part of \exe{configure}'s job.

\subsection*{Diagnostics}

Status return values correspond to the various phases of the operation
\\ \verb+   0+: success
\\ \verb+   1+: initialization error
\\ \verb+   2+: error fetching required utilities or installing \unixexe{gzip}
\\ \verb+   3+: error extracting compressed \unixexe{tar} files
\\ \verb+   4+: error installing the \exeref{aipsinit} scripts or databases
\\ \verb+   5+: error constructing the system directory tree
\\ \verb+   6+: error installing \unixexe{gzip}, \aipsexe{gmake}
\\ \verb+   7+: error installing local \file{makedefs} and \file{aipsinit} files

\subsection*{See also}

The \gnu\ manual page for \unixexe{gzip}.\\
The \gnu\ manual page for \unixexe{gmake}.\\
\aipspp\ variable names (\sref{variables}).\\
Installing an \aipspp\ production-line system (\sref{End-user installation}).\\
Installing an \aipspp\ code-development system
   (\sref{Consortium installation}).\\
\filref{aipshosts}, \aipspp\ hosts database.\\
\filref{aipsrc}, \aipspp\ resource database.\\
\exeref{getrc}, query \aipspp\ resource database.\\
\filref{makedefs}, \aipspp\ makefile definitions.\\
\filref{testdefs}, test \filref{makedefs} definitions.

\subsection*{Author}

Original: 1992/04/09 by Mark Calabretta, ATNF.

% ----------------------------------------------------------------------------

\newpage
\section{\exe{depend}}
\label{depend}
\index{depend@\exe{depend}}
\index{dependency analysis!system|see{\exe{depend}}}
\index{system!installation!dependency analysis|see{\exe{depend}}}
\index{system!generation!dependency analysis|see{\exe{depend}}}
\index{c++@\cplusplus!dependency analysis|see{\exe{depend}}}

Produce a dependency list for \aipspp\ class implementation files.

\subsection*{Synopsis}

\begin{synopsis}
   \code{\exe{depend} \exe{-p} package file1 [file2...]}
\end{synopsis}

\subsection*{Description}

\exe{depend} produces a list of dependencies of \aipspp\ class implementation
files in relation to their included header files.  The dependency lists and
timestamp files for each package/module are stored in \file{\$ARCHAUXD}
(\aipspp\ system directories are described in \sref{System directories}).  The
depencency lists have names of the form
\file{\textit{package}-\textit{module}.list}.  The module name may be empty to
indicate class implementation files which reside in the \file{implement}
directory itself.

\exe{depend} works for system compilations only, dependency analysis for
programmer compilations is handled separately.

The \file{implement} \filreff{makefile}{makefiles} includes the dependency
list associated with the package and module of the directory that it is
processing.  Thus, \exe{depend} is normally invoked automatically by the
\file{implement} makefile as part of the process of updating the files
included by it.  The list of files passed to \exe{depend} in that case
consists of all \file{.cc} files for the module and all \file{.h} files newer
than the \file{.time} timestamp file produced by \exe{depend} on its last
execution.

Beware that invoking \exe{depend} manually with an incomplete list of files
could invalidate the dependency analysis.

The \cplusplus\ header and implementation files may be specified in full or
in brief.  For example, in full:

\begin{verbatim}
   /aips++/code/aips/implement/Foo.cc
   /aips++/code/aips/implement/Foo.h
   /aips++/code/include/aips/Foo.h

   /aips++/code/aips/implement/module/Bar.cc
   /aips++/code/aips/implement/module/Bar.h
   /aips++/code/include/aips/module/Bar.h
\end{verbatim}

\noindent
(the last two are the same file) or in brief:

\begin{verbatim}
   Foo.cc
   aips/Foo.h

   module/Bar.cc
   aips/module/Bar.h
\end{verbatim}

\noindent
Note that the implementation files must correspond to the package-module
combination specified via the \exe{-p} option, but the header files may belong
to any package and so must have a package and module name associated with
them.

\subsection*{Options}

\begin{description}
\item[\code{\exe{-p} package[-module]}]
   The \aipspp\ package-module combination.  There is no default for the
   package name.  An empty module name indicates the \file{implement}
   directory itself.
\end{description}

\subsection*{Notes}

\begin{itemize}
\item
   The complete list of header and implementation files for a package given in
   full form may blow the environment in some operating systems and the brief
   form should therefore be used.

\item
   \exe{depend} is designed for parallel execution on any number of machines.
   It uses a ``pull-queue'' mechanism so that no machine needs to know about
   any of the others.  Parallel execution may be implemented for installations
   which maintain more than one architecture by defining \file{\$ARCHAUXD} for
   the second and subsequent architectures to be symbolic links to
   \file{\$ARCHAUXD} for the first architecture.

\item
   The dependency analysis done for programmer compilations does not use
   \exe{depend}.
\end{itemize}

\subsection*{Diagnostics}

Status return values
\\ \verb+   0+: success
\\ \verb+   1+: initialization error

\subsection*{Examples}

\exe{depend} should not be invoked manually (as explained above).  It is used
by the \file{implement} \filreff{makefile}{makefiles}.

\subsection*{Files}

\begin{description}
\item[\file{\$ARCHAUXD/\textit{package}-\textit{module}.list}]
...the dependency list for a package and module.

\item[\file{\$ARCHAUXD/\textit{package}-\textit{module}.time}]
...timestamp file for the dependency list.
\end{description}

\subsection*{See also}

\aipspp\ system directories (\sref{System directories}).\\
\filref{makefiles}, \gnu\ makefiles used to rebuild \aipspp.

\subsection*{Author}

Original: 1993/01/25 by Mark Calabretta, ATNF

% ----------------------------------------------------------------------------

\newpage
\section{\exe{gmake}}
\label{gmake}
\index{gmake@\exe{gmake}}
\index{code!distribution!gmake@\exe{gmake}}
\index{system!installation!gmake@\exe{gmake}}
\index{system!generation!gmake@\exe{gmake}}
\index{make@\exe{make}|see{\exe{gmake}}}

\gnu\ \exe{make} - a program for directing recompilation.

\subsection*{Synopsis}

\begin{synopsis}
   \code{\exe{gmake} [options] [targets]}
\end{synopsis}

\subsection*{Description}

\exe{gmake} is the name used within \aipspp\ to differentiate the \gnu
\unixexe{make} executable from the many other flavours of \exe{make} available
on unix systems.

\gnu\ \unixexe{make} is essential for \aipspp, and is installed automatically
by \exeref{configure} as ``\exe{gmake}'' when \aipspp\ is first installed.

\gnu\ \unixexe{make} has many features which make it preferable to any other
form of \unixexe{make}.  It can process makefiles written for most flavours of
\unixexe{make} although the converse is not true.

\gnu\ \unixexe{make} is free software provided by the Free Software
Foundation.

\subsection*{Notes}

\begin{itemize}
\item
   Version 3.71 or later is required.

\item
   \textsc{posix.2} compliance for \unixexe{make} applies largely to the way
   makefiles themselves are written, and essentially restricts functionality
   to the lowest common denominator of all the many varieties of
   \unixexe{make}.  This means it would be it very difficult to write portable
   \textsc{posix.2} compliant makefiles for \aipspp, so \gnu\ \code{Make} has
   been adopted instead.  \gnu\ \code{Make} is itself \textsc{posix.1} and
   \textsc{posix.2} compliant, and so satisfies the ``\textsc{posix}
   compliance'' criteria originally set for \aipspp.
\end{itemize}

\subsection*{See also}

The \gnu\ \code{Make} manual.\\
The \gnu\ manual page for \unixexe{make}.\\
\exeref{configure}, the \aipspp\ installation script.\\
\filref{makedefs}, \aipspp\ makefile definitions.\\
\filref{makefiles}, \gnu\ makefiles used to rebuild \aipspp.
 
% ----------------------------------------------------------------------------

\newpage
\section{\file{makedefs}}
\label{makedefs}
\index{makedefs@\file{makedefs}}
\index{system!generation!makedefs@\file{makedefs}|see{\file{makedefs}}}
\index{database!makefiles|see{\file{makedefs}}}

Installation-specific definitions used by the \aipspp\ makefiles.

\subsection*{Synopsis}

\begin{synopsis}
   \file{makedefs}
\end{synopsis}

\subsection*{Description}

The \file{makedefs} file is a \gnu\ makefile which defines variables and rules
common to all \aipspp\ makefiles.  It contains comments addressed to \aipspp
managers who must construct and maintain a site-specific version and as such
is intended to be self-documenting.  However, the following notes are provided
as a general overview.

\subsubsection*{Default definitions}

The \aipspp\ \file{makedefs} files contain definitions used by the \aipspp\ 
makefiles for object libraries, include directories and paths, compiler
options and the like.

Every \aipspp\ makefile includes the default \file{makedefs} file at an early
stage via a sequence similar to the following:

\begin{verbatim}
   # AIPS++ fundamentals.
   #---------------------
   AIPSROOT := $(word 1, $(AIPSPATH))
   AIPSARCH := $(AIPSROOT)/$(word 2, $(AIPSPATH))
   include $(AIPSARCH)/makedefs
\end{verbatim}

\noindent
(see \sref{variables} for \aipspp\ variable names).

The default \file{makedefs} guarantees to supply a definition for every
primary variable used by the \aipspp\ makefiles to control compilations.
While the default values supplied for some of these are unlikely to be
correct, they are provided as an indication of what may need to be redefined
in the site-specific \file{makedefs} file for each architecture.

The default \file{makedefs} file also defines many other variables, such as
directory locations, which are applicable to all \aipspp\ installations
and do not need to be redefined.

\subsubsection*{Site-specific definitions}

While \file{\$AIPSARCH/makedefs} contains generic definitions of variables used
in the \aipspp\ makefiles, a number of these have no sensible defaults and
must be redefined on a site-wide basis for each architecture in
\file{\$AIPSSITE/makedefs} (\sref{System directories} describes the \aipspp\ 
system directory structure).  The default file includes the site-specific file
and definitions made in the latter override those of the former.

Part of the process of installing \aipspp\ involves defining the site-specific
\filref{makedefs} file.  The installation utility, \exeref{configure},
provides a template version tailored for each architecture and requires the
installer to carefully read through the default \file{makedefs} file and make
the appropriate redefinitions.  \aipsexe{configure} then uses \filref{testdefs}
to ensure that all of the definitions are sensible.

As an example, the default \file{makedefs} file contains the following
definitions for the location of the \textsc{X11} windowing system's include
files and libraries:

\begin{verbatim}
   X11ROOT  := /usr/local/X11
   X11INCD   = $(X11ROOT)/include
   X11LIB    = -L$(X11ROOT)/lib -lX11
\end{verbatim}

\noindent
Note that \code{X11ROOT} is defined as a ``simply expanded'' variable in \gnu
\unixexe{make}.  These are defined using ``\code{:=}'' and are evaluated
immediately.  On the other hand, \code{X11INCD} and \code{X11LIB} are defined
as ``recursively expanded'' variables expressed in terms of \code{X11ROOT}.
Recursively expanded variables are defined using ``\code{=}'' and are
evaluated when used.  This construct allows the site-specific \file{makedefs}
files to redefine \code{X11ROOT} without necessarily needing to redefine the
other two.

As an example, supposing that \textsc{X11} was installed locally in
\file{/usr/X11} with include files and libraries in the usual \file{include}
and \file{lib} subdirectories, then the site-specific \file{makedefs} need
only make the following redefinition:

\begin{verbatim}
   X11ROOT  := /usr/X11
\end{verbatim}

\noindent
Note that all variable definitions in the site-specific \file{makedefs} files
should be ``simply expanded''.  In general the site-specific files should not
redefine any more than is necessary; this is particularly the case for
\aipspp\ consortium installations which are continually evolving.  For
example, if at some later time an \aipspp\ application was written which
used the Athena widget set, then the default value of \code{X11LIB} might be
reset to

\begin{verbatim}
   X11LIB    = -L$(X11ROOT)/lib -lXaw -lX11
\end{verbatim}

\noindent
and in the above example the change to the default value of \code{X11LIB}
would have effect without any changes required to the site-specific
\file{makedefs}.  On the other hand, if the site-specific \file{makedefs} file
had redefined \code{X11LIB} then it would have to be amended to add the
\code{Xaw} library.

\subsubsection*{System versus programmer usage}

As described in the entry for \filref{makefiles}, the \aipspp\ makefiles serve
the dual purpose of directing both system and programmer compilations.  These
programmer-oriented definitions are only of interest in \aipspp\ development
systems and may safely be ignored in production line installations.

System and programmer oriented variables and rules mostly reside together in
the makefiles without conflict.  To help resolve the few cases where conflicts
can occur \file{makedefs} sets a variable, \code{MAKEMODE}, to either
``\code{system}'' or ``\code{programmer}'' depending on whether the
\exeref{gmake} was initiated from a system or programmer directory.  It is
currently used to choose the default target and to circumvent certain time
consuming system dependency analyses which are not required for programmer
compilations.

\subsubsection*{Other variables defined within \file{makedefs}}

The default \file{makedefs} defines a collection of variables which are not
permitted to be redefined in the site-specific \file{makedefs}.  Of these, one
group may be redefined on the \exeref{gmake} command line.  These mainly
define the location of \aipspp\ directories and although there are rare
occasions when the \aipspp\ code distribution system needs to reset them, this
should never be necessary in normal usage.

A second small group of ``immutable'' variables defined at the start of
\file{makedefs} are used mainly for job control and syntactic purposes in the
\aipspp\ makefiles.  These are not permitted to be redefined even on the
\aipsexe{gmake} command line.

\subsubsection*{Rules defined in \file{makedefs}}

A cursory glance through \file{\$AIPSARCH/makedefs} will be sufficient to show
that it contains much more than just default variable definitions.  In fact,
it is a self-contained \gnu\ makefile and can be, and is, invoked by itself by
some parts of the \aipspp\ build system.  However, these ``nether'' sections
of \file{makedefs} can safely be ignored by \aipspp\ system managers.

Since it is included by all \aipspp\ makefiles, \file{makedefs} is the
appropriate place to define the many rules which are common to all of them.
It would be very difficult if not impossible to understand the functioning of
any of the \aipspp\ makefiles without reference to \file{makedefs}.

The main pattern rule defined within \file{makedefs} is that for checking out
source code (if the \aipspp\ installation includes \rcs\ repositories).
Apart from that, \file{makedefs} contains many static rules; their definitions
fall into several categories (refer to the \gnu\ \unixexe{make} manual for an
explanation of how rules are written):

\begin{itemize}
\item
   Single-colon rules without commands, with or without dependencies; an
   including makefile may define the commands and add additional dependencies.
   Examples are \code{all} and \code{allsys}, \code{docsys}, \code{docscan}
   and \code{docextr}.

   \code{FORCE}, the target of a single-colon rule with no dependencies or
   commands, is used as a dependency to force a target to be remade.  It
   should not be altered by an including makefile.

\item
   Single-colon rules with commands, with or without dependencies; an
   including makefile may add additional dependencies but no additional
   commands.  These rules are usually meant to be completely defined within
   \file{makedefs} and not augmented by the including makefile.  Examples are
   \code{chkout}, \code{eval\_vars} and \code{show\_sys}.

   Some of this class of rules such as \code{dependsys} are defined in
   \file{makedefs} solely to establish their recursive nature.  Such rules may
   be invoked in any directory and will recurse into every subdirectory but
   only actually do anything in the directories where the rule is augmented
   with a dependency list by the makefile which includes \file{makedefs}.

   Others of this class of rules have as a dependency a phony target of the
   same name preceded by a ``\code{.}'' which may be defined in the including
   makefile to do specific operations {\em before} the commands defined in
   the \file{makedefs} rule are executed.  These phony targets are also
   declared in \file{makedefs} to save having to do that in the including
   makefile if they're not required.  The \code{clean} target is an example of
   this.

\item
   Double-colon rules with commands, with or without dependencies; an
   including makefile may define double-colon rules of the same name with
   commands, with or without dependencies; these rules are independent and are
   executed sequentially.  The \code{help} target is an example, the
   \file{makedefs} rule for this lists general targets and the corresponding
   rule in the including makefile lists additional targets defined therein.
\end{itemize}

Organized by category, \filref{makedefs} declares and possibly lists
dependencies and defines rules for the following targets (see also
\filref{makefiles}):

\begin{itemize}
\item
   \code{.PHONY} target declarations.

\item
   Declaration of the default target \code{allsys} for system invokations and
   \code{all} for programmer invokations.

\item
   General purpose targets such as \code{FORCE} and \code{null}.

\item
   Rules for \file{makedefs} and the makefiles to update themselves.

\item
   The \code{chkout} target for recursively checking out all sources (if the
   \rcs\ repositories are present).

\item
   Rules for processing subdirectories by name, both for system and
   programmer.

\item
   Rules for creating the \aipspp\ system directories if they don't already
   exist.

\item
   General \code{clean} type rules for deleting intermediate files.  These
   have as a dependency a target whose rule may be supplied by the including
   makefile for deleting intermediate files which are specific to that
   makefile.

\item
   A rule, \code{recurse}, which recursively invokes a non-recursive rule
   specified by the value of the \code{TARGET} variable.  For example,
   \code{gmake TARGET=clean recurse}.

\item
   A rule, \code{command}, which invokes a command specified by the value of
   the \code{COMMAND} variable.  For example,
   \code{gmake COMMAND=env command}.

\item
   Rules defined for diagnostic purposes, including rules for reporting
   variable definitions.

\item
   A \code{help} target which lists the main targets defined in
   \file{makedefs}.  This is defined as a double-colon rule and the including
   makefile can supply the corresponding rule to list additional targets
   defined therein.
\end{itemize}

\noindent
The makefile targets are discussed in detail elsewhere (\sref{makefiles}).

\subsection*{Notes}

\begin{itemize}
\item
   The site-specific \file{makedefs} is a valid makefile in its own right and
   in principle new features could be added through it, in particular, new
   targets and conventions.  In practice, such features should be added
   judiciously lest the \aipspp\ programming environment deviate too far
   from the norm and make it difficult to diagnose problems.

   Useful features may be developed and evaluated in the site \file{makedefs}
   before being incorporated into the default \file{makedefs}.

\item
   The default \file{makedefs} is a critical part of the \aipspp\ code
   distribution system.  If a syntactically incorrect version was distributed
   to consortium sites, and if the damage was such that the broken version
   could not install a repaired version subsequently distributed, then the
   rebuild part of the code distribution system would be broken.
\end{itemize}

\subsection*{Files}

\begin{description}
\item[\file{\$AIPSARCH/makedefs}]
...defaults values.

\item[\file{\$AIPSSITE/makedefs}]
...site-specific values for each architecture.
\end{description}

\subsection*{See also}

The \textit{GNU make} manual.\\
The \gnu\ manual page for \unixexe{gmake}.\\
\aipspp\ variable names (\sref{variables}).\\
\exeref{configure}, the \aipspp\ installation script.\\
\exeref{gmake}, \gnu\ make.\\
\filref{makedefs adjuncts}, Per-sourcefile makedefs definitions.\\
\filref{makefiles}, \gnu\ makefiles used to rebuild \aipspp.\\
\filref{testdefs}, test \file{makedefs} definitions.

\subsection*{Author}

Original: 1992/05/01 by Mark Calabretta, ATNF

% ----------------------------------------------------------------------------

\newpage
\section{\file{makedefs} adjuncts}
\label{makedefs adjuncts}
\index{makedefs@\file{makedefs}!adjunct}
\index{adjunct|see{\file{makedefs}, adjunct}}
 
Per-sourcefile makedefs definitions.
 
\subsection*{Description}

The \file{app}, \file{imp}, \file{ftn} and \file{tst} makefiles
(\sref{makefiles}) look for and, if found, include an adjunct \filref{makedefs}
file which may contain definitions (or, in principle, rules) which apply to a
particular source code directory.  The adjunct files are architecture-specific
and are primarily intended to control compiler options on a per-sourcefile
basis.

The adjunct files reside in \code{\$INSTARCH} (see \sref{variables}) and have
names of the following form

\begin{verbatim}
                           Form                       Examples
            ---------------------------------   ---------------------
   imp      <package>[-<module>].defs           aips.defs
                                                aips-Tables.defs
   tst      <package>[-<module>]-test.defs      aips-Tables-test.defs
   ftn      <package>-fortran[-<module>].defs   aips-fortran.defs
   app      <package>_<app>.defs                aips_gtable.defs
\end{verbatim}

\noindent
As a simple example of the use of a \file{makedefs} adjunct, the applications
makefile uses a variable called \code{BIN} as a hook to allow conditional
compilation of an application.  If \code{BIN} is set to blank in an adjunct
file for a particular architecture then compilation of that particular
application will be skipped during a recursive system build.

The following adjunct \file{makedefs} decreases the optimization level for
\file{TSMCube.cc} for the \gnu\ \cplusplus\ compiler running under
\textsc{OSF/1}.  The file,
\file{\$(AIPSCODE)/install/alpha\_gnu/aips-Tables.defs}, is included by the
implement makefile, and it illustrates the general scheme:

\begin{verbatim}
   # Switch off optimization for TSMCube.
 
   LVL  := $(C++OPTLVL)
   LVL0 := -O0
 
   TSMCube := 0
 
   C++OPTLVL = $(LVL$($*))
\end{verbatim}

\noindent
Although this is a non-trivial construct the general form should be easy to
follow.  The operative part is the last line in which \code{C++OPTLVL}, a
recursively expanded \file{makedefs} variable which determines the \cplusplus
optimization level, is evaluated as a ``computed'' variable within the pattern
rule which compiles \file{TSMCube.o} from \file{TSMCube.cc}:

\begin{enumerate}
   \item Within the pattern rule, \code{\$*} is an ``automatic'' variable
         which evaluates to the stem with which the pattern rule matches, in
         this case \code{TSMCube}.  After the first round of translation
         \code{C++OPTLVL} would be set to \code{\$(LVL\$(TSMCube))}.

   \item \code{\$(TSMCube)} is evaluated in the second round of translation
         after which \code{C++OPTLVL} would become \code{\$(LVL0)}.

   \item The required result, \code{C++OPTLVL~=~-O0}, is achieved after the
         third round of translation.
\end{enumerate}

\noindent
For any other source file in the \file{\$(AIPSCODE)/aips/implement/Tables/}
directory, say \file{Table.cc}, the sequence would be as follows:
 
\begin{enumerate}
   \item After the first round of translation \code{C++OPTLVL} would be set to
         \code{\$(LVL\$(Table))}.
 
   \item In the second round of translation \code{\$(Table)} is undefined and
         evaluates to an empty string whence \code{C++OPTLVL} would become
         \code{\$(LVL)}.
 
   \item After the third round of translation \code{C++OPTLVL} is set to its
         original value by virtue of the simply expanded variable assignment
         of \code{LVL} at the start of the adjunct makedefs.
\end{enumerate}

\noindent
The default case relied on \code{Table} being undefined as a makefile
variable.  This is a safe assumption since makefile variable names are
case-sensitive and while \aipspp\ source file names contain a mixture of
upper- and lower-case characters, the \file{makedefs} and \file{makefile}
variables in \aipspp\ are all upper-case.

The \file{makedefs} variables which specify debug or optimization flags for
the various compilers are

\begin{description}
   \item[\code{C++DBGLVL}]  ...\cplusplus\ debug flags
   \item[\code{C++OPTLVL}]  ...\cplusplus\ optimization flags
   \item[\code{CDBGLVL}]    ...\textsc{c} debug flags
   \item[\code{COPTLVL}]    ...\textsc{c} optimization flags
   \item[\code{FCDBGLVL}]   ...\textsc{fortran} debug flags
   \item[\code{FCOPTLVL}]   ...\textsc{fortran} optimization flags
\end{description}

\noindent
These variables are not used directly in the makefiles but are instead used as
components in the definition of variables which contain all of the compiler
flags.  An imporant prerequisite for this system is that these variables,
namely \code{C++DBG}, \code{C++OPT}, \code{CDBG}, \code{COPT}, \code{FCDBG},
and \code{FCOPT}, be recursively expanded.  This also applies for the
programmer compilation option variables \code{C++FLAGS}, \code{CFLAGS}, and
\code{FCFLAGS}.

\subsection*{See also}
 
The \textit{GNU make} manual.\\
The \gnu\ manual page for \unixexe{gmake}.\\
\aipspp\ variable names (\sref{variables}).\\
\exeref{gmake}, \gnu\ make.\\
\filref{makedefs}, \aipspp\ makefile definitions.\\
\filref{makefiles}, \gnu\ makefiles used to rebuild \aipspp.

% ----------------------------------------------------------------------------

\newpage
\section{\file{makefiles}}
\label{makefiles}
\label{makefile.app}
\label{makefile.aps}
\label{makefile.chk}
\label{makefile.doc}
\label{makefile.ftn}
\label{makefile.imp}
\label{makefile.pkg}
\label{makefile.scr}
\label{makefile.tst}
\index{makefile}
\index{makefile!application}
\index{makefile!applications}
\index{makefile!checkout}
\index{makefile!class implementation}
\index{makefile!documentation}
\index{makefile!fortran@\textsc{fortran}}
\index{makefile!install}
\index{makefile!package}
\index{makefile!scripts}
\index{makefile!test}
\index{makefile!top-level}
\index{makefile.app@\file{makefile.app}|see{makefile, application}}
\index{makefile.aps@\file{makefile.aps}|see{makefile, applications}}
\index{makefile.chk@\file{makefile.chk}|see{makefile, checkout}}
\index{makefile.doc@\file{makefile.doc}|see{makefile, documentation}}
\index{makefile.ftn@\file{makefile.ftn}|see{makefile, \textsc{fortran}}}
\index{makefile.imp@\file{makefile.imp}|see{makefile, class implementation}}
\index{makefile.pkg@\file{makefile.pkg}|see{makefile, package}}
\index{makefile.scr@\file{makefile.scr}|see{makefile, scripts}}
\index{makefile.tst@\file{makefile.tst}|see{makefile, test}}
\index{compilation!system|see{system, generation}}
\index{documentation!makefile|see{makefile, documentation}}
\index{c++@\cplusplus!compilation|see{makefile, class implementation}}
\index{fortran@\textsc{fortran}!compilation|see{makefile, \textsc{fortran}}}
\index{rules|see{makefile, rules}}
\index{system!verification!test makefile|see{makefile, test}}
\index{targets|see{makefile, rules}}

\gnu\ makefiles used to rebuild \aipspp

\subsection*{Synopsis}

\begin{synopsis}
   \file{makefile}\\
   \file{makefile.\{app,aps,chk,doc,ftn,imp,pkg,scr,tst\}}
\end{synopsis}

\subsection*{Description}

Compilation of the \aipspp\ system from its sources is accomplished via a
hierarchical system of \gnu\ makefiles (\sref{gmake}).  The top-level makefile
resides in \file{\$AIPSCODE} (\sref{variables}) and certain targets cause all
makefiles residing in the subdirectories below to be invoked recursively.  In
this way all of the \aipspp\ executable scripts, object libraries,
applications, and documentation may be compiled and installed with a single
invokation of \aipsexe{gmake}.

In addition to these {\em system-oriented} targets, the makefiles also have a
set of {\em programmer-oriented} targets designed for code development.

Before examining the makefile targets in detail I will briefly summarize the
general features of the \aipspp\ system of makefiles:

\begin{itemize}
\item
   Every \aipspp\ source directory contains a makefile called
   \file{makefile} (\file{.dir} subdirectories are the only valid exceptions).
   Most of these makefiles simply \file{include} one of the following
   {\em generic} makefiles from \file{\$CODEINSD}:

   \begin{itemize}
   \item
      \file{makefile.app}  (application subdirectory)
   \item
      \file{makefile.aps}  (\file{apps} directory)
   \item
      \file{makefile.chk}  (checkout)
   \item
      \file{makefile.doc}  (documentation)
   \item
      \file{makefile.ftn}  (\file{fortran} directory)
   \item
      \file{makefile.imp}  (\file{implement} directory)
   \item
      \file{makefile.pkg}  (package)
   \item
      \file{makefile.scr}  (\file{scripts} directory)
   \item
      \file{makefile.tst}  (\file{test} directory)
   \end{itemize}

   These are referred to below by their three-letter file suffix, namely
   \file{app}, \file{aps}, \file{chk}, \file{doc}, \file{ftn}, \file{imp},
   \file{pkg}, \file{scr}, and \file{tst}.

\item
   Every makefile includes (whether directly or indirectly) an
   architecture-specific makefile, \file{\$AIPSARCH/}\filref{makedefs}, which
   defines variables and rules common to all \aipspp\ makefiles.

\item
   The makefiles contain a set of system-oriented targets for rebuilding the
   \aipspp\ system (see \sref{System directories}), and a set of
   programmer-oriented targets for code development in programmer workspaces
   (\sref{AIPS++ programmer setup}).  They also contain diagnostic targets for
   reporting makefile variable definitions, versions of installed software,
   for running system verification procedures, and printing a list of
   targets and their functions.

\item
   The makefiles recognize that the \aipspp\ installation may or may not
   have a copy of the \rcs\ source code repositories (see
   \sref{RCS directories}).  If the repositories are present, the plain-text
   copies are automatically updated if necessary.  In particular, the
   makefiles contain targets which cause \exeref{gmake} to update the makefile
   itself and any included files before attempting to remake anything else.

\item
   The makefiles usually do not contain lists of source files but instead
   construct them via \gnu\ \unixexe{make}'s \code{wildcard} function.  This
   means that new files checked into \aipspp\ are discovered automatically by
   the makefiles.

\item
   Any subdirectory which contains a makefile is also recognized as a target.
\end{itemize}

A few directories contain special-purpose makefiles, the main ones being the
top-level makefile in \file{\$AIPSCODE} (referred to as \file{top} below), and
the installation makefile in \file{\$CODEINSD} (referred to below as
\file{ins}).

The generic and special-purpose makefiles are collectively referred to below
as {\em specific} makefiles, as opposed to the general makefile,
\file{makedefs}.

\subsection*{File suffixes recognized by the \file{makefiles}}
\index{file!suffixes, recognized}
\index{makefile!file suffixes recognized}

The generic makefiles recognize the following source file types:

\begin{tabbing}
xxx\=xxx\=xxxxxxxxxxxxxxxxxx\=\+\kill
   \code{app}\+\\
      \file{.cc}              \>\ldots \cplusplus\ implementation file.\\
      \file{.h}               \>\ldots \cplusplus\ header file.\\
      \file{.g}               \>\ldots Glish script.\\
      \file{templates}        \>\ldots Template list (see \exeref{mkinst}).\\
      \file{MyTemplatesOnly}  \>\ldots Template instantiation semaphore file.\\
\-\\
   \code{aps}\+\\
      none\\
\-\\
   \code{chk}\+\\
      any\\
\-\\
   \code{doc}\+\\
      \file{.latex}           \>\ldots \LaTeX\ file.\\
      \file{.tex}             \>\ldots \TeX\ file.\\
      \file{.texi}            \>\ldots Texinfo file.\\
      \file{.ps}              \>\ldots \textsc{PostScript} file.\\
      \file{.text}            \>\ldots \textsc{ascii} text file.\\
      \file{.txt}             \>\ldots \textsc{ascii} text file.\\
      \file{.html}            \>\ldots \textsc{html} file.\\
      \file{.htm}             \>\ldots \textsc{html} file.\\
      \file{.gif}             \>\ldots \textsc{gif} file.\\
      \file{.jpg}             \>\ldots \textsc{jpeg} file.\\
      \file{.dir}             \>\ldots Subdirectory containing files included
                              by the document.\\
\-\\
   \code{ftn}\+\\
      \file{.f}               \>\ldots \textsc{fortran} source file.\\
\-\\
   \code{imp}\+\\
      \file{.cc}              \>\ldots \cplusplus\ implementation file.\\
      \file{.h}               \>\ldots \cplusplus\ header file.\\
      \file{.l}               \>\ldots \unixexe{lex} source file.\\
      \file{.y}               \>\ldots \unixexe{yacc} source file.\\
      \file{.g}               \>\ldots Glish script.\\
      \file{.gif}             \>\ldots \textsc{gif} file.\\
      \file{.html}            \>\ldots \textsc{html} file.\\
      \file{templates}        \>\ldots Template list (see \exeref{mkinst}).\\
      \file{MyTemplatesOnly}  \>\ldots Template instantiation semaphore file.\\
\-\\
   \code{pkg}\+\\
      none\\
\-\\
   \code{scr}\+\\
      any\\
\-\\
   \code{tst}\+\\
      \file{.cc}              \>\ldots \cplusplus\ implementation file.\\
      \file{.h}               \>\ldots \cplusplus\ header file.\\
      \file{.g}               \>\ldots Glish script.\\
      \file{templates}        \>\ldots Template list (see \exeref{mkinst}).\\
      \file{MyTemplatesOnly}  \>\ldots Template instantiation semaphore file.
\end{tabbing}

\noindent
Section \sref{System generation makefile rules} describes the makefile rules
used to process these source files and the type of files produced.

% ----------------------------------------------------------------------------

\newpage
\section{Object libraries}
\label{Object libraries}
\index{library!object}
\index{compilation!object library|see{library, object}}
\index{object library|see{library, object}}
\index{system!generation!object library|see{library, object}}

Generation of \aipspp\ object libraries and usage of external libraries in
\aipspp.

\subsection*{Library control variables}
\index{library!control variables}
\index{makedefs@\file{makedefs}!library control variables}
\index{variables!library control|see{library, control variables}}

An \aipspp\ installation may be configured to maintain a debug version of the
object libraries, an optimized version, or both as determined by the setting
of these variables.  They have names of the form \code{LIB<\textit{package}>},
for example \code{LIBaips}, and their values consist of six fields
corresponding to the debug and optimized \cplusplus, \code{C}, and
\textsc{fortran} libraries in that order,

\begin{verbatim}
   #                    C++            C          FORTRAN
   #                 dbg    opt    dbg    opt    dbg    opt
   #               ------------- ------------- -------------
   LIBaips      := static static defeat defeat static static
\end{verbatim}

\noindent
Four keywords are recognized:
\begin{itemize}
\item
   \textbf{defeat}: The library will not be built (and if an old version
   exists it will be deleted).
\item
   \textbf{static}: The static library is built and is the one linked to.
\item
   \textbf{shatic}: The static and shared libraries are built but the static
   library is the one linked to.
\item
   \textbf{shared}: The static and shared libraries are built and the shared
   library is the one linked to.
\end{itemize}

The library control variables are used by the \aipspp\ \filref{makefiles} to
determine whether to compile the debug and/or optimized versions of an object
module, and which libraries an executable may be linked with.  The library
updating procedure, \exeref{updatelib}, also uses them to determine which
sharable libraries to build.

\subsection*{External libraries}
\index{library!external}
\index{XLIBLIST@\code{XLIBLIST}|see{library, external}}
\index{CPPMODU@\code{CPPMODU}|see{library, external}}

\aipspp\ uses many external libraries such as \code{PGPLOT}, \code{LAPACK},
and \code{X11}.  These are expected to be installed separately from \aipspp.
Other libraries such as \code{Glish} and \code{WCSLIB} while bundled with
\aipspp\ are nevertheless treated by \filref{makedefs} as though they were
external.

\filref{makedefs} contains a set of variables for each external library.  For
example, for \code{Tcl} the variables are

\begin{verbatim}
   TCLROOT  := /usr/local
   TCLDEFS  := -DTCL
   TCLINCD   = $(TCLROOT)/include
   TCLLIBD   = $(TCLROOT)/lib
   TCLLIB   := -ltcl
\end{verbatim}

\noindent
The corresponding variables for \code{Glish} and \code{WCSLIB} are set to
point to the \aipspp\ system directories where they are installed.

The per-directory makefile for a class implementation module, an application
or test program registers its usage of one or more external libraries via the
\code{XLIBLIST} variable.  For example,

\begin{verbatim}
   XLIBLIST := GLISH WCSLIB F77
   include $(word 1, $(AIPSPATH))/code/install/makefile.app
\end{verbatim}

\noindent
This examples tells \filref{makedefs} to construct compile and link options
using \code{Glish}, \code{WCSLIB}, and \code{FORTRAN}.  Note that the order
is important, \code{WCSLIB} comes {\em before} \code{F77} in the list since
it uses \code{F77} and not vice versa.  It is valid for a library to be
repeated although that should not be necessary.

Note also that the mnemonics used for the external libraries are
case-sensitive.  Most are all-uppercase, \code{Motif} is the one exception.

The \code{*ROOT} variables in the external library definitions are not used
directly by \filref{makedefs} but may allow the site-specific \file{makedefs}
to provide a simple redefinition as explained elsewhere (\sref{makedefs}).
The other four variables are only used within \file{makedefs} as follows:
\begin{itemize}
\item
   The \code{*DEFS} variables are collected into a variable called
   \code{XTRNDEFS} which is appended to the C-preprocessor options
   (\code{CPPDBG} and \code{CPPOPT}) in \filref{makedefs}.  \code{XTRNDEFS}
   is not used outside \file{makedefs}.
\item
   The \code{*INCD} variables are given a \code{-I} prefix and collected
   together after \code{\$(AIPSCODE)/include} in a variable called
   \code{AIPSINCL} which is used as a compiler option in the generic
   makefiles.
\item
   The \code{*LIBD} variables are collected into a variable called
   \code{XLIBPATH} which is only used within \filref{makedefs} to construct
   \code{XTRNLIBS} (see next item).
\item
   The \code{*LIB} variables are appended to \code{\$(XLIBPATH)} and there
   followed by \code{\$(ARCHLIBS)} (platform-specific unix system libraries)
   to form \code{XTRNLIBS}.  \code{XTRNLIBS} is used in the link list by the
   \code{app} and \code{tst} makefiles.
\end{itemize}

While external libraries may have preprocessor definitions associated with
them, it is also possible to add preprocessor directives to a per-directory
makefile via the \code{CPPMODU} variable.  \code{CPPMODU} is processed within
\file{makedefs} the same way as preprocessor definitions defined for each
external library, that is, they are appended to the C-preprocessor options
\code{CPPDBG} and \code{CPPOPT} and not otherwise used outside
\file{makedefs}.  An example of its usage

\begin{verbatim}
   XLIBLIST := GLISH WCSLIB F77
   CPPMODU  := -DAIPS_UNAME
   include $(word 1, $(AIPSPATH))/code/install/makefile.app
\end{verbatim}

\noindent
Note that preprocessor macro definitions made via \code{CPPMODU} must not be
platform-specific since this would impede portability.  Any such definitions
should be made in \file{makedefs}.

\subsection*{See also}

\filref{makedefs}, \aipspp\ makefile definitions.\\
\filref{testdefs}, test \file{makedefs} definitions.\\
\exeref{updatelib}, update an \aipspp\ object library.

% ----------------------------------------------------------------------------
 
\newpage
\section{Template instantiation}
\label{Template instantiation}
\index{templates}
\index{templates!specialization}
\index{system!generation!templates|see{templates}}
\index{types, parameterized|see{templates}}
\index{parameterized types|see{templates}}
\index{specialization!template|see{templates, specialization}}

\cplusplus\ template instantiation in \aipspp
 
\subsection*{C++ template classes}

\aipspp\ makes heavy use of \cplusplus\ template classes, also referred to as
``parameterized types''.  These are typically used to implement ``container''
classes, for example \code{Set}, \code{List}, and \code{Array} classes, which
serve to aggregate objects of another type.  In \cplusplus, \code{Set} would
be defined in ``template'' form as \code{Set<T>}, where the template type (or
parameter), \code{T}, represents some as yet unspecified data type.  This
saves having to code \code{Set} classes separately for \code{int},
\code{float}, or general \code{Object} data types. 

The \cplusplus\ compiler ``instantiates'' the \code{Set<T>} class template for
objects of type \code{float} (say) when it compiles a piece of code which
declares that it wants to use \code{Set<float>}.

Global functions can also be templated.  The argument list and return value
may be defined in terms of template type \code{T}, where \code{T} often (but
not necessarily) refers to a template class.

It often happens that particular template classes and functions can be
implemented more efficiently for a particular template type by manual coding
rather than by instantiation of the class or function template.  \cplusplus
allows ``template specializations'' to be written for particular instances of
template classes, but some compilers may require these to be registered in
a particular way.
 
\subsection*{Instantiation mechanisms}
\index{templates!instantiation}
\index{compilation!templates|see{templates, instantiation}}
\index{instantiation|see{templates, instantiation}}

While no two \cplusplus\ compilers use exactly the same template instantiation
mechanism there are two basic types:

\begin{description}
\item[automatic:]
   Some compilers deduce what templates need to be instantiated, the only
   outside intervention needed being provided by compile-line options.  These
   compilers maintain a ``template repository'' which holds intermediate files
   generated in the instantiation process.  Older \textsc{cfront}-based
   compilers did all template instantiation at link time, but more modern
   ``native'' compilers do as much as possible when the object library is
   generated.  They include template object files together with those
   generated from the class implementation files in order to speed up the
   linking phase.

   Since the compiler needs to locate all \cplusplus\ class implementation and
   header files required for the instantiation this is a non-trivial operation
   and this method is notoriously bug-ridden.

\item[manual:]
   The \gnu\ \cplusplus\ compiler, \unixexe{g++}, cannot deduce what templates
   need to be instantiated.  However, it does accept a small \cplusplus\ source
   file which includes the necessary class implementation and header files and
   declares the template of the desired type.
\end{description}

The proliferation of template instantiation mechanisms has presented a
significant challenge for the \aipspp\ system, particularly in avoiding the
introduction of compiler-specific procedures.

\subsubsection*{Template repositories}
\index{templates!repositories}
\index{repository!template|see{templates, repositories}}

Compilers which maintain template repositories have mostly been accomodated
via the use of \code{PTRDBGD}, \code{PTROPTD} variables in \file{makedefs},
and also in distinguishing between the archiver used for \cplusplus\ object
libraries (\code{CXXAR}) and other libraries (\code{AR}).

\subsubsection*{Template specialization and the Sun native compiler}
\index{templates!specializations@\file{specializations} file}

The Sun native compiler requires template specializations to be registered in
the template instantiation options file, \file{Template.opt}, which resides in
the template repository.  Within \aipspp\ these specializations are registered
in \file{specializations} files which reside in the same directory as the
\cplusplus\ code.  A \code{specialize} rule is supplied with the initial
version of \file{makedefs} supplied for \code{sun4sol\_ntv} installations, and
\code{specialize} is added as a dependency of \code{allsys}.  The
\code{specialize} rule checks for the existence of a \file{specializations}
file and if found merges its contents into \file{Template.opt}.  In this way
the compiler specific behaviour is isolated to the local makedefs file and a
set of \file{specializations} files which are ignored by other compilers.

\subsubsection*{Do-it-yourself (diy) templates}
\index{templates!do-it-yourself}
\index{diy|see{templates, do-it-yourself}}
\index{templates!list|see{templates, do-it-yourself}}

The \gnu\ \cplusplus\ compiler, \unixexe{g++}, must have template
instantiation files supplied to it.  This ``do-it-yourself'' mode is enabled
by setting the \code{TEMPLATES} variable in \filref{makedefs} to \code{diy}.

Templates to be instantiated are discovered during code development via the
list of unresolved symbols which results when attempting to compile a program.
The linker reports the mangled names of the templates and these may be
demangled with the \gnu\ version of \unixexe{c++filt} (the name mangling
scheme used by \unixexe{g++} differs from other compilers).

It is up to the programmer to supply the name of the class implementation file
and any required header files for each template to be instantiated.  This
information is recorded as an entry in the \file{templates} file as
described in the entry for \exeref{mkinst}.  The \file{templates} files are
maintained within the \aipspp\ system and programmers may also create private
copies for code development.

\file{templates} files may reside in any \file{imp}, \file{app} or \file{tst}
directory.  However, these are handled in different ways when compiling the
system (see chapter~\ref{Code development} for programmer usage):
\begin{itemize}
\item
   Template instantiations generated in an \file{implement} directory are
   added to the related system object library so that they may be shared by
   all applications and test programs which use that library.  By convention
   such \file{templates} files are restricted to the \file{\_ReposFiller}
   ``module'' for each \aipspp\ package.
\item
   \file{app} directories contain only a single application so the template
   instantiation files generated therein are not pre-compiled but instead are
   added to the compilation command for the application.
\item
   Since \file{tst} directories may contain several test programs the template
   instantiation files are pre-compiled and inserted into a temporary object
   library which is deleted after all test programs have been compiled.
\end{itemize}
 
\subsection*{See also}
 
\exeref{mkinst}, Generate template instantiation files from a list.\\
\exeref{reident}, Remake the idents in a \file{templates} list.\\
\exeref{duplicates}, Checks for duplicate entries in \file{templates} lists
   across the system.
% ----------------------------------------------------------------------------
 
\newpage
\section{System generation makefile rules}
\label{System generation makefile rules}
\index{system!generation!makefile rules}
\index{makefile!rules!system generation}
\index{makefile!application}
\index{makefile!applications}
\index{makefile!checkout}
\index{makefile!class implementation}
\index{makefile!documentation}
\index{makefile!fortran@\textsc{fortran}}
\index{makefile!install}
\index{makefile!package}
\index{makefile!scripts}
\index{makefile!test}
\index{makefile!top-level}
\index{perl@\unixexe{perl} scripts!installation}
 
\gnu\ makefile rules used to rebuild \aipspp
 
\subsection*{Synopsis}
 
\begin{synopsis}
   \file{makefile}\\
   \file{makefile.\{app,aps,chk,doc,ftn,imp,pkg,scr,tst\}}
\end{synopsis}
 
\subsection*{AIPS++ targets}

The \aipspp\ makefile targets are listed below by category.  These lists are
not exhaustive, but do aim to cover everything of practical use.  In
particular, they omit targets which are intended for the internal use of the
makefiles.

A target is labelled as ``recursive'' if it causes \exeref{gmake} to be
invoked in all subdirectories.  It is ``general'' if it applies to all
makefiles; such targets are defined in \file{makedefs}.  A target is
``specific'' if defined in a specific makefile.

Some targets such as \file{allsys} have a general meaning, the specific
behaviour of which differs for specific makefiles.  These are referred to as
``general/specific'' and where appropriate the details of a target's behaviour
are described for each of the generic makefiles, for the top-level makefile
(\file{top}), and the installation makefile (\file{ins}).

Targets which apply only if the \rcs\ source code repositories are present are
marked as ``\rcs''.

Rules for system-oriented targets always take source code from the
\file{\$AIPSCODE} subdirectories.  If \file{\$AIPSRCS} exists, then these
plain-text sources are updated from the \rcs\ repository first if necessary.

\begin{itemize}
\item
   \code{allsys} : (default system target, general/specific, recursive)
   \\ This is declared generally in \file{makedefs} as the default target if
   \aipsexe{gmake} has been invoked from a subdirectory of \file{\$AIPSCODE}.
   It has a dependency which causes source files to be checked out where
   required if the \rcs\ repositories exist.  Further dependencies and
   commands are defined in the specific makefiles to compile and install all
   \aipspp\ sources.
   \begin{itemize}
   \item
      \file{app}: Rebuild the application; template instantiation files will
      be created from a \file{templates} file if necessary.  Also install any
      Glish scripts in \code{\$(LIBEXECD)}.
   \item
      \file{aps}: Rebuild all applications residing in an \file{apps}
      directory.
   \item
      \file{chk}: Just update the plain-text sources if \rcs\ repositories
      are present.
   \item
      \file{doc}: Compile all documentation.
   \item
      \file{ftn}: Rebuild a \textsc{fortran} library from its sources.
   \item
      \file{imp}: Rebuild a \cplusplus\ library from its sources updating the
      system dependency list in the process (see \exeref{depend}).  Also
      install any Glish scripts in \code{\$(LIBEXECD)}.
   \item
      \file{ins}: Compile and install all \aipspp\ system utilities in the
      \file{bin} area.  See also \code{thisys}.
   \item
      \file{pkg}: Rebuild a whole package.  Auxiliary directories such as
      \file{glish} and \file{wcslib} in the \code{aips} package are done
      first, then the \file{scripts} subdirectory, then the \aipspp\
      libraries, then all applications.
   \item
      \file{scr}: Install all \aipspp\ executable scripts in the \file{bin}
      area and install any Glish scripts in \code{\$(LIBEXECD)}.  When
      \unixexe{perl} scripts are installed the pathname in the strings
      \code{\#!/usr/local/bin/perl4} and \code{\#!/usr/local/bin/perl5} on the
      first line of the script are replaced with the pathname encoded in the
      \code{PERL4} and \code{PERL5} \file{makedefs} variables.  All sources
      present in the directory will be installed except for those listed in
      the \code{EXCLUDE} variable.  By default, this contains the name of the
      makefile itself to prevent it from being installed.
   \item
      \file{top}: Rebuild the entire \aipspp\ system as follows:

      If necessary, the \file{include} subdirectory is first created and
      populated with symbolic links to the \file{implement} directories of all
      installed packages (see \exeref{mktree}).

      Before commencing the rebuild any required system directories are
      created.

      The \file{install}, \file{aips}, \file{dish}, \file{synthesis}, and
      \file{vlbi} subdirectories are then built in that order.

      If the \file{admin} subdirectory exists it is then rebuilt.

      Auxiliary packages are then rebuilt under the control of the
      \code{AUXILIARY} variable.  This may be set in \file{makedefs} to the
      required combination of \file{contrib} and \file{trial}.  They will be
      rebuilt in the order listed in \code{AUXILIARY}.

      Consortium packages are then rebuilt under the control of the
      \code{CONSORTIA} variable.  This may be set in \file{makedefs} to the
      required combination of \file{atnf}, \file{bima}, \file{hia},
      \file{nfra}, \file{nral}, \file{nrao}, and \file{tifr}.  They will be
      rebuilt in the order listed in \code{CONSORTIA}.

      The \aipspp\ documentation is then compiled.  This can be defeated by
      unsetting the \code{DOCSYS} variable in \file{makedefs}.

      Document extraction from \cplusplus\ sources is then performed under
      the control of the \code{DOCEXTR} variable in \file{makedefs}.
   \item
      \file{tst}: Create template instantiation files from a \file{templates}
      file if necessary.  If the \code{BINTEST} variable is set to
      ``\code{bintest}'' (or just ``\code{bin}'') in \file{makedefs} then
      rebuild all test programs.  Debug compilations are done by default, but
      if the \code{TESTOPT} variable is set to ``\code{opt}'' in
      \file{makedefs} then optimized compilations will be done.
   \end{itemize}

\item
   \code{thisys} : (specific)
   \\ Non-recursive version of \code{allsys}.
   \begin{itemize}
   \item
      \file{ins}: Compile and install all \aipspp\ system utilities in the
      \file{bin} area.  Same as \code{allsys} except that it does not recurse
      into any subdirectories.
   \end{itemize}

\item
   \code{aipsroot} : (specific)
   \\ Special purpose rule to remake the \file{\$(AIPSROOT)} directory.
   \begin{itemize}
   \item
      \file{ins}: Install all root level files.
   \end{itemize}

\item
   \file{\$(SUBDIRS)} : (general, recursive)
   \\ \file{makedefs} sets the \file{SUBDIRS} variable to the names of all
   subdirectories which have a makefile, thus making them recognized targets.
   If the \rcs\ source code repositories exist then \code{SUBDIRS} lists
   the subdirectories of the corresponding \rcs\ directory.  This list is
   then made the target of a rule for creating the subdirectory and, if the
   \rcs\ directories are present, its \file{RCS} symlink (see
   \exeref{mktree}).  A \aipsexe{gmake} is then initiated within the
   subdirectory.  Note that this target has a programmer-oriented counterpart
   which behaves similarly.

\item
   \file{\$(CODESUBS)} : (general, recursive)
   \\ Same as \file{\$(SUBDIRS)} except that a subdirectory of
   \file{\$AIPSCODE} may be specified via an absolute pathname.

\item
   \code{null} : (general)
   \\ Does nothing directly, but indirectly it may cause a makefile to update
   its included files, and in particular, this may trigger a dependency
   analysis to be done (see \exeref{depend}).

\item
   \code{chkout} : (general, recursive, \rcs)
   \\ Update the \file{\$AIPSCODE} directories by checking out files from the
   corresponding \file{\$(AIPSRCS)} directories (if the \rcs\ repositories
   are present).

   In installations which use do-it-yourself template instantiation
   (\sref{Template instantiation}) the \code{chkout} rule also generates
   template instantiation files in the \file{tmplinst} subdirectory by
   invoking \exeref{mkinst}.  (These \file{tmplinst} subdirectories are
   maintained by the makefile in their parent directory and should not contain
   their own makefile.)

   The \code{chkout} target for the \code{doc} makefile explicitly handles all
   subdirectories with names of the form \file{.dir} so that these
   subdirectories need not and should not contain a makefile.

\item
   \code{symlinks} : (specific)
   \\ Create the \code{\$(CODEINCD)} directory and symlinks.
   \begin{itemize}
   \item
      \file{top}: Create the \code{\$(CODEINCD)} directory and symlinks.
   \end{itemize}

\item
   \code{sysdirs} : (general)
   \\ Create the \aipspp\ system directories, the subdirectories of
   \file{\$AIPSARCH}.  This is invoked by the top-level (\file{\$AIPSCODE})
   makefile at the beginning of a recursive rebuild to ensure that all
   required system directories exist.

\item
   \code{cleancode} : (general/specific, recursive)
   \\ Recursively delete files from the \aipspp\ code areas which shouldn't
   be there - since noone should work from within these areas such files
   should not normally accumulate in them.  Generally, the following are
   deleted: \file{,*,}, \file{*~}, \file{*\%}, \file{a.out}, and \file{core}.
   The general target has a dependency which may be defined in the specific
   makefiles as the target of a rule to delete additional files:
   \begin{itemize}
   \item
      \file{app}: \file{*.i}, \file{*.o}, \file{*.cdb}, \file{*.cyi}, and any
      \file{tmplinst} subdirectory.
   \item
      \file{aps}: (none)
   \item
      \file{chk}: (none)
   \item
      \file{doc}: \file{*.aux}, \file{*.bbl}, \file{*.blg}, \file{*.cp},
      \file{*.cps}, \file{*.dvi}, \file{*.fi}, \file{*.fis}, \file{*.fn},
      \file{*.fns}, \file{*.ky}, \file{*.kys}, \file{*.lof}, \file{*.log},
      \file{*.pg}, \file{*.pgs}, \file{*.toc}, \file{*.tp}, \file{*.tps},
      \file{*.vr}, \file{*.vrs}, \file{*.info}, \file{*.info-*}
   \item
      \file{ftn}: \file{*.o}
   \item
      \file{imp}: \file{*.lcc}, \file{*.ycc}, \file{*.i}, \file{*.o},
      \file{*.cdb}, \file{*.cyi}, and any \file{tmplinst} subdirectory.
   \item
      \file{ins}: \file{*.i}, \file{*.o}
   \item
      \file{pkg}: (none)
   \item
      \file{scr}: (none)
   \item
      \file{top}: (none)
   \item
      \file{tst}: \file{*.i}, \file{*.o}, \file{*.cdb}, \file{*.cyi},
      \file{*\_tmp*} (temporaries created by \exeref{assay}), and any
      \file{tmplinst} subdirectory.
   \end{itemize}

\item
   \code{cleansys} : (general/specific, recursive)
   \\ Delete selected files from the \aipspp\ system directories, usually
   as a prelude to rebuilding the system in its entirety.  The general rule
   does nothing except recurse, but it has a dependency which may be defined
   in the specific makefiles as the target of a rule to delete additional
   files:
   \begin{itemize}
   \item
      \file{app}: (none)
   \item
      \file{aps}: (none)
   \item
      \file{chk}: (none)
   \item
      \file{doc}: (none)
   \item
      \file{ftn}: The debug and optimized static \textsc{fortran} object
      libraries for the package, and also certain \file{BUILD.*} lock files
      which are normally deleted after a library is built but may be left
      behind if the build is terminated with prejudice.
   \item
      \file{imp}: The debug and optimized static \cplusplus\ object libraries
      for the package, dependency lists and the timestamp files maintained
      for the module by the dependency analysis (their deletion causes the
      dependency analysis to be done again from scratch), the \file{version.o}
      object module, the debug and optimized \cplusplus\ template repositories
      (if any, in their entirety).
   \item
      \file{ins}: (none)
   \item
      \file{pkg}: Recursively delete the \file{tmp} directories for the
      package.  These exist as subdirectories of \file{\$(ARCHTMPD)}.
   \item
      \file{scr}: (none)
   \item
      \file{top}: (none)
   \item
      \file{tst}: Test executables and reports in \file{\$(BINTESTD)}
      generated by the \code{runtests} rule (see section \sref{Diagnostic
      makefile rules}).  Also, the intermediate object library produced when
      compiling all test executables in the directory.
   \end{itemize}

\item
   \code{cleandocs} : (specific)
   \\ Clean up \file{\$(AIPSDOCS)}.
   \begin{itemize}
   \item
      \file{imp}: Delete defunct and unrecognized files from the corresponding
      subdirectory of \file{\$(AIPSDOCS)}.
   \end{itemize}

\item
   \code{dependsys} : (specific)
   \\ Update the system dependency lists in \file{\$(ARCHAUXD)}.  Since these
   lists are included by the makefiles they are normally updated automatically
   by \aipsexe{gmake}.
   \begin{itemize}
   \item
      \file{imp}: Build the system dependency lists for the \cplusplus\
      libraries.
   \end{itemize}

\item
   \code{instsys} : (specific)
   \\ Generate and possibly compile template instantiation files specified by
   a \file{templates} file in \file{\$(CODEDIR)}.
   \begin{itemize}
   \item
      \file{app}: Generate template instantiation files using \exeref{mkinst}
      and deposit them in subdirectory \file{\$(CODEDIR)/tmplinst}.
   \item
      \file{imp}: Generate template instantiation files using \aipsexe{mkinst}
      and deposit them in subdirectory \file{\$(CODEDIR)/tmplinst}, then
      invoke \file{gmake allsys} in that directory to compile them and insert
      them into the object library.
   \item
      \file{tst}: Generate template instantiation files using \aipsexe{mkinst}
      and deposit them in subdirectory \file{\$(CODEDIR)/tmplinst}.
   \end{itemize}

\item
   \code{version} : (specific)
   \\ Compile \file{version.o}.
   \begin{itemize}
   \item
      \file{imp}: Generate \file{version.o} using \exeref{doover}, compile it
      and insert it into the object libraries.
   \end{itemize}

\item
   \code{lib(\%.o)} : (specific, pattern rule)
   \\ Compile an object module from the corresponding source file in
   \file{\$(CODEDIR)} and insert it into the system library, then apply
   \code{\$(RANLIB)} to the library.

   An \aipspp\ installation may be configured to maintain a debug version
   of the object libraries, an optimized version, or both as determined by the
   setting of the {\em library control} variables in \filref{makedefs}.

   If dual debug/optimized libraries are being maintained then both forms are
   compiled and the libraries updated in tandem to ensure that they remain
   synchronized (see \exeref{updatelib}).

   Intermediate object files are stored in a subdirectory of
   \file{\$(ARCHTMPD)}.

   \begin{itemize}
   \item
      \file{ftn}: Compile the \file{.f} file for a \textsc{fortran} subroutine
      and insert it into the \textsc{fortran} library.
   \item
      \file{imp}: Compile the \file{.cc} file for a \cplusplus\ class
      implementation and insert it into the \cplusplus\ library.
   \end{itemize}

\item
   \code{lib} : (specific)
   \\ Invoke the \code{lib(\%.o)} pattern rule for all sources in
   \file{\$(CODEDIR)} to build the system object libraries (debug and/or
   optimized).
   \begin{itemize}
   \item
      \file{ftn}: Build the \textsc{fortran} library(s).
   \item
      \file{imp}: Update the package library for all \cplusplus\ sources in
      this module.  Also, install any Glish scripts in \code{\$(LIBEXECD)}.
   \item
      \file{pkg}: Invoke \code{allsys} in the \file{implement} and
      \file{fortran} subdirectories.
   \item
      \file{tst}: Invoke \code{allsys} in the \file{implement} directory for
      this package.
   \end{itemize}

\item
   \code{updatelib} : (specific)
   \\ Insert all object modules into the system libraries and \unixexe{ranlib}
   them.
   \begin{itemize}
   \item
      \file{ftn}: Update the \textsc{fortran} libraries.
   \item
      \file{imp}: Update the \cplusplus\ libraries.
   \end{itemize}

\item
   \code{ranlib} : (specific)
   \\ Apply \code{\$(RANLIB)} to the system static object libraries.
   \begin{itemize}
   \item
      \file{ftn}: \unixexe{ranlib} the \textsc{fortran} libraries.
   \item
      \file{imp}: \unixexe{ranlib} the \cplusplus\ libraries.
   \end{itemize}

\item
   \code{bin/\$(AIPSEXES)} : (specific)
   \\ Compile an executable in optimized mode from the corresponding source
   file in \file{\$(CODEDIR)} and install it in \file{\$BINOPTD}.
   \begin{itemize}
   \item
      \file{aps}: The apps directory makefile generates a list of all
      applications which may be compiled from applications subdirectories.
      It then forms this into a list of targets of a rule for invoking the
      \code{bin} target in each applications subdirectory.
   \item
      \file{ins}: Compile and install a utility program, e.g. \exeref{getrc}.
   \item
      \file{tst}: Synonym for \code{bintest/\%}.
   \end{itemize}

\item
   \code{bindbg/\$(AIPSEXES)} : (specific)
   \\ Compile an executable in debug mode from the corresponding source
   file in \file{\$(CODEDIR)} and install it in \file{\$(BINDBGD)}.
   \begin{itemize}
   \item
      \file{aps}: The apps directory makefile generates a list of all
      applications which may be compiled from applications subdirectories.
      It then forms this into a list of targets of a rule for invoking the
      \code{bindbg} target in each applications subdirectory.
   \end{itemize}

\item
   \code{bintest/\%} : (specific, pattern rule)
   \\ Compile a test program.
   \begin{itemize}
   \item
      \file{tst}: \\ Compile a test program from the corresponding source file
      in \file{\$(CODEDIR)} and install it in \file{\$BINTESTD}.  If necessary,
      template instantiation files will be created from a \file{templates}
      file and compiled into an object library (which is retained).  The
      compilation will be done in optimized mode if the \code{TESTOPT}
      \file{makedefs} variable is set to ``\code{opt}'', anything else will
      produce a debug compilation.  The include path will be augmented with
      the name of the test subdirectory thereby allowing test programs to
      maintain a set of include files specific to them.
   \end{itemize}

\item
   \code{bin} : (specific)
   \\ Compile all executables with sources in \file{\$(CODEDIR)} in optimized
   mode and install them in the \file{\$(BINOPTD)}.
   \begin{itemize}
   \item
      \file{app}: Compile and install the application.  The include path will
      be augmented with the name of the applications subdirectory thereby
      allowing an application to maintain a set of include files specific to
      it.  Also, install any Glish scripts in \code{\$(LIBEXECD)}.
   \item
      \file{aps}: Compile and install all applications by invoking the
      \code{bin} target in every applications subdirectory.
   \item
      \file{ins}: Compile and install all utility programs.
   \item
      \file{pkg}: Invoke the \code{bin} target in the \file{apps}
      subdirectory.
   \item
      \file{scr}: Synonym for \code{allsys}.
   \item
      \file{tst}: Synonym for \code{bintest}.
   \end{itemize}

\item
   \code{bindbg} : (specific)
   \\ Compile all executables with sources in \file{\$(CODEDIR)} in debug mode
   and install them in the \file{\$(BINDBGD)}.
   \begin{itemize}
   \item
      \file{app}: Compile and install the application in debug mode.  The
      include path will be augmented with the name of the applications
      subdirectory thereby allowing an application to maintain a set of
      include files specific to it.
   \item
      \file{aps}: Compile and install all applications in debug mode by
      invoking the \code{bindbg} target in every applications subdirectory.
   \end{itemize}

\item
   \code{bintest} : (specific)
   \\ Compile and install test programs.
   \begin{itemize}
   \item
      \file{tst}: Invoke the \code{bintest/\%} pattern rule for each test
      program in \file{\$(CODEDIR)}.  Delete the intermediate object library
      which may be produced for template instantiations created from a
      \file{templates} file.
   \end{itemize}

\item
   \code{docsys} : (general/specific)
   \\ Compile and install documentation.  Generally this invokes the
   \code{docscan} and \code{docextr} targets in the current directory as
   controlled by the \code{DOCEXTR} variable in \file{makedefs}.  Specific
   makefiles may then do additional document compilations:
   \begin{itemize}
   \item
      \file{app}: (none)
   \item
      \file{aps}: (none)
   \item
      \file{chk}: (none)
   \item
      \file{doc}: Compile all \file{*.texi}, \file{*.latex} and \file{*.tex}
      files in \file{\$(CODEDIR)} into \file{*.ps} \textsc{PostScript} files
      and install them in the corresponding \file{\$AIPSDOCS} subdirectory.

      Files included by the \file{*.texi}, \file{*.latex} or \file{*.tex}
      files will be obtained from the corresponding \file{.dir} subdirectory.
      Any \LaTeX-related \file{.bib} bibliography files contained in
      this directory will be processed by \textsc{Bib}\TeX.

      Plain-text \file{.text} files are simply copied to the \file{\$AIPSDOCS}
      subdirectory, as are \file{.txt}, \file{.html}, \file{.htm},
      \file{.gif}, and \file{.jpg} files.

      Any \code{<!$\code{}Date$>} meta-markups in \file{.html} and \file{.htm}
      files are parsed to record the time of installation.
   \item
      \file{ftn}: (none)
   \item
      \file{imp}: (none)
   \item
      \file{ins}: (none)
   \item
      \file{pkg}: (none)
   \item
      \file{scr}: (none)
   \item
      \file{top}: Recurse into the \file{doc} subdirectory.
   \item
      \file{tst}: (none)
   \end{itemize}

\item
   \code{docscan} : (general/specific)
   \\ Scan \cplusplus\ sources building the database used by the document
   extractor.  The general rule does nothing.  Specific makefiles behave as
   follows:
   \begin{itemize}
   \item
      \file{app}: (none)
   \item
      \file{aps}: (none)
   \item
      \file{chk}: (none)
   \item
      \file{doc}: (none)
   \item
      \file{ftn}: (none)
   \item
      \file{imp}: Run \exe{cxx2html} in \exe{-scan} mode for each header file
      then recurse into all but \file{test} subdirectories.
   \item
      \file{ins}: (none)
   \item
      \file{pkg}: Recurse into the \file{implement} subdirectory.
   \item
      \file{scr}: (none)
   \item
      \file{top}: Recurse into all package subdirectories.
   \item
      \file{tst}: (none)
   \end{itemize}

\item
   \code{docextr} : (general/specific)
   \\ Extract documentation from \cplusplus\ sources.  The general rule does
   nothing.  Specific makefiles behave as follows:
   \begin{itemize}
   \item
      \file{app}: (none)
   \item
      \file{aps}: (none)
   \item
      \file{chk}: (none)
   \item
      \file{doc}: (none)
   \item
      \file{ftn}: (none)
   \item
      \file{imp}: Run \exe{cxx2html} for each header file to extract
      documentation from the \cplusplus\ sources and install it in the
      corresponding subdirectory of \file{\$AIPSDOCS}.  Copy any \file{.gif}
      files to the same place.  Then recurse into all but \file{test}
      subdirectories.
   \item
      \file{ins}: (none)
   \item
      \file{pkg}: Recurse into the \file{implement} subdirectory.
   \item
      \file{scr}: (none)
   \item
      \file{top}: Recurse into all package subdirectories.
   \item
      \file{tst}: (none)
   \end{itemize}
\end{itemize}


\subsection*{Notes}

\begin{itemize}
\item
   The implement makefile includes the system dependency lists and so may
   start slowly as it checks to see whether the list is up-to-date (regardless
   of whether the particular target uses it or not).  Inclusion of the
   dependency list can be circumvented by setting the \code{NODEP} variable
   (to anything).  This causes the makefile to start considerably faster.

   \code{NODEP} is set automatically if \exeref{gmake} is invoked from a
   directory which does not reside under \file{\$AIPSROOT}, that is, a
   programmer invokation.  However, system-oriented targets may also be
   invoked from a programmer directory, and this would cause the dependency
   analysis to be circumvented, and the dependency list to be ignored.  This
   may be legitimate if the target invoked does not actually use the
   dependency list, for example \code{chkout}, \code{cleancode} or
   \code{cleansys}.  In fact, the code distribution system sets \code{NODEP}
   explicitly when it invokes the top-level makefile for these recursive
   targets for the system (see \exeref{inhale}).  However, \code{NODEP} must
   not be set for an invokation of the implement makefile for a target which
   does use the dependency list.  A proper resolution of this problem would
   require the facility for a makefile to examine its target list, but this is
   not currently possible.

\item
   If the \aipspp\ \rcs\ source code repositories are present in an
   installation all \aipspp\ makefiles access them via a symbolic link
   \file{\$AIPSROOT/rcs} which is usually set to point to \file{slave}.
   Therefore, the slave \rcs\ repositories are normally the ones consulted.
   However, it is possible to reset the \file{rcs} ``switch'' to \file{master}
   to cause \exeref{gmake} to checkout and/or rebuild \aipspp\ from the
   \file{master} repositories.  \exeref{exhale} uses this mechanism when
   constructing a new base release.  However, it requires good bandwidth to
   the master and is only feasible in Socorro.
\end{itemize}

\subsection*{Examples}

The following command suffices to clean up the \aipspp\ system and rebuild it
in its entirety

\begin{verbatim}
   cd $AIPSCODE
   gmake cleansys allsys
\end{verbatim}

\noindent
To just compile and install the documentation:

\begin{verbatim}
   cd $AIPSCODE
   gmake docsys
\end{verbatim}

\noindent
This would recursively compile all \textsc{PostScript} documents from the
\file{*.latex}, \file{*.tex} and \file{*.texi} files in the
\file{\$AIPSCODE/doc} directory tree and install them in the corresponding
\file{\$AIPSDOCS} subdirectory.  \textsc{ascii}, \file{*.html}, \file{*.ps}
etc.  documents will also be copied across.  The document extractor would then
be invoked on the \cplusplus\ sources (if enabled).  Note, however, that no
documents are printed via \code{docsys}.

\subsection*{See also}

The \gnu\ \code{Make} manual.\\
The \gnu\ manual page for \unixexe{gmake}.\\
The unix manual page for \unixexe{ranlib}(1).\\
\aipspp\ variable names (\sref{variables}).\\
\exeref{gmake}, \gnu\ make.\\
\filref{makedefs}, \aipspp\ makefile definitions.\\
\exeref{updatelib}, update an \aipspp\ object library.

% ----------------------------------------------------------------------------
 
\newpage
\section{\exe{mkinst}}
\label{mkinst}
\index{mkinst@\exe{mkinst}}
\index{library!templates|see{templates, instantiation}}
\index{templates!instantiation files|see{\exe{mkinst}}}
\index{templates!templates@\file{templates} file|see{\exe{mkinst}}}
\index{tmplinst@\file{tmplinst}|see{\exe{mkinst}}}

Generate template instantiation files from a list.

\subsection*{Synopsis}
 
\begin{synopsis}
   \code{\exe{mkinst} [\exe{-q}] package}
\end{synopsis}
 
\subsection*{Description}
 
\exe{mkinst} generates a template instantiation file for each entry in the
specified file, (\file{templates} by default).  It leaves the resulting
\file{.cc} files in the current directory.  The format of the entries in the
\file{templates} file is

\begin{verbatim}
   <ident> <.cc file> <.h file> [<extra .h files>] <template declaration> ...
\end{verbatim}

\noindent
or

\begin{verbatim}
   <ident> <.h file> [<extra .h files>] <template declaration> ...
\end{verbatim}

\noindent
The latter form is for instantiation of purely inline functions.  The
\file{.cc} and \file{.h} files are expressed as relative pathnames with
respect to \file{\$AIPSROOT/code/include}.  For example:

\begin{verbatim}
   1050 aips/Set/Set.cc template class Set<Int>
   1040 aips/Set/Set.cc aips/Cube/Cube.h template class Set<Cube>
   1060 aips/Set/Set.cc template Set<Int> operator+(Set<Int> const &, Set<Int> const &)
   1060 aips/Set/Set.cc template void union(Set<Int> const &, Set<Int> const &)
\end{verbatim}

\noindent
The \code{ident} contains a 4-digit number which is unique amongst all
templates based on a particular class implementation \file{.cc} or \file{.h}
file.  The name of the template instantiation \file{.cc} file is composed of
the name of the class \file{.cc} or \file{.h} file and the \code{ident}, for
example, the instantiation file for the first entry above would be
\file{Set\_1050.cc}.

\noindent
Comments in the \file{templates} file are signalled by a ``\code{\#}'' in the
first field.  Blank lines are also allowed.

\noindent
Each entry in the \file{templates} can be split over several lines. The first
line must have the \code{ident} and one or more of the necessary include
files (.cc or .h). Subsequent lines can be in any order, and have one of the
following formats:
\begin{verbatim}
    = file.h				 additional include files
    template class Name<...>		 class specialisation
    template <...> ...			 templated class forward declaration
    template <> ...			 non-templated forward declaration
    template ret-val function(....)	 function specialisation
    typedef definition name              typedef, for use in next
    AIPS_[A-Z0-9]*_AUX_TEMPLATES(x, ...) to aid with sub-templates
\end{verbatim}

\noindent
The {\em AIPS\_()} macros are provided to aid in the generation of
auxilliary templates necessary for some compilers for standard
library templates (like the map and vector e.g.). Since macros
cannot handle arguments with embedded commas, the \code{typedef}
option is provided to give macro arguments with commas. See the
repositories for examples.

\noindent
Template declarations can be bracketed by \#if
\#else \#endif. For example:

\begin{verbatim}
   1040 aips/Set/Set.cc aips/Cube/Cube.h
	template class Set<Cube>
   1050 aips/Set/Set.cc 
	template class Set<Int>
	template <> class ostream
	template <class T> class Vector
	#if !defined(STD_LIB)
    	  template Set<Int> operator+(Set<Int> const &, Set<Int> const &)
      	  template void union(Set<Int> const &, Set<Int> const &)
	#endif
\end{verbatim}

\noindent
Any template instantiation \file{.cc} file in the current directory which does
not correspond to an entry in the templates file will be deleted.  These files
are recognized by having names of the form \file{*\_[0-9][0-9][0-9][0-9].cc}.

\subsection*{Options}
 
\begin{description}
\item[\exe{-q}]
   Run quietly.
\end{description}
 
\subsection*{Notes}
 
\begin{itemize}
\item
   The \file{templates} file is normally sorted on the name of the \file{.cc}
   or \file{.h} file so that it can easily be checked that the idents are
   unique.  A separate utility, \exeref{reident}, is provided to help manage
   the idents.
\item
   If a \file{templates} file entry is changed then its \code{ident} should
   also be changed to force its instantiation file to be regenerated.
\end{itemize}

\subsection*{Diagnostics}
 
Status return values
\\ \verb+   0+: success
\\ \verb+   1+: the \file{templates} file contains one or more bad entries
 
\subsection*{Examples}
 
Invokation of \exe{mkinst} is usually done indirectly via specific makefile
targets (see \sref{System generation makefile rules} and \sref{Code
development makefile rules}).  These maintain the template instantiation
files in a subdirectory (\file{tmplinst}) of the directory where the
\file{templates} file resides. 
 
\begin{verbatim}
   mkdir tmplinst
   cd tmplinst
   mkinst -q ../templates
\end{verbatim}
 
\subsection*{See also}
 
\exeref{reident}, Remake the idents in a \file{templates} list.\\
\exeref{duplicates}, Checks for duplicate entries in \file{templates} lists
   across the system.
 
\subsection*{Author}
 
Original: 1996/04/17 by Mark Calabretta, ATNF after a \unixexe{perl} script by
Shelby Yang, NRAO.
 
% ----------------------------------------------------------------------------

\newpage
\section{\exe{updatelib}}
\label{updatelib}
\index{updatelib@\exe{updatelib}}
\index{library!update|see{\exe{updatelib}}}
\index{update!library|see{\exe{updatelib}}}

Update \aipspp\ object libraries.

\subsection*{Synopsis}

\begin{synopsis}
   \code{\exe{updatelib} [\exe{-f}] package}
\end{synopsis}

\subsection*{Description}

\exe{updatelib} updates the object libraries associated with a particular
\aipspp\ package and language (see \sref{Overview}).  It is normally used only
by \aipspp\ \filref{makefiles} but can be invoked in stand-alone mode.  It can
process dual debug and optimized libraries concurrently with another
invokation, possibly on another machine.

An ``\code{\_f}'' or ``\code{\_c}'' appended to the package name, for example
``\code{aips\_f}'', indicates that the \textsc{fortran} or \code{C}
libraries for the package are to be updated rather than the default
\cplusplus\ libraries.  The libraries themselves have names of this form, for
example \file{\$LIBOPTD/libaips\_f.a}.

The \code{lib} and \code{lib/\%} targets of the implement and fortran
makefiles deposit object modules in package/language-specific subdirectories
of \file{\$ARCHTMPD} referred to as \file{\$TMPPCKGD}, for example
\file{\$ARCHTMPD/aips\_f}.  These have separate \file{dbg} and \file{opt}
subdirectories for debug and optimized compilations.  When the \code{lib}
rules have finished compiling all modules they invoke \exe{updatelib} to
insert them into the libraries.

Once invoked, \exe{updatelib} copies the library into the temporary area,
inserts the object modules into it, and then \unixexe{ranlib}s it.  It does
this in turn for the debug and and optimized libraries.

\exe{updatelib} uses the library control variables to determine whether
sharable libraries are to be built (see \filref{makedefs}).  If so, they are
constructed in a subdirectory called \file{BLDSHR.\$ID}, where \file{\$ID} is
an identification string of the form \file{<user>@<host>}.

Only if each static and sharable library was successfully updated does it copy
them back to \file{\$LIBDBGD} and/or \file{\$LIBOPTD}.

With reference to the library control variables, \exe{updatelib} explicitly
looks for and deletes static and/or shared libraries for the package/language
which are not being maintained, thus ensuring that the libraries remain
synchronized.

This whole process is complicated by the fact that the debug and optimized
libraries for a package-language combination can be updated concurrently by
multiple invokations of \exe{updatelib}, possibly on different machines.
Independent invokations of \exe{updatelib} communicate via semaphore files
with names of the form \file{updatelib.*}.  These are described below.

\subsection*{Options}

\begin{description}
\item[\exe{-f}]
   Force a \unixexe{ranlib} and rebuild of the sharable objects (if
   applicable) even if no new object modules are found.
\end{description}

\subsection*{Notes}

\begin{itemize}
\item
   When building the system the implement makefile recurses through all module
   subdirectories, compiling object modules and accumulating them in a
   temporary directory.  The object library is only updated after all modules
   have been compiled.  The alternative of updating the object library after
   processing each software module imposes a large overhead because of the
   large size of the object library, particularly the debug version.
 
   However, the large number of object modules in some \aipspp\ packages may
   cause problems for \exe{updatelib} simply by causing the argument list to
   exceed the maximum imposed by the unix kernel.  This is particularly
   troublesome for systems which use do-it-yourself template instantiation 
   (\sref{Template instantiation}), or have a small value of \code{ARG\_MAX}
   in \file{limits.h} (e.g. HPUX).

   To circumvent this \exe{updatelib} recognizes an \code{UPDBATCH} makedefs
   variable which causes it to process object modules in batches no bigger
   than the specified size.
\item
   \exe{updatelib} should not be terminated with a \code{SIGKILL}
   (``\code{kill -9}'') since this would prevent it from cleaning up its
   semaphore files and possibly cause library updates to be locked out for 24
   hours.  \exe{updatelib} exits gracefully on receiving a \code{SIGHUP}
   (``\code{kill -1}'') or a \code{SIGTERM} (``\code{kill -15}'').
\item
   Stand-alone invokations of \exe{updatelib} obtain \file{makedefs} variable
   definitions via the \code{eval\_vars} target.
\end{itemize}

\subsection*{Diagnostics}

Status return values
\\ \verb+   0+: success
\\ \verb+   1+: initialization error
\\ \verb+   2+: library update failed

\noindent
If any library update fails, none of the libraries will be
updated---with one exception: if a static library build succeeds and its
corresponding shared library build fails then the static library will be
updated.

\subsection*{Examples}

The command

\begin{verbatim}
   updatelib aips
\end{verbatim}

\noindent
would update \file{\$LIBDBGD/libaips.a}, \file{\$LIBOPTD/libaips.a}, and the
corresponding sharable libraries if enabled for the installation.

\subsection*{Files}

\exe{updatelib} uses the following semaphore files:

\begin{description}
\item[\file{\$TMPPCKGD/updatelib.process.\$ID}]
...This file simply declares an invokation of \exe{updatelib}.
\exe{updatelib} determines whether it is the first invokation by testing for
the existence of any file with a name of the form \file{updatelib.process.*}.

\item[\file{\$TMPPCKGD/updatelib.proceed}]
...This file is created by the first invokation of \exe{updatelib}.  It is
used as an ``all-is-well'' semaphore and is deleted by any invokation which
fails to update a library.  Other invokations abort their updates if it
disappears.

\item[\file{\$TMPPCKGD/\{dbg,opt\}/updatelib.\$ID}]
...This is a lock file for the task of updating the static library, whether
debug or optimized, and possibly its sharable counterpart.  Files older than
24 hours are ignored when testing for the existence of one of these locks.  If
a valid lock does already exist then \exe{updatelib} reports it before looking
for further work.

\item[\file{\$TMPPCKGD/\{dbg,opt\}/updatelib.done}]
...When an invokation of \exe{updatelib} has finished updating the library it
renames \file{updatelib.\$ID} to \file{updatelib.done} and then looks for
further work.  The invokation which has reserved the job of installing the
updated libraries tests for the existence of this file as a signal that the
invokation responsible for updating the library has finished.

\item[\file{\$TMPPCKGD/updatelib.lock}]
...Lock file for the invokation of \exe{updatelib} which will install the
updated libraries.  If an invokation sees that this file already exists it
waits for it to disappear before proceeding, thereby synchronizing the
termination of multiple invokations and ensuring that \exe{updatelib} doesn't
return before the library update is complete.
\end{description}

\noindent
The invokation of \exe{updatelib} which installs the libraries also deletes
all semaphore files on completion.

\subsection*{See also}

The unix manual page for \unixexe{ar}(1).\\
The unix manual page for \unixexe{ranlib}(1).\\
\aipspp\ variable names (\sref{variables}).\\
\filref{makedefs}, \aipspp\ makefile definitions.\\
\filref{makefiles}, \gnu\ makefiles used to rebuild \aipspp.

\subsection*{Author}

Original: 1992/04/03 by Mark Calabretta, ATNF.

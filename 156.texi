\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename aips-standards.info
@settitle AIPS++ Documentation Standards.

@c %**end of header

@ifinfo

This document discusses the language for marking-up comments in source
code for later extraction. The comment mark-up language is based on
SGML, Standard Generalized Markup Language. As a result, the language
is sufficiently general to to allow its use in a variety of systems
once it is extracted.

The extracted documentation along with information gained from the
source code is used to generate a complete SGML document.
@end ifinfo

@titlepage
@title AIPS++ Documentation System (rev 2)
@subtitle DRAFT Version
@vskip 0pt plus 1fill
@author Darrell Schiebel
Last modified: $Date$
By: $Author$
@c The above line is maintained by RCS - do not modify it.
@c NOTE #140
@end titlepage

@node Top, Overview, (dir), (dir)

@chapter Introduction

The objective of this system is to provide a way for programmers to
document source code in a way which allows documentation to be extracted and 
converted into a reference document. To accomplish this, it is necessary to 
provide a way for the programmer to specify information which supplements the 
regular comments. This ``extra'' information is know as markup. The 
markup provides a means of structuring the comments, and allows them 
to be formatted in ways more sophisticated than ASCII text. 

This system allows both the source code and the documentation for the source
to exist in the same file. This close proximity will increase the chances
that the reference document will remain up to date. In addition, the goal 
is to have a parser which understands most of the C++ language. This allows 
much of the reference document to be generated automatically from the 
source code.

The first revision of this system used a language similar to the @kbd{roff}
dialects. This language was abandoned in favor of @sc{sgml}, Standard 
Generalized Markup Language. There are a few reasons for this:
@itemize @bullet
@item
Since @sc{sgml} is an ISO/ANSI standard many tools are likely to be available
in the future to support it.
@item
Generalized markup is a better model for information reuse and flexibility.
It allows the information it structures to be used by a variety of 
applications.
@item
@sc{sgml} provides a good basis for future expansion.
@item
Many successful applications already use @sc{sgml}, and the work they and
the various standardization groups have done can be leveraged to our 
benefit.
@end itemize

@section Generalized Markup

The motivation for generalized markup is a departure from that of 
traditional markup languages. With traditional markup languages, the goal 
is to add additional information to a document to allow it to be formatted
for presentation. The markup is formatting information. With generalized
markup, however, the markup is used convey the logical structure of
the information. How this structure is formatted should not be the
concern of the writer. The provider of the information should only
be concerned with providing the important information with the appropriate
logical structure. The actual formatting will be performed by systems
which will use this information. The logical structure of the information 
is much more valuable than the way it should be formatted. If the
information is structured correctly, a variety of post-processors should
be able to use the information which is based on a given tag-set.

So for example a piece of procedural markup might look like:
@example
.TH DF 1V "16 September 1989"
.SH NAME
df \- report free disk space on file systems
.SH SYNOPSIS
.B df
@end example
@noindent
This is a section taken from the @kbd{df} Unix man page. Here, the @emph{.TH} 
command sets up the header -- the reference page is @kbd{DF}, the section 
is @emph{1V}, and the last field is the date of the most recent change. 
The @emph{.SH} command sets up a section heading with the given label, and
the @emph{.B} command displays text in bold. This is relatively typical
of procedural markup. While all of the information necessary to present
a nicely formatted man page is there, it is all superficial. The sections
do not convey the content. The section command is just a section command,
and does not convey the fact that the section is the synopsis. In
a generalized markup language, @sc{SGML} in this case, this section of
the man page might be represented as:
@example
<man ref=DF sect='1V' date="16 September 1989">
<name> df 
<summary> report free disk space on file systems </summary> 
<synopsis> <com>df</com>
@end example
@noindent
Here the document is labeled as a man page and the @i{<man>} attributes
@footnote{Single or double quotes can be used to distinguish literal
values in @sc{sgml}. If an attribute value is a single word, quotes are
not required.} are the information that previously generated the header.
The name is no longer the text of a section heading; it is labeled as 
a @i{<name>}. The synopsis is labeled as a synopsis, @i{<synopsis>}, 
instead of a section with the heading ``SYNOPSIS''. The ``df'' reference
in the synopsis is a command, @i{<com>}, instead of a bold section
of arbitrary text.

Generalized markup allows the important information to be processed
unambiguously by many different systems. With generalized markup,
a @i{<synopsis>} may be treated as a section for printed text, but
for a hypertext system the synopsis may only be displayed if someone
presses the synopsis button (however that is done). The information
represents a synopsis instead of formatting details. The formatting
decisions are left to the discretion of the system which will use the 
information. 

Generalized markup is one tool which will allow information to be
reused for a variety of purposes. Once freed from a particular
formatting language, many applications can utilize the same information
source for many purposes. The same logically structured information can
be used to generate a printed manual, a hypertext system, a database,
or practically anything else that can be done with information.
All that is necessary is that the proper set of tags are defined and
processors exist to manipulate information structured with the tags.

@section Standard Generalized Markup Language

@sc{sgml} is in some sense a meta-language. It allows one to specify 
one of a family of generalized markup languages. @sc{sgml} provides the
language to specify the elements of the markup language and the rules
for composition of these elements. This capability enables mechanical
analysis of documents which utilize an @sc{sgml} specified markup language. 
In addition, since @sc{sgml} is an ANSI/ISO standard compatibility of 
@sc{sgml} systems is guaranteed. In fact, @sc{sgml} has been used for 
representing brail, music, hypermedia, information for tutoring systems, 
published books. @sc{sgml} will be one of the tools which will help to make 
free interchange of information a reality.

@subsection Document Type Definition
One of the most important sections of an @sc{sgml} document is the 
section which defines the tag-set and composition rules which will 
be used in the document. This ``grammar'' is typically located in 
another file and is included at the top of the document in much the
same way that La@TeX{} macro packages would be included in La@TeX{} 
documents. This ``grammar'' section is called the @emph{Document Type
Definition}, @b{DTD}.

@subsubsection Elements
The @b{DTD} specifies the elements, the tags which delimit elements,
and the rules for composition of elements. An element is the smallest
unit of concern for @sc{sgml}. It represents a single concept or logical
unit. So for example, a paragraph might be one element in the @b{DTD},
and one paragraph element might be delimited:
@example
<p> This is my paragraph. </p>
@end example
@noindent
This forms one instance of the paragraph element. The starting,
@i{<p>}, and ending, @i{</p>}, tags delimit the element. The ``p''
in the tags is called a generic identifier, and it serves to distinguish
paragraph elements from other sorts of elements.

Generic identifiers, @b{GI}s, can have attributes. These attributes describe 
important characteristics of the @b{GI}. The attributes are specified within
the starting tag of the element. For example:
@example
<category lib=aips sect="math">
@end example
@noindent
Here the attributes are @i{lib} and @i{sect}. The value for @i{lib} is
``aips'' and the value for @i{sect} is ``math''. Either single quotes,
`` ' '' or double quotes, `` " '', may be used to delimit literal attribute 
values. If the attribute value is one word, no quotes are necessary. The
attribute name is typically limited to eight characters.

@subsubsection Entities
In addition to tags, @sc{sgml} also allow for the definition of entities.
Entities provide a means for simple keyword expansion. This is useful
not only for a shorthand notation, but also as a way of parameterizing
a document to make future changes easy. Entity references begin with
an ampersand and end with a semicolon. So for example, a reference entity
for the less than symbol, ``<'', might be @i{&lt;}. All entities are
typically defined in the @b{DTD}.

Entities are particularly useful to prevent text from being interpreted as
markup. The characters which are of particular concern are ``<'' and ``&'' 
because the introduce element references and entities references respectively. 
However, this should typically not be a problem because misinterpretation 
is only possible when these opening characters are followed directly by a 
non-space character. So ``@i{<test}'' could be interpreted as a tag but
``@i{<@: test}'' could not. Other characters which could cause problems are
``>'' and ``;'' because these are the characters which end element 
references and entity references respectively.

@subsection Body

Once the @b{DTD} has been specified, the user can then structure the 
information in the body of the @sc{sgml} document. Once the tags are
specified they can be used like the commands in other markup 
languages. If the elements are composed incorrectly, a parser will
point out the problems. This is the level at which most @sc{sgml} users
will operate. This is the level at which developers entering comments will
operate. For the developer entering comments, there will not be a ``body'' 
as such. The comments will each be a portion of the ``body'' of the 
@sc{sgml} document. These pieces will be ordered and assembled into the 
body of the document by an extractor.

@chapter Document Generation

The conflicts and complications between
the language in which the source code is expressed and the language in
which the comments are expressed must somehow be resolved. The information
contained in these two languages must be used to generate a reference
document. These issues are discussed in this section along with the tags 
which are used to structure the comments.

@section Mixing Languages

The introduction of a structuring language for comments implies a mixing
at some level of the language being documented and the language in which 
the documentation is expressed. This mixing can happen in one of three
ways:
@enumerate
@item
Provide a system which can integrate the languages at a level higher than
the file level. In this way, the system would provide mechanism to edit
code where the code would be brought up in the programmers favorite
editor, but the documentation would be brought up in a SGML editor. This
gives the best of both worlds. A text editor is used for code, but a more
powerful @sc{wysiwyg} editor can be used to construct the documentation.
@item
Provide a system where the code is described as part of the documentation
system. In this system, the code is extracted from the documentation for
compilation purposes. This is the literate programming environment 
envisioned by Knuth.
@item
Provide a system where the structure of the documentation is described
inside of comments in the source code, and then the whole thing is
massaged into a useful shape by a processor which turns the code/comment
combination into a nice document.
@end enumerate
@noindent
Of these three alternatives I think the first is the cleanest, and it 
could be the most programmer friendly. However, it also involves the 
most work, especially if it is to be truly programmer friendly. It involves
much more work than the latter two options. In addition, it would require
a great deal of trial and error to arrive at a system which was flexible
enough to be used for serious development. The second choice seems nice
in theory, but I fear that this ``literary'' nature of development is
quite foreign to many developers. The extra processing of turning 
documentation into code could also add too much extra time in the 
edit--compile--debug loop for it to be useful in practice. Thus, the
third alternative was chosen. It has the advantage that the source is
always kept in a state which can be compiled.

Reference documents will be assembled out of the
documentation in the comments and the information extracted directly
from the source code. This mixing of source code objects and comment
objects in the same place requires a processor to mesh the two 
languages and rearrange the derived @sc{sgml} objects into a coherent
reference document. 

@section Language and Comment Elements

The code units in a source file will be called ``language elements''.
This includes for example a class definition, a function definition, a 
definition of one or more variables, a class declaration, a function 
declaration, etc. Basically, a language element is any complete statement in 
the grammar for the language. These are the pieces of the language which can 
have comment elements associated with them. Likewise, the comment elements 
are the comments which must @strong{precede} the language element 
with which they are associated. So, for example, the following code 
fragment shows a function definition along with its associated comment.
@example
// <div>
// <p> This function computes the area of a triangle and returns the
// result.
// </div>
float triangle::area() @{
  return (0.5 * base() * height());
@};
@end example
@noindent
In this example, the code element is the definition of the function
@emph{triangle::area()}. The comment element preceding the definition
is associated with the function. This pair will be converted into one
piece of the documentation generated by the documentation extractor.

While comment elements can be provided for any C++ language elements
or preprocessor elements, all comments will not be extracted. Initially,
comments will only be extracted for functions and classes. Later 
elements like ``@emph{#define}''s, structs, enums, etc. will be added.

@section SGML Tags for Documentation

This section discusses the tags which were developed for describing
the logical structure of elements of comments. These are described as
an @sc{sgml} specification in appendix A.

@subsection DTD Elements for Source Code Documentation

@subsubsection Title -- @i{title}

Many documentation elements contain an optional @i{<title>} as their first
component. This allows for the specification of a label for that section
of the overall document. So for example, one might have:
@example
<div> <title> A simple section </title>
<p>The contents of the section.
</div>
@end example
@noindent
The elements which can have titles are @i{<div>}, @i{<warn>}, @i{<note>},
@i{<verbatim>}, @i{<literal>}, @i{<code>}, @i{<enum>}, and @i{<list>}. 
These are explained below.

@subsubsection Text Separators -- @i{div}, @i{p}

There are two basic levels of division where ``plain'' text is concerned.
These divisions are at the paragraph and section level. 

To divide paragraphs the @i{<p>} tags should be used. These tags mark off
a section of text indicating that it makes up a paragraph. The paragraph
contains parsable character data, ``#PCDATA''. This means that the data
in the paragraph can be fully processed by @sc{sgml} for the expansion of
entities and elements. Both starting and ending paragraph tags are optional 
in the cases where no ambiguity exists.

As a short-cut, paragraph beginnings and ends can be implied by blank
lines. So for example, the following comment:
@example
//
// This function computes the volume of a cylinder
//
// Its OK
//
float Cylinder::volume() {
  return C::pi * radius() * radius() * height();
}
@end example
@noindent
would be converted into:
@example
<div>
<p>
This function computes the volume of a cylinder
</p><p>
Its OK
</p>
</div>
@end example
@noindent
The @i{<div>}s are added automatically by the documentation extractor
(discussed below). and the paragraph elements, @i{<p>}, are implicit.
Note that the leading and trailing blank lines are significant. They are
the short-hand notation to start the initial paragraph and end the last
paragraph.

The @i{<div>} tag is the generic tag for sections within a document. These
sections are designed to be referentially transparent and readily 
relocatable. Typically comment elements will be divisions. Both
the starting and ending tags are required for divisions. To obtain
subsections, @i{<div>s} can be nested. For example,
@example
<div>
  <div> <title> Nested Division </title>
     <p> This is the first simple paragraph.
     <p> This is the second simple paragraph.
   </div>
</div>
@end example
@noindent
In this case, the closing paragraph tags can be left off because a 
paragraph cannot contain another paragraph. Typically the closing 
paragraph tag can be left off.

@subsubsection Warnings and Notations -- @i{warn}, @i{note}

These sections of text are for the display of information which should be
important to the user. In the case of @i{<note>}, this should be used to
bring a portion of text to the attention of the user. The @i{<warn>} text
should tell the user information which can result in damage (of some
sort) if the information is not known. For example,
@example
<warn> ... deletion of this object will result in a memory leak under
       these circumstances.
<note> The new operator is private to prevent dynamic creation of
       objects of this class.
@end example
@noindent

@subsubsection Literal Sections -- @i{verbatim}, @i{literal}, @i{code}

Literal sections allow one to create sections which undergo very little 
modification in the process of generating output. There is one subtle
distinction between these sections.

In the case of @i{<verbatim>} and @i{<code>}, very little processing is done.
The characters between the starting and ending tags for these elements are
simply treated as a character string; no elements are processed and no
entities are expanded. The one difference between these two is that
@i{<code>} should be used to display sections of source code, otherwise
@i{<verbatim>} should be used. These are to be used when @b{no} expansion
of entities is required.

In the case of @i{<literal>}, minimal processing is also done on the characters
in a @i{<literal>} section. In this case, however, the entities are expanded
correctly.

@subsubsection Lists -- @i{enum}, @i{list}

All of the lists that are used have a common tag for the elements of the 
list, @i{<item>}. The contents of this tag can only be parsable character
data and the list items do not nest. So for the most part, the closing
@i{<item>} tag can typically be omitted.

There are two ``generic'' list choices. The first type of generic list
is a numbered list, @i{<enum>}. The second generic list type is a
list which distinguishes the elements of the list with bullets, @i{<list>}.
Both of these lists can have a @i{<title>} before any of the elements of the
list. So these might look like:
@example
<list>
  <item> First Element
  <item> Second Element
</list>
<enum> <title> An empty list </title>
  <item> first element
</enum>
@end example
@noindent

@subsubsection Hyperlinks

@strong{To be added later (probably based on @sc{html} or HyTime) ...}

@subsubsection Descriptors

There are several elements which are devoted to describing details about
a given class or function. These descriptors list things like the 
exceptions thrown, the I/O devices accessed, etc.

@subsubheading Class Descriptors

The @i{<descriptor>} element list several important aspects about a given
class. A given @i{<descriptor>} might look like:
@example
<descriptor>
  <execution> <sequential>
  <bounded>
  <memory> <counted>
  <iterator>
  <cached>
</descriptor>
@end example
@noindent
So, this description would describe a class that is purely sequential, has 
a maximum object size, is reference counted, has an iterator class, and
has a builtin caching mechanism. If @i{<bounded>} were not specified,
the assumption is that the object size is unbounded.

This @i{<descriptor>} list corresponds to the object descriptors required
in the @sc{aips++} coding standards. The options are as follows:
@itemize @bullet
@item
@i{<execution>} can contain @i{<sequential>}, @i{<guarded>}, 
@i{<concurrent>}, or @i{<multiple>}. 
@item
If @i{<bounded>} is specified then the object size growth is bounded, 
otherwise it is unbounded.
@item
@i{<memory>} can contain @i{<counted>}, @i{<gc>}, or @i{<unmanaged>}
@item
If @i{<iterator>} is specified, then the object has an iterator, otherwise
it does not.
@item
If @i{<persistent>} is specified, then the object is persistent, otherwise
it is not.
@item
If @i{<cached>} is specified then the object has cached management, otherwise
it does not.
@end itemize
@noindent
Using this list of attributes a great deal of information about the class
can be expressed succinctly.

@subsubheading Device I/O

Often, it is useful to have the ability to track functions which depend
on particular files or I/O devices. This will often target which functions
have direct access to the operating system. So the following would label
a function which performed I/O on the files @kbd{/etc/hosts} 
and @kbd{/etc/motd} using OS specific routines, e.g. @emph{``<stdio.h>''},
@emph{``<iostream.h>''}:
@example
<iodev> <level><os>
   <item> /etc/hosts
   <item> /etc/motd
</iodev>
@end example
@noindent
It is also useful to be able to target functions which access files
using a particular abstraction, e.g. @b{AipsIO}, because although these
files do not depend directly on the operating system function calls they
are tied to particular files. So for example a function that performs
operations on the file @kbd{/usr/local/var/aipsppdb} using @b{AipsIO}
would be labeled:
@example
<iodev> <level> AipsIO
   <item> /usr/local/var/aipsppdb
</iodev>
@end example
@noindent
In this way, the dependencies between the @sc{aips++} and the environment
in which it operates can be tracked.

@subsubheading Exceptional Conditions

It is important to know the exceptions which can be thrown by a given class
or function. This information gives the user of a function the list of
exceptions which he may be required to catch. This information can be 
presented as follows:
@example
<thrown>
  <item> AllocError
  <item> ArrayNDimError
</thrown>
@end example
@noindent
These thrown exceptions should be specified at the member functions which
throw the exceptions. However, the @i{<thrown>} descriptor could also be
used in the comment element for a class. At some time in the future, the
extractor will hopefully be able to generate call trees, and thus pick
up a complete list of all of the exceptions thrown by a given function
automatically. However, this ability depends on having a fully functional
C++ parser available.

@section Extractor Commands

There are extractor commands which provide the user with control over
how and if the comments are extracted. All of these commands have the
form @b{//*} where the ``//'' is the beginning of a C++ comment, and the
``*'' is one or more consecutive non-space command characters.

@subsection Non-processable Comment

Often one will want to specify a comment which only belongs in the source
file, and should not be extracted. This can be accomplished as follows:
@example
//#   This comment will not be extracted
//#Neither will this one
@end example

@subsection Group Command

It is useful to provide a comment and specify that this comment applies to
a group of language elements. This prevents the comment inconsistencies which
can result from duplication of comments. This can be achieved as follows:
@example
// Generally use of this should be shunned, except to use a FORTRAN 
// routine or something similar. Because you can't know the state of 
// the underlying implementation.
//+grp
T *getStorage(Bool &deleteIt);
const T *getStorage(Bool &deleteIt) const;
void putStorage(T *storage, Bool deleteAndCopy);

// <warn> An added problem with freeStorage is that it ...
void freeStorage(const T *storage, Bool deleteIt) const;
//-grp
@end example
@noindent
The @emph{``//+grp''} is the start group command. This command tells the 
extractor that the comment it just encountered should be used as the 
``base'' comment for languages elements until a end group command, 
@emph{//-grp}, is encountered. Any comments that are introduced within 
the group will be added to the end of the base comment for the appropriate 
language element(s). Group commands can be nested as long as the start and 
end group commands are balanced.

@subsection Literal Command

All comment elements, the comment preceding a language element, are 
typically a division, @i{<div>}. However, inside source files this
results in a great deal of clutter in comments which would otherwise
be quite readable. As a result, the extractor will attempt to correctly
add the @i{<div>} tags. The user, however, can prevent the extractor
for adding these by using the literal extractor command. The extractor
will @strong{not} try to spruce up documentation between the start literal
command, @emph{``//+lit''}, and the end literal command, @emph{``//-lit''}. 
The start literal command should occur at the beginning of the comment block,
and the end literal command should occur at the end. The literal command
does not extend over multiple comment elements. The following example 
demonstrates the use of these commands.
@example
//+lit
// <category lib=aips sect=io>
// <div> <title> Problems with this implementation </title>
//   The body of the section.
// </div>
//-lit
@end example
@noindent
These commands prevent the extractor from adding any @emph{user level} 
@sc{sgml} commands. Typically all that the extractor would add is 
@i{<div>}s around a comment element. This allows the user to specify:
@example
//
// This computes the area of the circle.
//
float circle::area() {
  return(C::pi * radius() * radius());}
@end example
@noindent
instead of:
@example
// <div>
// This computes the area of the circle.
// </div>
float circle::area() {
  return(C::pi * radius() * radius());}
@end example

@appendix Document Type Definition

This appendix has the document type definition for the comment markup
language. It is written in @sc{sgml} syntax. The @strong{DTD} defines
``elements'' and ``entities''. The elements are the lowest level of
granularity with which @sc{sgml} deals. The entities function much
like macro; entity references are replaced by the ``body'' of the entity.

There are two basic kinds of entities, general and parameter. The primary
reason a distinction is drawn between these two types of entities is so 
that the general entity name space is unique from the parameter entity 
name space. Parameter entities are typically used by the designer of the 
@strong{DTD}. As a result, parameter entities are typically used within 
other entity or element definitions. This leaves the person writing a 
particular document free to use any names when defining general entities.

Entity definitions begin with ``@i{<!entity}''. So the definition of a general
entity might look like:
@example
<!entity dquot sdata '@{\tt "@}' >
@end example
@noindent
This defines a general entity which can be used to insert ``double
quotes'' into a document. This is done by placing a reference to the
entity in the document, i.e. ``@i{&dquot;}''. Here the ``&'' introduces
the entity reference and the ``;'' ends the entity reference. This double
quote entity is defined in terms of the formatting language into which the 
@sc{sgml} document will be translated, in this case La@TeX{}. So these, 
entities must be changed for each @sc{sgml} processor. For a plain ASCII 
system, the entity might look like:
@example
<!entity dquot sdata '"' >
@end example

Parameter entities are defined and used in much the same way as general
entities. Except that parameter entities are typically used by the
@strong{DTD} designer. The following is an example of a parameter entity
definition:
@example
<!entity % bridgecontent "(p|warn|note|code|enum|list)" >
@end example
@noindent
This defines a entity @i{bridgecontent}. The @i{%} indicates that this is a
parameter entity instead of a general entity. This parameter entity is 
later used to define the elements that a @i{<bridge>} element can contain:
@example
<!element bridge - o ((%bridgecontent)*) >
@end example
@noindent
The @i{%bridgecontent} entity reference is replace by the body of the
entity, @i{(p|warn|note |code|enum|list)}. Element definitions are 
introduced with the`` @i{<!element}'', as shown above. The element definition
has four fields, the name e.g. ``bridge'', a pair of fields which indicate 
if the opening tag and closing tag are optional or required --- an ``o'' 
indicates that it is optional and an ``-'' indicates that it is required ---, 
and a field which indicates the contents of the element. The syntax of
the contents field is similar to lex:
@itemize @bullet
@item
``*'' -- indicates zero or more occurrences
@item
``+'' -- indicates one or more occurrences
@item
``?'' -- indicates zero or one occurrence
@item
``,'' -- indicates a sequence, e.g. (foo,bar) is @i{<foo>} followed by
@i{<bar>}
@item
``|'' -- indicates an ``or'', e.g. (foo|bar) means one of @i{<foo>} or @i{<bar>}
must occur
@item
``&'' -- indicates an ``and'', e.g. (foo&bar) means @i{<foo>} and @i{<bar>}
must occur, but in any order
@item
``()'' -- parentheses provide grouping
@end itemize
@noindent
So, the @i{<bridge>} example above declares a @i{<bridge>} element which can in 
turn contain zero or more @i{<p>}, @i{<warn>}, @i{<note>}, @i{<code>}, @i{<enum>}, 
or @i{<list>} elements. The opening tag is required, but the closing tag is
optional. Elements are the most basic information units handled by @sc{sgml}.
They serve a purpose very similar to productions in a grammar.

In addition to elements and entities, there are several ``special'' 
characters which are useful to know:
@itemize @bullet
@item
@i{&#TAB;} -- Horizontal tab
@item
@i{&#RE;} -- Record end
@item
@i{&#RS;} -- Record start
@item
@i{&#RS;B} -- Record start followed by one or more spaces and/or tabs
@item
@i{&#RS;&#RE;} -- Empty record
@item
@i{&#RS;B&#RE;} -- Record containing only one or more spaces and/or tabs
@item
@i{B&#RE;} -- One or more trailing spaces and/or tabs
@item
@i{BB} -- Two or more spaces and/or tabs.
@end itemize
@noindent
These ``invisible'' characters are most useful when trying to define
keyboard shortcuts which prevent document preparers from having to enter
all of the necessary tags. For instance, inserting paragraph tags can be
made easer as follows:
@example
<!entity psplit '</p><p>' >
<!shortref pmap "&#RS;B&#RE;" psplit 
                "&#RS;&#RE;" psplit >
@end example
@noindent
This allows one to insert paragraph breaks by entering a blank
line, i.e. a blank line or an empty line.

@section Parameter Entities
@subsection Sections
@itemize
@item
<!entity % divcontent @w{"(p|warn|note|verbatim|literal| code|enum|list|descriptor|iodev|thrown)"}>
@item
<!entity % bridgecontent "(p|warn|note|code|enum|list)" >
@end itemize
@subsection Paragraphs
@itemize
@item
<!entity % pcontent "#PCDATA" >
@item
<!entity ptag '<p>' >
@item
<!entity psplit '</p><p>' >
@item
<!shortref pmap "&#RS;B&#RE;" psplit "&#RS;&#RE;" psplit >
@item
<!usemap pmap p>
@end itemize
@section Elements

@subsection Sections
@itemize
@item
<!element div - - (title?, divbody) >
@item
<!element divbody o o ((%divcontent)* | divset) >
@item
<!element divset o o ((div,bridge?)*, div) >
@item
<!element bridge - o ((%bridgecontent)*) >
@end itemize
@subsection Paragraphs
@itemize
@item
<!element p o o (%pcontent) * >

@end itemize
@subsection Warnings and Notations
@itemize
@item
<!element warn - o (title?, #PCDATA) >
@item
<!element note - o (title?, #PCDATA) >
@end itemize
@subsection Literal Sections
@itemize
@item
<!element verbatim - - (title?, (#CDATA)) >
@item
<!element literal - - (title?, (#RCDATA)) >
@item
<!element code - - (title?, (#CDATA)) >
@end itemize
@subsection Lists
@itemize
@item
<!element enum - - (title?, (item*)) >
@item
<!element list - - (title?, (item*)) >
@item
<!element item - o ((p*)|div) >
@end itemize
@subsection Titles
@itemize
@item
<!element title o o (#PCDATA) >
@end itemize
@subsection Class Categories
@itemize
@item
<!element category - o (#EMPTY) >
@item
<!attlist category lib CDATA "misc">
@item
<!attlist category sect CDATA "general">
@end itemize
@subsection Descriptors
@itemize
@item
<!element descriptor - - ((execution|bounded|memory|iterator|persistent)*) >
@item
<!element execution - o (sequential|guarded|concurrent|multiple) >
@item
<!element bounded - o EMPTY >
@item
<!element memory - o (counted|gc|unmanaged) >
@item
<!element iterator - o EMPTY >
@item
<!element persistent - o EMPTY >
@item
<!element cached - o EMPTY >
@item
<!element concurrent - o EMPTY >
@item
<!element memory - o EMPTY >
@item
<!element manage - o EMPTY >
@item
<!element iter - o EMPTY >
@item
<!element persist - o EMPTY >
@item
<!element counted - o EMPTY >
@item
<!element gc - o EMPTY >
@item
<!element unmanaged - o EMPTY >
@end itemize
@subsection Device I/O
@itemize
@item
<!element iodev - - (level?,item*) >
@item
<!element level - o (os|(#PCDATA)) >
@item
<!element os - o EMPTY >
@end itemize
@subsection Exceptions
@itemize
@item
<!element thrown - - (item*) >
@end itemize

@section General Entities (for La@TeX{})
@subsection Required Because of Tags
@itemize
@item
<!entity lt sdata "@{\lt@}" >
@item
<!entity amp sdata "\&" >
@end itemize
@subsection Typically Unnecessary
@itemize
@item
<!entity dquot sdata '@{\tt "@}' >
@item
<!entity num sdata "\#" >
@item
<!entity gt sdata "@{\gt@}" >
@item
<!entity percnt sdata "\%" >
@item
<!entity lpar sdata "(" >
@item
<!entity rpar sdata ")" >
@item
<!entity ast sdata "\mch@{\ast@}" >
@item
<!entity plus sdata "+" >
@item
<!entity comma sdata "," >
@item
<!entity hyphen sdata "-" >
@item
<!entity colon sdata ":" >
@item
<!entity semi sdata ";" >
@item
<!entity equals sdata "=" >
@item
<!entity commat sdata "@@" >
@item
<!entity lsqb sdata "[" >
@item
<!entity rsqb sdata "]" >
@item
<!entity circ sdata "\verb+^+" >
@item
<!entity lowbar sdata "\_" >
@item
<!entity lcub sdata "\@{" >
@item
<!entity rcub sdata "\@}" >
@item
<!entity verbar sdata "@{\verbar@}" >
@item
<!entity tilde sdata "\verb+~+" >
@item
<!entity mdash sdata "@{@minus{}@minus{}@minus{}@}" >
@item
<!entity ndash sdata "@{@minus{}@minus{}@}" >
@item
<!entity hellip sdata "@{\ldots@}" >
@end itemize

@appendix Example Header File
@example
#if !defined(AIPS_COUNTEDPTR_H)
#define AIPS_COUNTEDPTR_H
//# Copyright (C) 1992 
//# Associated Universities, Inc. Washington DC, USA.
//# 
//# This program is free software; you can redistribute it and/or modify
//# it under the terms of the GNU General Public License as published by
//# the Free Software Foundation; either version 2 of the License, or
//# (at your option) any later version.
//# 
//# This program is distributed in the hope that it will be useful,
//# but WITHOUT ANY WARRANTY; without even the implied warranty of
//# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//# GNU General Public License for more details.
//# 
//# You should have received a copy of the GNU General Public License
//# along with this program; if not, write to the Free Software
//# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
//# 
//# The AIPS++ consortium may be reached by email at aips2-request@@nrao.edu.
//# The postal address is: AIPS++ Consortium, c/o NRAO, 520 Edgemont Rd., 
//# Charlottesville, Va. 22903-2475 USA.

template<class t> class CountedPtr;
template<class t> class CountedConstPtr;

//
// This is a dummy class which is not part of "aips/CountedPtr.h". I've 
// included it for the purpose of demonstration. The things to note in 
// the comments in general
// are:
//  <list>
//    <item> The opening blank comment line is significant. It is the 
//           marker for the first paragraph.
//    <item> Blank lines between paragraphs are significant. They 
//           separate paragraphs.
//    <item> The blank comment line at the end of the comment is 
//           significant. It closes the last paragraph.
//  </list>
//
// In addition, although typically the divisions, "div", are not 
// specified for a comment they are generated before and after the comment.
//
template<class t> class  generic_useless_template @{
private:
  t *val;
public:
  //
  // Generic ctor comment.
  //
  generic_useless_template(t *nv) : val(nv) @{@}
  //
  // This is one of the indirection operators. It is here to demonstrate
  // the use of the "+grp" extractor command.
  //+grp
  t &operator*() @{ return *val;@}
  t *operator->() @{return val;@}
  //-grp

  //
  // Just another function.
  //
  void set(t *n) @{
    if (val) delete val;
    val = n;
  @}
  //
  // Generic dtor comment.
  //
  ~generic_useless_template() @{ delete val;@}
@};  
  

//
// <category lib=aips sect=memory>
//
// This class stores the reference count and the pointer to the 
// "real data". 
//
// It is currently a template and is used such that
// "t" is the "true" type of the stored pointer. This means, however,
// that when it is used a template instantiation must be done for
// each type which "t" assumes. This makes debugging easier, but
// in the future all of these pointers could be declared with void
// type to avoid template instantiations.
//
template<class t> class PtrRep @{
friend class CountedPtr<t>;
friend class CountedConstPtr<t>;
private:
  t *val;
  unsigned int count;
protected:
  //
  // This constructor sets up the reference count to "1" and
  // initializes the pointer to the "real" data.
  //
  PtrRep(t *v) : val(v), count(1) @{@}
  //
  // <warn> 
  // This destructor, if called, deletes the "true" data.
  //
  ~PtrRep() @{delete val;@}
@};

//
// <category lib=aips sect=memory>
//
// This class maintains a count of pointers which point to particular
// data, and it deletes the data only when no other counted pointers 
// are pointing at it.
//
// This class is used as a pointer to constant data. As such, it
// only has the subset of the "CountedPtr" functions which are relevant
// for constant data.
//
template<class t> class CountedConstPtr @{
protected:
  PtrRep<t> *ref;
public:
  //
  // After the counted pointer is initialized the value should no
  // longer be manipulated by the raw pointer of type "t*".
  //
  CountedConstPtr(t *val) : ref(new PtrRep<t>(val)) @{@}
  //
  // After the counted pointer is initialized the value should no
  // longer be manipulated by the raw pointer of type "t*".
  //
  CountedConstPtr(const CountedConstPtr<t> &val) : ref(val.ref) @{
    if (ref)
      (*ref).count++;
  @}
  //
  // The destructor deletes the data only when there are no other
  // counted pointers pointing at it.
  //
  ~CountedConstPtr() @{
    if (ref) @{
      (*ref).count--;
      if ((*ref).count == 0)
	delete ref;
    @}
  @}
  //
  // The CountedConstPtr indirection operator simply returns a
  // reference to the value being protected.
  //
  // <note> The address of the reference returned should not be
  // stored for later use.
  //
  const t &operator*() const @{
    return(*(*ref).val);
  @}
  //
  // This dereferencing operator behaves as expected; it returns the
  // pointer to the value being protected, and then its dereferencing
  // operator will be invoked as appropriate.
  //
  const t *operator->() const @{
    return ((*ref).val);
  @}
@};

//
// <category lib=aips sect=memory>
//
// This class maintains a count of pointers which point to particular
// data, and it deletes the data only when no other counted pointers 
// are pointing at it.
//
// This class is used as a pointer to non-constant data, and it has
// all of the possible manipulation functions.
//
// <note> It is possible that use the <code>replace</code> function
// can change the data to which a <code>CountedConstPtr</code> points.
//
template<class t> class CountedPtr : public CountedConstPtr<t> @{
public:
  //
  // Simple function which leaves the work to the parent constructor.
  //
  CountedPtr(t *val) : CountedConstPtr<t>(val) @{@}
  //
  // Simple function which leaves the work to the parent constructor.
  //
  CountedPtr(const CountedPtr<t> &val) : CountedConstPtr<t>(val) @{@}
  //
  // This assignment operator allows CountedPtrs to be freely assigned to
  // each other.
  //
  CountedPtr<t> &operator=(CountedPtr<t> &val) @{
    if (ref) @{
      (*ref).count--;
      if ((*ref).count == 0)
	delete ref;
    @}
    ref = val.ref;
    if (ref)
      (*ref).count++;
    return *this;
  @}
  //
  // This function changes the value for this CountedPtr and all of
  // the other CountedPtrs which pointed to this same value.
  //
  // <note> This can change the value to which a CountedConstPtr points.
  //
  void replace(t *v) @{
    if (ref) @{
      if ((*ref).val)
	delete (*ref).val;
      (*ref).val = v;
    @}
  @}
  //
  // This assignment operator allows the object to which the current
  // CountedPtr points to be changes.
  //
  CountedPtr<t> &operator=(t *v) @{
    if (ref) @{
      (*ref).count--;
      if ((*ref).count == 0)
	delete ref;
    @}
    ref = new PtrRep<t>(v);
    return *this;
  @}
  //
  // The CountedConstPtr indirection operator simply returns a
  // reference to the value being protected.
  //
  // <note> The address of the reference returned should not be
  // stored for later use.
  //
  t &operator*() @{
    return(*(*ref).val);
  @}
  //
  // This dereferencing operator behaves as expected; it returns the
  // pointer to the value being protected, and then its dereferencing
  // operator will be invoked as appropriate.
  //
  t *operator->() @{
    return ((*ref).val);
  @}
@};

#endif
@end example

@bye

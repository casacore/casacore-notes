\documentclass[12pt, twoside]{article}
%\documentstyle[12pt,amsmath]{article}
%\usepackage{html}
\usepackage{epsf}
\usepackage{amsmath}
\usepackage[dvips]{graphicx, color}  % The figure package
\usepackage{palatino}
\usepackage{natbib}     % Package used for bib. citation
%\usepackage{txfonts}
%\usepackage{MnSymbol,wasysym}
\usepackage{marvosym}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[breaklinks]{hyperref}

\colorlet{light-gray}{gray!20}

\markboth{S. Bhatnagar}{MeasurementSet Selection Syntax}
\pagestyle{myheadings}

\setlength{\textheight}{23.0cm}
\setlength{\textwidth}{17.00cm}
\setlength{\topmargin}{-1.0cm}
\setlength{\oddsidemargin}{0.1cm}
\setlength{\evensidemargin}{0.1cm}
%\setlength{\parskip}{5pt}
%\setlength{\parindent}{20pt}

%\evensidemargin -0.7cm
%\oddsidemargin 1.5cm
%\textwidth 13cm
%\topmargin -1.5cm
%\textheight 23cm
%\parskip 1ex    % White space between paragraphs amount
%\sffamily
\renewcommand{\familydefault}{\sfdefault}


\newcommand{\MSS} {{\tt MSSelection}}
\newcommand{\MSSelection}    {\htmladdnormallinkfoot{{\tt MSSelection}}{{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1MSSelection.html}}}
\newcommand{\MSSelectionError} {\htmladdnormallinkfoot{{\tt MSSelectionError}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1MSSelectionError.html}}
\newcommand{\MSSelectionErrorHandler} {\htmladdnormallinkfoot{{\tt MSSelectionErrorHandler}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1MSSelectionErrorHandler.html}}
\newcommand{\CalTables} {\htmladdnormallinkfoot{{\tt CalTables}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1CalTable.html}}
\newcommand{\MSSelectableTable} {\htmladdnormallinkfoot{{\tt MSSelectableTable}}{http://casa.nrao.edu/active/docs/doxygen/html/classcasa\_1\_1MSSelectableTable.html}}
\newcommand{\PDFVersion} {\htmladdnormallinkfoot{PDF Version}{http://www.aoc.nrao.edu/$\sim$sbhatnag/misc/msselection.pdf}}

%\def\myhyperref#1#2{\hyperref[{#1}]{{#2} {(section \ref{{#1}})}}}

\begin{document}
\title{MeasurementSet Selection Syntax}
\author{S. Bhatnagar\\ NRAO, Socorro}
\date{June 15, 2007\\{\small (Updated: April 6, 2015)}}
\maketitle
\normalsize
\begin{center}
  \PDFVersion
\end{center}

\begin{abstract}
  This note describes the syntax for the various expressions for
  selecting data from the Measurement Set, implemented in the
  \MSSelection\ module of CASACore.  All expressions consist of a
  comma or semi-colon separated list of specifications.  Except
  channel selection, the final product of parsing the expressions is a
  Table Expression Node (TEN) which can be used to construct a table
  with only the selected rows.  Higher level global methods to return
  a selected table, given the user supplied expressions, are also
  provided as part of this module.

  Error handling is done via the C++ exception handling mechanism.
  The exceptions thrown by the \MSS\ module are of type
  \MSSelectionError\ which is derived from {\tt AipsError} class.  The
  exceptions generated from each individual expression parser are
  further specializations of the {\tt MSSeletionError} class.
  Application layer code therefore can have a finer level control on
  error handling.  The module also support externally plug-able
  error handlers of type \MSSelectionErrorHandler. This allows
  application layer code to have control on the resolution mechanism
  of the exceptional states that may be reached during the parsing
  cycle.

  The \MSS\ module can also be used for other tables
  that follow the general data base design of the {\tt
    MeasurementSet}.  The CASA \CalTables\ is an example which also
  uses the \MSS\ module for data selection.
\end{abstract}
\newpage
\tableofcontents
\newpage

\section{General Syntax}
\label{Sec:GENERALSYNTAX}
A \MSS\ expression consists of a comma separated list of
specifications.  Specifications are typically strings or numbers.
Strings and numbers can be mixed to form a single list.  Elements of
the list which can be converted to integers are treated as integer
index specification.  Elements which do not get parsed as numbers are
treated as strings.  Where appropriate, strings are matched against
names.  Depending upon the content of a string, it can be used as
regular expressions or pattern.  Where appropriate, physical
quantities (numbers with appropriate units) can also be used.

A blank selection expression is interpreted as "no selection to be
applied to the MS".  Hence a blank expression effectively implies
"select all".

\subsection{Number Format}
\label{Sec:NUMBERS}

Integers can be of any length (in terms of characters) and composed of
the characters in the range 0-9. Where appropriate, negative values
can be given using the '-' character.  Floating point numbers can be
in the standard format:

\begin{itemize}
\item   DIGIT.DIGIT  : e.g. 10.56
\item   DIGIT.       : e.g. 10.
\item   .DIGIT       : e.g. .56
\end{itemize}
or in the mantissa-exponent format (e.g. 10.56e-1).  If a floating
point number is given where only integers are expected (e.g. indexes),
the floating point value is truncated to the nearest integer.

\subsection{Range Specification}
\label{Sec:RANGE}
Range of numbers (integers or real numbers) can be given in the format
N0$\sim$N1.  Integer ranges are expanded into a list of integers
starting from N0 (inclusive) to N1 (inclusive).  Range of real numbers
is used to select all values between N0 and N1 (including the
boundaries). E.g.

Integer ranges:

\begin{itemize}
\item 10$\sim$30 implies all integers in the range [10,30]
\item 10.1$\sim$30.5 implies all integers in the range [10,30]
\end{itemize}
Floating point ranges:
\begin{itemize}
\item 10$\sim$30 implies all values in the range [10.0, 30.0]
\item 10.5$\sim$30.7 implies all values in the range [10.5, 30.7]
\item 1.05e1 $\sim$ 3.07e1 implies all values in the range [10.5,
  30.7]
\end{itemize}

\subsection{Units}

Wherever appropriate, units can be optionally specified.  Values with
units are converted to the units in the Measurement Set (which uses
the MKS-system).  For ranges, the units are specified only once (at
the end) and it applies to both the range boundaries. E.g.

\begin{itemize}
\item   1421.07MHz implies 1421.07e6 Hz
\item 1421$\sim$1500MHz implies all frequencies in the range [1421.0,
  1500.0]MHz.
\end{itemize}

\subsection{Strings}
\label{Sec:STRINGS}
String matching can be done in three ways.  Any component of a comma
separated list that cannot be parsed as number/number range/physical
quantity is treated as a regular expression or a literal string.  If
the string contains any of the '*', '\{', '\}' or '?' characters, it
is treated as a pattern (a simplified form of regular expression).
Otherwise it is treated as a literal string and used for exact
matching.  As a result, for most cases, the user does not need to
supply any special delimiters for literal strings and/or regular or
pattern matching expressions.  However if it is required that the
string be matched exclusively as a regular expression, it can be
supplied within a pair of '/' as delimiters.  A string enclosed within
double quotes ('"') is used exclusively for pattern matching (patterns
are a simplified form of regular expressions - used in most UNIX
commands for string matching). Patterns are internally converted to
equivalent regular expressions before matching.  Read elsewhere
(e.g. use command "info regex", or visit \htmladdnormallinkfoot{this
  link}{http://www.regular-expressions.info}) for details of regular
expression and patterns.

Strings can include any character except the following:

\begin{verbatim}
   ','   ';' '"'  '/'  ':' and NEWLINE
\end{verbatim}
(these are reserved characters for \MSS\ expression syntax).
Strings that do not contain any of the characters used to construct
regular expressions or patterns are used for exact matches.  Although
it is highly discouraged to have name in the database containing the
above mentioned reserved characters, if one DOES choose to include the
reserved characters are part of names etc., those names can only be
matched against quoted strings (since regular expression and patterns
are super-set of literal strings. I.e. literal string is a valid
regular expression also).  This leaves the list '"', '*', '?', '\{' and
  '\}' as the list of printable character that cannot be part of a name
(i.e., a name containing this character can never be matched in a
\MSS\ expression).  If a need is felt to include these as well,
an escape mechanism can be included later (but I would prefer to
enforce that {\bf at least} these characters not be part of any
name!).  Following are some examples of strings/regular
expressions/patterns:

\begin{itemize}
\item The string LBAND will be used as a literal string for exact
  match.  This will match only "LBAND".
   
\item The string {\tt *BAND*} will be used as a string pattern for
  matching.  This will match any string which has "BAND" in it.
 
\item The string {\tt"*BAND*"} will be used as a string pattern for
  matching.  This will also match any string which has the string
  "BAND" in it.

\item The string /.*BAND.*/ will be used as a regular expression.
  This will also match any string which has the string "BAND" in it.
  (.* operator has the same meaning as the '*' operator of patterns).
\end{itemize}

\subsection{White Spaces (blanks in expressions)}

In most cases, blanks are treated as white-spaces (i.e., insertion of
blanks anywhere in the expression has no effect), except in the case
of Field Selection Expressions (see Section~\ref{FIELDEXPR}).  Blanks
are allowed as part of the field names.  Blanks around the delimiting
characters (',' , ';' , '\&' etc.) are ignored.  For field names,
blanks after the first valid name character and before the last valid
name character are included as part of the name.  Hence

\begin{itemize}
\item field={\tt A , B , C} is same as field={\tt A,B,C}
\item field={\tt A , BB~BB , C} is same as field={\tt A,BB~BB,C}
  (first name is "A", second name is "BB~BB" and the third name is
  "C")
\item baseline={\tt 1 , 2 , 3 \& 4 , 5 , 6 ; 10 $\sim$ 11 \& 20 $\sim$
  30} is same as\\ baseline={\tt 1,2,3\&4,5,6;10$\sim$11\&20$\sim$30}
\end{itemize}

\section{Time Selection}

Time selection expression is a comma separated list of time
specifications. Time can be specified in the format
YYYY/MM/DD/HH:MM:SS.FF.  Fields (i.e., YYYY, MM, DD, HH, MM, SS and
FF), starting from left to right, can be omitted.  Omitted fields will
be replaced by context sensitive defaults as explained below.

\begin{table}[h]
\caption{Railroad diagram for the syntax of time/time-range selection expression.}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\small {Syntax of}              & \small{Railroad Diagram}\\
\hline
   TIME Expression     &  \includegraphics[width=8cm]{TIME-EXPR.png}\\
\hline
   TIME-RANGE          &  \includegraphics[width=8cm]{TIME-RANGE.png}\\
\hline
\end{tabular}
\label{Tab:RAILROAD_TIME}
\end{center}
\end{table}

\subsection{Syntax}

Various forms of possible time-selection expression are listed below.
T0, T1 and dT in the following description are time specifications.

\begin{itemize}
\item {\bf time~=~~T0$\sim$T1}

  Selects all time stamps which satisfy the following condition:

\begin{quote}
  (TimeStamp $>$= T0) {\bf and} (TimeStamp $<$= T1)
\end{quote}

  Fields missing in T0 are replaced by the fields in the time stamp of
  the first valid selected row in the MS.  Fields missing in T1 are
  replaced by the corresponding fields of T0 (after its defaults are
  set).

\item {\bf time~=~~[T0$\sim$T1]}

  The edges of the range is computed using the Exposure Time.  All
  rows with a time stamp which satisfy the following condition are
  selected:
   
\begin{quote}
  ((TimeStamp $>$ T0) {\bf or} (abs(TimeStamp - T0) $<$ ExposureTime/2)) {\bf and}\\
  ((TimeStamp $<$ T1) {\bf or} (abs(TimeStamp - T1) $<$ ExposureTime/2))
\end{quote}

  Fields missing in T0 are replaced by the fields in the time stamp of
  the first valid selected row in the MS.  Fields missing in T1 are
  replaced by the corresponding fields of T0 (after its defaults are
  set).

\item {\bf time~=~~FLOATNUMBER [T0$\sim$T1]}

  Same as the previous expression with the edges of the range
  determined using the FLOATNUMBER (in seconds of time) instead of
  Exposure Time.  All rows with a time stamp which satisfy the
  following condition are selected:
   
\begin{quote}
  ((TimeStamp $>$ T0) {\bf or} (abs(TimeStamp - T0) $<$ FLOATNUMBER)) {\bf and}\\
  ((TimeStamp $<$ T1) {\bf or} (abs(TimeStamp - T1) $<$ FLOATNUMBER))
\end{quote}

  Fields missing in T0 are replaced by the fields in the time stamp of
  the first valid selected row in the MS.  Fields missing in T1 are
  replaced by the corresponding fields of T0 (after its defaults are
  set).

\item {\bf time~=~~T0}

  All rows with time stamp that is within an integration time of T0
  are selected.  Integration time is determined from the first valid
  selected row (more rigorously, an average integration time should be
  computed).  Default settings for the missing fields of T0 are as
  described in bullet (1) above.

\item {\bf time~=~~T0+dT}

  All rows with time stamp starting from T0 and ending with time value
  given by T0+dT are selected. Defaults of T0 are set as usual described in bullet
  (1) above.  Defaults for dT are set from the time corresponding to
  MJD=0.  I.e. dT is an specification of length of time from nominal
  "start of time" (the time stamp of the first valid selected row of
  the MS).

\item {\bf time~=~~$>$T0} 

  Selects all times greater than T0.

\item {\bf time~=$<$T0} 

  All rows with time stamp less than T0 are selected. Default settings
  for T0 are as above.
\end{itemize}

\section{Antenna/Baseline Selection}
\label{Sec:BASELINE}
This expression is used to perform baseline based selections.
Baseline can be specified as a pair of antenna specifications.  Since
antenna specification can itself be a list of antennas, the expression
allows a rich selection syntax which is simple for simple selections.

ANT in the description below is a comma-separated list of antenna
specifications.  A baseline specification is an single ANT, ANT
followed by an operator or a pair of ANT separated by an operator.  A
baseline expression is single baseline specification or a semi-colon
separated list of baseline specifications.

The full antenna and baseline expression syntax is described in the
Railroad Diagram format in Table~\ref{Tab:RAILROAD_BASELINE} and
explained in the following sections.

\begin{table}[h]
  \caption{Railroad diagrams for the syntax of full baseline selection expression.
    Note that this is also referred to as ``antenna selection'' expression.}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\small {Syntax of}         & \small{Railroad Diagram}\\
\hline
   BASELINE Expression     &  \includegraphics[width=8cm]{BASELINE-EXPR.png}\\
\hline
   Antenna Expression      & \includegraphics[width=8cm]{ANT-EXPR.png}  \\
   (ANT-EXPR)              & \\
\hline
   Antenna/Station Spec.   & \includegraphics[width=8cm]{ANT-STATION-SPEC.png}\\
   (ANTSPEC, STATIONSPEC)  & \\
\hline
\end{tabular}
\label{Tab:RAILROAD_BASELINE}
\end{center}
\end{table}

\subsection{Syntax}

\subsubsection{Antenna Specification}

An ANT can be given as a single \hyperref[Sec:STRINGS]{string (section~\ref{Sec:STRINGS})}
% \hyperref{string}{string (see Section}{)}{Sec:STRINGS} 
(literal/pattern/regular expression), single integer ID, a 
\hyperref[Sec:RANGE]{range (section~\ref{Sec:RANGE})}
% \hyperref{range}{range (see Section }{)}{Sec:RANGE} 
of integer
IDs or a comma separated list of integers.  For VLA-specific reasons
(see Section~\ref{VLACONVENTION}), {\bf only} for antenna
specifications, integers are first converted to strings and matched
against the antenna names.  E.g.

\begin{itemize}
\item {\tt VLA:N1} corresponds to antenna named "VLA:N1".
\item {\tt 1,2,3} corresponds to antennas {\bf named} "1", "2" and
  "3".
\item {\tt 1$\sim$3} corresponds to antennas {\bf named} "1", "2" and
  "3".
\item {\tt VLA:N*} corresponds to all antennas who's name starts with
  "VLA:N".
\end{itemize}

The precise logic applied to the antenna specification (ANT) is as
follows:

\begin{enumerate}
\item If ANT is an integer index (or a list or 
  \hyperref[Sec:RANGE]{range (section~\ref{Sec:RANGE})}
%  \hyperref{range}{range (see Section }{)}{Sec:RANGE})
  , it is first used as a name (e.g. the
  index 1 is converted to a string "1" etc.)  and matched against the
  {\tt NAME} column of {\tt ANTENNA} sub-table.  If no match is found,
  it is treated as an integer index and matched against the antenna
  indices.

\item If ANT is a string which cannot be converted to an integer, it
  is first matched against the {\tt NAME} column of the {\tt ANTENNA}
  sub-table.  If no match is found, match against the {\tt STATION}
  column is attempted.
\end{enumerate}

\subsubsection{Antenna@Station Specification}

A fully qualified antenna specification can also include the station
name via the {\tt ANT@STATION} syntax.  {\tt STATION} specification
follows the same rules as antenna specification. When antenna or
station in a {\tt ANT@STATION} syntax is a comma-separated list, the
list must be enclosed in a left- and right-parenthesis pair to
distinguish it from a comma-separated list of {\tt ANT@STATION} (i.e.,
{\tt "A1@S1, A2@S2, A3@S3"} versus {\tt "(A1,A2,A3)@(S1,S2,S3)"}).  All
antennas in the {\tt ANT} part of the specification on {\it any} of
the stations in the {\tt STATION} part of the specification will be
selected.  The {\tt ANT} part of the specification is optional and
when not specified is replaced with the wild-card {\tt "*"} (i.e. {\tt
  "@STATION"} is equivalent to {\tt "*@STATION"}).

The two forms of specifications that are interpreted differently are:
\begin{enumerate}
\item List of ANT@STATION: {\tt A1@S1, A2@S2, A3@S3,....}
\item (List of ANT)@(List of STATION): {\tt (A1, A2, A3)@(S1,S2,S3)}
\end{enumerate}
First form is similar to the comma-separated list of antenna
specifications used to construct the baseline to be selected (see
Section~\ref{BASELINE_SPEC}).  The latter will select all members of
the antenna list that are on any of the stations listed in the station
list.  E.g. if antenna {\tt A1} appears on stations {\tt S1} and {\tt
  S3}, both will be selected in the second form, but only the antenna
{\tt A1} on station {\tt S1} will be selected in the first form.  Note
that the second form of specification can itself be a member of a
comma-separated list.


\subsubsection{Baseline Specification}
\label{BASELINE_SPEC}

A baseline specification consists of an ANT followed by an
operator or a pair of antenna specifications separated by an operator.
Operator can be one, two or three ampersands ({\tt '\&'}):

\begin{table}[h!]
\caption{Table of allowed baseline selection operators and their meaning.} 
\begin{center}
\begin{tabular}{|c|l|}
\hline
{\bf The operator} & {\bf Operation}\\
\hline
{\tt \&} & Select only cross-correlation data\\
\hline
{\tt \&\&} & Select cross- {\it and} auto-correlation data\\
\hline
{\tt \&\&\&} & Select {\it only} auto-correlation data\\
\hline
\end{tabular}
\end{center}
\label{BASELINEOP:TAB}
\end{table}

%  {\tt
%   '\&'} selects {\it only} cross-correlation baselines, {\tt '\&\&'}
% selection cross- {\it and} auto-correlation baselines and {\tt
%   '\&\&\&'} selection {\it only} auto-correlation baselines.

Possible forms of baseline specifications are tabulated in
Table~\ref{BASELINE:TAB}.
\begin{table}[h!]
  \caption{Baseline specification syntax: ANT, ANT1 and ANT2 in the
    table below represent a comma-separated list of antennas names or
    a list of {\tt ANT@STATION} specifications.  {\tt ANT} and {\tt
      STATION} in {\tt ANT@STATION} can themselves be comma-separated
    lists enclosed in braces.}
\begin{center}
\begin{tabular}{|l|l|}
\hline
{\bf Specification} & {\bf Meaning}\\
\hline
{\tt ANT}    & Select only cross-correlation baselines between all the\\
             & antennas in {\tt ANT} and {\it all} other available antennas\\
\hline
{\tt ANT\&}  & Select only cross-correlation baselines between antennas\\
             & in {\tt ANT} only\\
\hline
{\tt ANT1 \& ANT2} & Select only cross-correlation baselines between antennas\\
                   & in {\tt ANT1} and {\tt ANT2}\\
\hline
{\tt ANT\&\&} & Select cross- {\it and} auto-correlation baselines between all\\
              & the antennas in {\tt ANT} only\\
\hline
{\tt ANT\&\&*} & Select cross- {\it and} auto-correlation baselines between all\\
               & the antennas in {\tt ANT} and {\it all} other available antennas\\
\hline
{\tt ANT1 \&\& ANT2} & Select cross- {\it and} auto-correlation baselines between\\  
                     & antennas in {\tt ANT1} and {\tt ANT2}\\
\hline
{\tt ANT\&\&\&}  & Select {\it only} auto-correlation baselines for antennas in {\tt ANT}\\
\hline
{\tt !ANT}  & Excludes all baselines involving antennas in {\tt ANT}. {\tt ANT} can be\\ 
            & any of the above expressions\\
\hline
{\tt ANT1 ; !ANT2} & {\tt ANT1} and {\tt ANT2} can be any of the above
expressions. This \\
                   & selects only cross-correlation baselines between all the\\
                   & antennas in {\tt ANT1} and {\it all} other available antennas {\bf except} \\
                   & those involving antennas in {\tt ANT2}.\\ 
\hline
\hline
{\tt A1@S1}        & Select baselines with antenna {\tt A1} on station {\tt S1} only\\
\hline
{\tt (A1,A2)@(S1,S2)}  & Select baselines with antenna {\tt A1} on station {\tt S1} or {\tt S2} and \\
                       & antenna {\tt A2} on station {\tt S1} or {\tt S2}\\
\hline
\end{tabular}
\end{center}
\label{BASELINE:TAB}
\end{table}
Formally, baseline specification is of the form {\tt
  [!]ANT[$<$OP$>$[ANT]]} (where the parts in square brackets are
optional and {\tt $<$OP$>$} can be {\tt '\&', '\&\&'} or {\tt
  '\&\&\&'}).


\subsubsection{Baseline Negation Operator}

The negation operator {\tt '!'} can be used to exclude a baseline
specification from the final selection.  The negation operator applies
to the single expression only.  Hence in a compound expression
(collection of expressions separated by ``;''), if a baseline
specification is negated in one expression and included in a following
expression, it will {\it not} be excluded from the selection.  {\it
  Note that this is a baseline negation operator and not an antenna
  negation operator}.  The negation operator applies only to the
baseline specification {\it immediately} following it.  E.g.,

\begin{itemize}
\item baseline={\tt !15} excludes all baselines with the antenna {\bf
  named} "15"
\item baseline={\tt!1$\sim$10} excludes {\bf all} baselines involving
  the antennas {\bf named} between "1" and "10"
\item baseline={\tt !1,3,5,7,9} excludes all baselines involving
  antennas {\bf named} "1", "3", "5", "7" and "9"
\item baseline={\tt 1$\sim$10;!5} selects all baselines involving
  antennas {\bf named} between "1" and "10" {\it except} those
  involving antenna {\bf named} "5".
\end{itemize}

Note that the negation operator {\it cannot} be applied to individual
members of the antenna specification/antenna list.  E.g. the
expression {\tt "1,2,!5,8"} is syntactically incorrect.

\subsubsection{Baseline negation and Regular Expression negation}
Since antenna names in a antenna/baseline selection can be a regular
expression or a pattern, one can preceed a name, pattern or regex by
``\^'' (the regular expression negation operator) to negate that
name. Thus
\begin{verbatim}
      ^VLA:N*
\end{verbatim}
means all antennas except {\tt VLA:N*}.  Note that {\tt {}\^{}VLA:N*} and
{\tt !VLA:N*} are very different. The first one forms all
cross-correlation baselines of the antenna in the remaining arms with
all antenna (also VLA:N antenna). Thus {\tt {}\^{}VLA:N*} is the same as
{\tt VLA:[SE]*}. The second one has all baselines between the antenna
in the remaining arms, but also autocorr between VLA:N antenna.

\subsubsection{Examples}
In the most common usage, an atomic ANT selects all baselines
containing all the antennas in ANT.  ANT\& selects only baselines
between the list of antennas in the antenna specification.  ANT1\&ANT2
selects baselines between antennas in ANT1 and ANT2 only.  E.g.

\begin{itemize}
\item baseline={\tt 1,2,3} selects baseline between antennas 1, 2 and
  3 and all other antennas.
\item baseline={\tt 1,2,3\&} selects baseline between antennas 1,2 and
  3 only.
\item baseline={\tt 1,2,3 \& 4,5,6} selects baselines between antennas
  1,2,3 and 4,5,6.
\end{itemize}
Following are more examples of baseline specification using ranges and
names:
\begin{itemize}
\item baseline={\tt 1$\sim$3} same as baseline=1,2,3
\item baseline={\tt 1$\sim$3\&} same as baseline=1,2,3\&
\item baseline={\tt 1$\sim$3 \& 4$\sim$5} same as baseline={\tt
  1,2,3\&4,5,6}
\item baseline={\tt VLA:N* \& VLA:E*} selects all baselines between
  antennas with names starting with "VLA:N" and "VLA:E".
\item baseline={\tt 21;!15} selects baselines between antenna {\bf
  named} "21" and all other available antennas, {\it except} antenna
  {\bf named} "15".  I.e, baseline "21-15" (or its conjugate, if
  present in the database) is excluded.
\end{itemize}

The full baseline selection expression is any of the examples shown
above or a semi-colon-separated list of baseline specifications.  E.g.

\begin{itemize}
\item baseline={\tt 1$\sim$3\& ; 4$\sim$5\&10$\sim$15 ; VLA:N* \&
  VLA:E*}
\end{itemize}
with each elements of the semi-colon separated list being interpreted
as explained above.


\subsection{Integers-as-names VLA Naming Convention}
\label{VLACONVENTION}
Antenna naming convention for VLA is such that the antenna names are
actually valid integers converted to strings.  While we feel that this
is indeed a bad idea and it will be best to translate the VLA antenna
names to something like VLA1, VLA2 in the CASA VLA filler (or
something that does reflect that its a name and not get confused with
integer indexes), for now, to accommodate the VLA tradition, the
following logic is used:

\begin{quote}
{\it  Just for antenna selection, a user supplied integer (or integer
  list) is converted to a string and matched against the antenna name.
  If that fails, the normal logic of using an integer as an integer
  and matching it with antenna index is done.}
\end{quote}
For example, if the antenna with index 17 is named "21", the string
{\tt "21,VLA22"} will expand into an antenna index list of 17,22
(assuming that the antenna named VLA22 has index 22).

If we conclude that this style of antenna selection is indeed the way
we wish to go, users should be aware that the antenna selection will
behave differently for telescopes other than VLA.  For example,
assuming that antenna with names "21","17", and "11" have indices 1,2
and 3, for VLA only a selection string "21,17,11" will select antenna
with indices 1, 2 and 3.  For other instruments where this is not the
naming convention, the same selection string ("21,17,11") will select
antennas with indices 21, 17, and 11.

%% \subsubsection{Note}

%% \begin{enumerate}
%% \item   Selection on polarization is not implemented.
%% \end{enumerate}

\section{Field Selection}
\label{FIELDEXPR}
\subsection{Syntax}

Field specifications can be literal field names, regular expressions
or patterns.  Leading and trailing blanks are stripped from the user
supplied field specifications as well as from the entries of the NAME
and field codes before being used for matching.  

Since none of the following characters are used as part of the FIELD
selection expressions, they can also be used as part of field names:
";", "\$", "\%", "!", "@", and "\#"\footnote{In case users loose their
  patience with the NRAO Observation Preparation Tool (NRAO OPT) and
  start giving field names like ``{\tt @\#!\$\%;}'', to them we can say ``...we
  understand.'' {\bf \Smiley{}}}.

Fields for which the entry in the NAME column of the the FIELD
sub-table match the literal field name/regular expression/pattern are
selected.  If a field name/regular expression/pattern fails to match
any field name, the given name/regular expression/pattern are matched
against the field code.  If still no field is selected, an exception
of type MSSelectionFieldParseError is thrown.

Field specifications can also be give by their integer IDs.  IDs can
be a single ID or a \hyperref[Sec:RANGE]{range (section~\ref{Sec:RANGE})} %\hyperref{range}{range (see Section }{)}{Sec:RANGE}
of IDs (N0$\sim$N1).  Field ID selection can also be done using a
boolean expression.  For a field specification of the form "$>$ID",
all field IDs greater than ID are selected.  Similarly for "$<$ID" all
field IDs smaller than ID are selected.

The field selection expression is a comma-separated list of field
specifications.  E.g.

\begin{itemize}
\item field={\tt 1,2,3,4} selects field IDs 1,2,3 and 4
\item field={\tt 1$\sim$4} same as above
\item field={\tt 1$\sim$4, VIRGO A , 3C*} selects field IDs 1,2,3,4
  field named "VIRGO A" and all fields with names starting with "3C".
\end{itemize}

\section{UV Distance Selection}

\subsection{Syntax}
\label{SPWEXPR}

A uv-distance specification is given as a physical quantity (number
with units in the format {\tt NUMBER[UNIT][:NUMBER\%]} where syntax in
square brackets is optional).  This is referred to as UVDIST in the
description below.  Units are optional with the default unit being
meter.  Units can be specified as "m"/"M" (for Mega) or "k"/"K" (for
Kilo) followed by "m"/"M" (for meter) or "lambda"/"LAMBDA" (for
wavelength).  User supplied values are converted to internal
Measurement Set units using the spectral window sensitive reference
frequency.

If only a single UVDIST is specified, all rows that exactly match the
given UVDIST are selected.  When UVDIST is given as a
\hyperref[Sec:RANGE]{range (section~\ref{Sec:RANGE})} in the format
{\tt N0$\sim$N1[UNIT]} (where N0 and N1 are valid numbers), all rows
corresponding to the uv-distance between N0 and N1 (N0 and N1
included) are selected.

Rows can also be selected via boolean expressions.  When specified in
the format "$>$UVDIST", all rows with uv-distance greater than the
given uv-distance (converted to the appropriate units) are selected.
When specified in the format "$<$UVDIST", all rows with uv-distance
less than the given uv-distance (converted to the appropriate units)
are selected.

The {\tt :NUMBER\%} syntax can be used to selected rows with uv-distance within an
equal range on either side of a given range.  All rows with
uv-distance between $\pm$N percent of the uv-range determined by the
uv-distance expression in appropriate units are selected.

The full uv-distance selection expression is a comma-separated list of
any of the above mentioned uv-distance specifications.  E.g.

\begin{itemize}
\item uvdist={\tt 100Klambda} selects all baselines for which
  $\sqrt{u^2+v^2}$ is equal to 100~K$\lambda$.
\item uvdist={\tt 100Km} selects all baselines for which
  $\sqrt{u^2+v^2}$ is equal to 100~Km.
\item uvdist={\tt 100$\sim$200Klambda} selects all baselines for which
  $\sqrt{u^2+v^2}$ is in the range [100, 200]~K$\lambda$.
\item uvdist={\tt $>$100Klambda} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is greater than 100~K$\lambda$.
\item uvdist={\tt $<$100Klambda} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is less than 100~K$\lambda$.
\item uvdist={\tt $<$100Klambda:5\%} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is less than 100+5~K$\lambda$.
\item uvdist={\tt 100$\sim$200Klambda:5\%} selects all baselines for which
  $\sqrt{u^2 + v^2}$ is between 100-5 and 200+10~K$\lambda$.
\end{itemize}

\section{Frequency Selection}

Frequency selection expression consists of two specifications
separated by colon (':') in the form:
\begin{verbatim}
      SPWSPEC[:FREQSPEC]
\end{verbatim}
where SPW is the spectral window specification and FREQSPEC is the
optional frequency specification for selection within the selected
spectral windows.  When channel specification is omitted, all channels
of the selected SPW are selected.

SPWSPEC and FREQSPEC allow use of semi-colon separated lists.  As a
result, list of SPWSPEC can be given in two ways: (1) a semi-colon
separated list, (2) coma separated list.  This allows simple
selections to remain simple and more complex selections consistent
with the syntax for FREQSPEC list.

The full syntax is shown in the Railroad Diagram format in
Table~\ref{Tab:RAILROAD_SPW} and explained in the following sections.

\begin{table}[h]
  \caption{Railroad diagrams for the syntax of full frequency selection expression.}
\begin{center}
\begin{tabular}{|l|l|}
\hline
\small {Syntax of} & \small{Railroad Diagram}\\
\hline
   SPWSPEC[:FREQSPEC] expression    &  \includegraphics[width=8cm]{SPW-EXPR.png}  \\
\hline
   SPWSPEC   &   \includegraphics[width=8cm]{SPWID.png}\\
\hline
   FREQSPEC    &   \includegraphics[width=8cm]{FREQ.png}\\
\hline
   RANGESPEC   &   \includegraphics[width=8cm]{RANGE.png}\\
\hline
\end{tabular}
\label{Tab:RAILROAD_SPW}
\end{center}
\end{table}

\subsection{Spectral Window Specification Syntax}

Spectral windows (SPW) specification can be of the following types:
\begin{enumerate}
\item an integer ID 
\item a name (as a literal 
\hyperref[Sec:STRINGS]{string (section~\ref{Sec:STRINGS})} for exact match
or a regular expression/pattern)
\item a frequency value (value with a unit).  
\end{enumerate}

\subsubsection{Selection by ID}

SPWSPEC can be single integer, a list or a range of integers.  It can also be
a list of boolean expressions involving IDs.  E.g.
\begin{itemize}
\item spwspec="$>$ID" will select all SPWs with ID greater than the specified
  value.
\item spwspec="$<$ID" will select all SPWs with ID lesser than the specified
  value.
\item spwspec={\tt 1,2,3} selects spectral window IDs 1,2 and 3
\item spwspec={\tt 1;2;3} same as above.  This style can be used along
  with FREQSPEC
\item spwspec={\tt 1$\sim$3} same as above
\end{itemize}

\subsubsection{Selection By Name}

SPWSPEC can be a name or a list of names which will be matched against
the NAME column of the SPECTRAL\_WINDOW.  The name can be
a string for literal matching, or a regular expression or a pattern.
All SPWs that match the given name will be selected.  E.g.
\begin{itemize}
\item spwspec="LBAND" will select {\it a} SPW named ``{\tt LBAND}''.
\item spwspec="SUBBAND*" will select all SPWs with the name starting with ``{\tt SUBBAND}''.
\item spwspec="SUBBAND*0" will select all SPWs with name starting with ``{\tt
    SUBBAND}'' and ending with ``{\tt 0}''.
\end{itemize}

\subsubsection{Selection By Frequency}
SPWSPEC can also be constructed using the reference frequency of the
SPWs.  The reference frequency is defined as the average of the
frequency corresponding to the first and the last channel for each
SPW.  A single frequency specification is used for exact match with
the reference frequency.  A \hyperref[Sec:RANGE]{range
  (section~\ref{Sec:RANGE})} of frequencies are used to select all
SPWs with the reference frequencies within the given range.  The
allowed units are Hz, KHz, MHz, GHz or THz.  E.g.
\begin{itemize}
\item spwspec="$>$FREQ" will select all SPWs, the reference frequencies of
  which are greater than the given frequency converted to Hz.
\item spwspec="$<$FREQ" will select all SPWs, the reference frequencies of
  which are greater than the given frequency converted to Hz.
\item spwspec={\tt 327MHz} selects spectral window with a reference
  frequency equal to 327.0 MHz
\item spwspec={\tt 327$\sim$610MHz} selects all spectral windows with
  reference frequencies in the range [327.0, 610.0] MHz.
\item spwspec={\tt 1421MHz, 1422MHz, 1423MHz} selects SPWs with reference
  frequency 1421.0, 1422.0 and 1423.0 MHz.
\item spwspec={\tt 1421MHz; 1422MHz; 1423MHz} same as above.  This style
  can be used along with FREQSPEC.
\item spwspec={\tt $>$327MHz} selects all spectral windows with reference
  frequency greater than 327.0 MHz
\item spwspec={\tt $<$327MHz} selects all spectral windows with reference
  frequency less than 327.0 MHz
\end{itemize}

\subsection{Channel Specification Syntax}

Channel specification\footnote{\it The \MSS\ module is currently
  used to only parse the channel selection expression to produce the
  START,STOP,STEP tuples.  No channel based selection is actually
  applied to the data.  The list of tuples per SPW is passed to the
  application program layer and the interpretation of the tuples for
  actual selection depends on the application programmer.} (referred
to as FREQSPEC in the following description) is a START, STOP, STEP
tuple corresponding to the first frequency channel, the last frequency
channel and the step size to increment from the first to the last
channel.  The START and STOP part of the tuple can be
\hyperref[Sec:RANGE]{range (section~\ref{Sec:RANGE})} specification for
the range [START, STOP] followed by an optional STEP size.

START and STOP part of the tuple can be specified as a single integer
or physical quantity or as a \hyperref[Sec:RANGE]{range
  (section~\ref{Sec:RANGE})} of integers or physical quantities.  A
single integer is treated as a channel index and the tuple corresponds
to [ID,ID,1].  A single physical quantity is matched with the exact
frequency value of the channels and tuple of matched channel index is
constructed as [ID,ID,1].  A \hyperref[Sec:RANGE]{range
  (section~\ref{Sec:RANGE})} of integers given as N0$\sim$N1 is used
to construct a tuple [N0,N1,1].  Similarly for a range of physical
quantities.

If a START,STOP part of the tuple specification is followed by
"\char94 STEP", the STEP is used as the third value of the tuple.
STEP specification is a single integer or physical quantity.
E.g. 0$\sim$10\char94 2 is converted to a START, STOP, STEP tuple
[0,10,2].

A channel selection expression is a semi-colon separated list of
channel specifications.  E.g.

\begin{itemize}
\item chanspec={\tt 1;2;3} selects channels 1,2 and 3.
\item chanspec={\tt 1$\sim$3} selects channels 1,2 and 3.
\item chanspec={\tt 0$\sim$10\char94 2} selects channels in the range
  [0,10] with a step size of 2
\item chanspec={\tt 1421MHz} selects a frequency channel corresponding to
  the frequency 1421.0 MHz
\item chanspec={\tt 1421$\sim$1500MHz} selects all channels in the range
  [1412.0, 1500.0] MHz
\item chanspec={\tt 1421$\sim$1500MHz\char94 10KHz} selects all channels
  in the range [1421.0, 1500.0] MHz in steps of 10 KHz.
\item chanspec={\tt 1421$\sim$1500MHz\char94 10KHz ; 0$\sim$10\char94 2 ;
  20 ; 30; 40} selects all channels in the range [1421.0, 1500.0] MHz
  in steps of 10KHz, all channels with indexes in the range [0,10] in
  steps of 2 channels and channels 10, 20 and 30.
\end{itemize}

\subsection{ Frequency Selection Syntax}

The specifications for SPW and channels can be combined to form a
fully qualified frequency selection expression of the form
SPWSPEC[:FREQSPEC] (square brackets indicate that :FREQSPEC is
optional).  A frequency selection expression is a comma-separated list
of SPWSPEC[:FREQSPEC] specifications.  Channel selections apply to all
SPWs selected by the SPWSPEC on the left of ':'.  E.g.

\begin{itemize}
\item freq={\tt LBAND:1421$\sim$1500MHz\char94 10KHz ,
  327MHz:300$\sim$400MHz, 0$\sim$4:0$\sim$10\char94 2 , 5:20;30;40}

       selects 

\begin{itemize}
	\item all channels corresponding to channels in the range
          [1421.0, 1500.0] MHz for the SPW named "LBAND", and
	\item all channels corresponding to the range [300.0,
          400.0]MHz for the SPW with a reference frequency of 327.0
          MHz, and
	\item Channels in the range [0,10] in steps of 2 for all SPWs
          with IDs in the range [0,4], and
	\item Channels 20, 30 and 40 for SPW 5
\end{itemize}          

\item freq={\tt 1421Mhz;1422Mhz;1423Mhz :
  0;1;2;10$\sim$20;30$\sim$100$\sim$10 ,0$\sim$3:10$\sim$30}

	 selects

\begin{itemize}
    \item Channels 0, 1, 2 for SPWs with reference frequency of
      1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 10 to 20 in step of 1 channel for SPWs with
      reference frequency of 1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 30 to 100 in steps of 10 channel for SPWs with
      reference frequency of 1421.0, 1422.0 and 1423.0 MHz.
    \item Channels 10 to 30 in step of 1 channel for SPW IDs 0 to 3 in
      step of 1.
\end{itemize}          

\end{itemize}          

Figure~\ref{FIG:SPW} shows an example frequency setup to motivate the
need to separate the full frequency selection expression into SPWSPEC
and FREQSPEC parts.  SPW0 covers the frequency range 1.0--2.0~GHz with
SPW1 overlapping in the range 1.6--1.7~GHz, with a reference frequency
of 1.5~GHz and 1.65~GHz respectively.  With independent specifications
for SPW and channel selection, selection expressions can be
constructed to select channels from SPW0 \underline{\bf or} SPW1 or
from SPW0 \underline{\bf and} SPW1. E.g.
\begin{itemize}
\item freq= {\tt * : 1.6$\sim$1.7GHz} will select all channels from
  SPW0 \underline{\it and} SPW1 that are in the range
\item freq= {\tt 1.5$\sim$1.65GHz : 1.6$\sim$1.7GHz} is the same as
  above (selecting SPWs via reference frequency specification)
\item freq={\tt 1.5GHz : 1.6$\sim$1.7GHz} will select all channels
  from \underline{only} SPW0 that are in the range
\item freq={\tt 0 : 1.6$\sim$1.7GHz} will select all channels
  from \underline{only} SPW0 that are in the range
\item freq={\tt 1.65GHz : 1.6$\sim$1.7GHz} same as above, with SPW1
  selected via integer ID
\item freq={\tt 1 : 1.6$\sim$1.7GHz} same as above, with SPW1
  selected via integer ID

\end{itemize}
\begin{figure}
\centerline{
  \includegraphics[width=10cm]{FreqSettingExample.png}\qquad
}
\caption{Frequency setup with two overlapping SPWs.}
\label{FIG:SPW}

\end{figure}
      
\subsubsection{Notes}

\begin{enumerate}
\item For channel specifications of the type {\tt
  N1$\sim$N2:c0;c1;c2;c3MHz} the list of channel selection is applied
  to all SPWs in the range [N0, N1].  c3 is converted from physical
  units to channel index by using the channel width from SPW N1. Is it
  better to use the min. chan. among the selected SPWs?

\item If channel range is out of bounds, it will be brought within
  bounds per SPW.  If the lower limit of a range is greater than the
  available outer limit, exception is generated.  If the lower limit
  is less than zero, it is set to zero.  If upper limit is greater
  than the available outer limit, it is set to the available outer
  limit.

  If a single channel specification is greater than the available
  outer limit, an exception is thrown.  If it is less than zero, it is
  set to zero.

\item For ranges of physical values, it is assumed that the spectral
  window sub-table's CHAN\_FREQ column has ordered list of channel
  frequencies.
\end{enumerate}

\section{Polarization Selection}

The structure of the Measurement Set allows independent set up for the
frequency and polarization description of the data\footnote{The
  combined main-table descriptor for spectral windows and polarization
  is the Data Description ID (DDID).  DDID represents a two-level
  indirection based on the the Spectral Window and Polarization
  sub-tables (which are the real astrophysically relevant parameters
  of the database).}.  E.g., it is valid to have data at 1420MHz, with
some fraction of the data recorded with only parallel hand
polarizations (e.g. "RR" and "LL") and some fraction of the data
recorded in full polarization mode (e.g. "RR", "LL", "RL", and "LR").
Note however that a polarization set up describes a spectral window
and not the individual frequency channels in a spectral window.

Consequently, polarization selection expressions may need to be
qualified with the spectral window and polarization ID specification
as well.  Therefore, current the polarization selection expressions
are of the type {\tt [SPW:]POL}\footnote{A full specification of the
  type {\tt [[POLID:][SPWID:]POL} or {\tt [DDID::]POL} will be
    implemented in future.}.  The {\tt SPW} part of such expressions
  follow the syntax of the Spectral Window Selection expression (see
  Section~\ref{SPWEXPR}) -- except that the channel specifications are
  not allowed here.

As with other expressions, the polarization selection expression also
consists of comma separated list of full specifications.  The
separator for lists for the individual parts of the specification
(i.e. {\tt SPW}, {\tt POL}, etc.) is semi-colon. However note that if
the optional qualifiers are omitted (i.e., {\tt SPW} etc.), either of
the separators can be used (comma or semi-colon).  Thus {\tt "RR;LL"}
is equivalent to {\tt "RR,LL"}.

The {\tt POL} specification is a semi-colon separated list of
polarization products (i.e., it is a baseline based selection).
E.g. {\tt POL} can be {\tt "RR"} or {\tt "LL"} or {\tt "RR;LR"} or
{\tt "RR;LL;LR;RL"}, etc.  Without the qualifiers, comma can also be
used as a separater.  Polarization specifications in the list can be
in any order.  A number of {\tt [SPW:]POL} specifications can be given
as a comma separated list.  E.g.

\begin{itemize}
\item "poln=RR" will select data corresponding to RR polarization
  product only.
\item "poln=RR,LL,LR,RL" will select all polarization products.
\item "poln=RR ; LL ; LR ; RL" same as the previous expression.
\item "poln=0:RR;LL , 1:LR;RL'' will select RR and LL from spectral
  window 0 and LR and RL from spectral window 1.
\end{itemize}

\section{"Scan intent'' Based Selection}

"Scan intent" selection is based on the entries in the {\tt
  "OBS\_MODE"} column of the {\tt "STATE"} sub-table.  The main table
of a Measurement Set has the {\tt "STATE\_ID"} column containing the
row number of the {\tt "STATE"} sub-table appropriate for each row in
the main table.  The {\tt "OBS\_MODE"} column of the {\tt STATE}
sub-table contains strings describing the observational intent.
These intents are referred to as "scan intents" and the scan-intent
expressions in the \MSS\ module can be used for data selection
based on these intents.

\subsection{Syntax}

The scan-intent selection expression is a comma-separated list of
specifications.  Each specification can be a
\hyperref[Sec:STRINGS]{string (section~\ref{Sec:STRINGS})} , an
integer or an integer \hyperref[Sec:RANGE]{range (section~\ref{Sec:RANGE})}.  As in other such expressions, a range $[N0,N1]$ can
be specified as {\tt N0$\sim$N1} (see Section~\ref{Sec:RANGE}).
\hyperref[Sec:STRINGS]{String (section~\ref{Sec:STRINGS})} can be regular
expressions or patterns or quoted-strings for as-is matching (see
Section~\ref{Sec:STRINGS}).

A single scan can have multiple scan-intents represented by a
comma-separated list of strings like {\tt
  "CALIBRATE\_BANDPASS.UNSPECIFIED,CALIBRATE\_AMPLI.UNSPECIFIED"}.
Each of these comma-separated components are referred to as the
scan-intent components.  All string specifications in scan-intent
expression are matched against {\it each} of these comma-separated
components.  Scans with {\it any} of the scan-intent components
matching the string(s) in the scan-intent expression are selected.
E.g. {\tt scanintent=*CAL*, *BAND*} will select all scans which have
the strings {\tt "CAL"} or {\tt "BAND"}.

To allow selection based on scan-intent components, scan-intent
selection specifications can also be ampersand-separated ({\tt '\&'})
list strings.  Only those scans, at least one scan-intent components
of which match {\it all} the ampersand-separated components are
selected.  E.g. {\tt scanintent=*CAL* \& *BAND*} will select only
those scans the intent strings of which contain the strings {\tt
  "CAL"} {\it and} {\tt "BAND"}.  See
Section~\ref{Sec:SCANINTENTEXAMPLES} for more examples.

\subsection{Examples}
\label{Sec:SCANINTENTEXAMPLES}
Table~\ref{Tab:SCANINTENT} shows an example-table of scan-intents.
Table~\ref{Tab:SCANINTENTEXPR} shows a list of some scan-intent
selection expressions and the corresponding list of selected scan
numbers from Table~\ref{Tab:SCANINTENT}.

\begin{table}[ht!]
\caption{Example scan-intent table}
\begin{center}
\begin{tabular}{|c|l|}
\hline
\small {Scan No.} & \small{Scan-intent strings}\\
\hline
   0    &  \small{\tt CALIBRATE\_BANDPASS, CALIBRATE\_PHASE}\\
   1    &  \small{\tt CALIBRATE\_BANDPASS, CALIBRATE\_AMPLI}\\
   2    &  \small{\tt CALIBRATE\_BANDPASS, CALIBRATE\_AMPLI, CALIBRATE\_PHASE}\\
   3    &  \small{\tt AMPLI\_UNSPECIFIED, PHASE\_UNSPECIFIED}\\
\hline
\end{tabular}
\end{center}
\label{Tab:SCANINTENT}
\end{table}
\begin{table}[h!]
\caption{Examples of scan-intent selection expressions for intents
shown in Table~\ref{Tab:SCANINTENT}}
\begin{center}
% This LaTeX table template is generated by emacs 23.2.1
\begin{tabular}{|l|l|l|}
\hline
{\bf Scan-intent}& {\bf Selected}& {\bf Remarks}\\
{\bf selection expression}&{\bf scans}& \\
\hline
\hline
{\small \tt CALI*}   & 0,1,2 & \\
\hline
{\small \tt *PHASE}   & 0,2   & Matches {\small \tt CALIBRATE\_PHASE} but \\
                      &       & not {\small \tt PHASE\_UNSPECIFIED} \\
\hline
{\small \tt *UNSPEC*} & 3     & \\
\hline
{\small \tt *AMPLI, *PHASE} & 1,2 & {\small \tt *AMPLI} matches {\small \tt CALIBRATE\_AMPLI}; \\
                            &     & {\small \tt *PHASE} matches {\small \tt CALIBRATE\_PHASE} \\
\hline
{\small \tt *AMP*} & 1,2,3 & {\small \tt *AMP*} matches {\small \tt CALIBRATE\_AMPLI} and \\
                   &       & {\small \tt AMPLI\_UNSPECIFIED} \\
\hline
{\small \tt *BAND \& *PHASE} & 0,2 & {\small \tt *BAND} and {\small \tt *PHASE} are  simultaneous present \\
                             &     & for scans 0 and 2 only \\
\hline
{\small \tt AMP* \& *PHASE*} & 3 & {\small \tt *PHASE*} matches scans 0,2,3. {\small \tt AMP*} matches \\
                             &   & only scan 3. \\
\hline
{\small \tt *BAND \& *PHASE* \& *AMP*} & 2 & Only scan that matches {\small \tt *BAND} {\it and} \\
                                       &   & {\small \tt *PHASE*} {\it and} {\small \tt *AMP*} is scan 2 \\
\hline
{\small \tt *BAND \& *PHASE*, AMPLI*} & 0,2,3 & {\small \tt *BAND \& *PHASE} selects scans 0,2. \\
                                      &       & {\small \tt AMPLI*} selects scan 3 \\
\hline
\end{tabular}
\end{center}
\label{Tab:SCANINTENTEXPR}
\end{table}

\section{Scan/Sub-array Selection}

Scan and sub-arrays selections are purely integer ID based selections.
The syntax for the specification of both these is therefore identical.

\subsection{Syntax}

Scan and Sub-array selection specification is a single integer (INT)
or a \hyperref[Sec:RANGE]{range (section~\ref{Sec:RANGE})} of
integers(N0$\sim$N1).  Scans and sub-arrays can also be selected via
boolean expressions of the type "$>$INT", "$>$=INT", "$<$INT" or
"$<$=INT"\footnote{{\it Programmers note:} The getScanList()
  (getSubArrayList() for sub-arrays) method will return the list
  generated from INT,INT,... or INT$\sim$INT or "$<$INT"
  specification.  For "$>$INT" specification, the returned list will
  be number from INT part of "$>$INT" up to the maxScans (maxArrays for
  sub-arrays) set via MSSelection::setMaxScan()
  (MSSelection::setMaxArray() for sub-arrays).  The default value of
  maxScans/maxArrays is {\tt std::standard\_limits$<$int$>$::max()}
  (i.e. the maximum value an integer can take on a machine).  It is
  done this way since there is no efficient way of generating a list
  of SCAN/ARRAY IDs present in the data and "$>$INT" is an unbounded
  list of integers.  The list of scans IDs in the data can be {\bf
    probably} generated using the MSRange class - but I think it can
  be quite expensive.  So if it is necessary to know the precise list
  of scans selected using the "$>$INT" specification, the application
  programs will have to use MSRange class to get the range in the
  data.  An intersection of the list from MSRange and the list from
  MSSelection.getScanList() will be the actual selected scans
  (intersection of two CASA vectors can be done using the
  set\_intersection() global method in MSSelectionTools.h).  }.

Full expression is a comma-separated list of any of the above index
specifications.  E.g.

\begin{itemize}
\item scan={\tt 0,1,2,3}  selects scan numbers 0, 1, 2 and 3
\item scan={\tt 0$\sim$3}      selects scans in the range [0,3]
\item scan={\tt 0$\sim$3,4,5}  selects scans in the range [0,3] and scans 4 and 5 
\item scan={\tt $>$5}       selects all scans greater than 5
\item scan={\tt $<$5}       selects all scans less than 5
\end{itemize}

\section{Using \MSS\ expressions in TaQL}
The \MSS\ module can be thought of as a compiler which compiles
expressions written in MSSelection syntax into TaQL code.  The module
therefore can also be supplied pure-TaQL expressions which are used
as-is along with any of the \MSS\ expressions. Internally, the
pure-TaQL expression will be treated as just another \MSS\ expression.

While it is natual to be able to use TaQL expressions via the \MSS\
module for selection on an MS, it is also possible to embed \MSS\
expressions in TaQL expressions via the {\tt MSCal} user-defined
functions (UDF).  E.g. in a TaQL expression like the following
\begin{verbatim}
 select from MS where mscal.baseline('sel1') || mscal.baseline('sel2') 
\end{verbatim}
{\tt sel1} and {\tt sel2} can be \MSS\ 
\hyperref[Sec:BASELINE]{baseline (section~\ref{Sec:BASELINE})}.  Other types of
selection are also similarly possible (e.g. selection on Time,
Frequency, Scan, etc.) via TaQL.

\newpage
\appendix{}
\section{Appendix: API Note - General Error Handling}

The \MSS\ sub-system reports errors via the C++ exception mechanism.
\MSSelectionError\ is the base class of the objects used to report
exceptions.  The class diagram for the objects thrown is shown in
Fig.~\ref{FIG:MSSERROR}.

\begin{figure}[hb!]
\centerline{
  \includegraphics[width=15cm]{MSSError.png}\qquad
}

\caption{Class diagram for the objects used for error reporting via
  C++ exceptions in the MSSelection module.}
\label{FIG:MSSERROR}
\end{figure}

% \begin{center}
% \begin{verbatim}
%                              AipsError
%                                  o
%                                  |
%                                  |
%                           MSSelectionError
%                                  o
%                                  |
%                                  |
%   MSSelection{Time,Spw,UvDist,Antenna,Scan,Subarray,Poln,State}Error
%                                  o
%                                  |
%                                  |
% MSSelection{Time,Spw,UvDist,Antenna,Scan,Subarray,Poln,State}ParseError
% \end{verbatim}
% \end{center}

All parsing errors are reported by throwing the {\tt
  MSSelection\{Time, Spw, Field, UvDist, Antenna, Scan,
  Subarray,Poln,State\}ParseError} exception.  All other forms of
errors (e.g. illegal \hyperref[Sec:RANGE]{range
  (section~\ref{Sec:RANGE})} specification N0$\sim$N1 where N0 $>$ N1)
are reported by throwing an exception of type {\tt MSSelection\{Time,
  Spw, Field, UvDist, Antenna, Scan, Subarray,Poln,State\}Error}.

Hence, to catch all errors thrown from the \MSS\ sub-system,
catch the {\tt MSSelectionError} object.  For more specific exception
handling, catch the more qualified MSSelection*Error objects.  For
catching only parsing errors, catch the MSSelection*ParseError object.
As is obvious, any un-caught exception from the \MSS\ sub-system
will be caught in the AipsError catch block.

The exceptional error message consists of a human understandable
one-line description of the error, the string which caused the error
and the possible location in the string of the erroneous
character.  E.g.
\begin{verbatim}
 Spw Expression: No match found for "LBAN" (near char. 4 in string "LBAN")
\end{verbatim}

\subsection{Installing Error Handlers}

The normal (default) behavior of the parsers is to throw an exception
when an error is encountered during parsing cycle or in the
rule-resolution code.  However there are cases where instead of
throwing an exception, the errors must be collected as they occur and
resolution of the error done at the end of the parsing cycle.  In the
\MSS\ module, this is achieved by installing an error handler object
of type \MSSelectionErrorHandler (the base-class) in the
instance of the \MSS\ object.  This is the object that is used
internally to handle errors in the \MSS\ module.  The default error
handler that comes pre-installed simply throws an exception of the
appropriate kind when an error is encountered, recreating the normal
behaviour of the C++ exception handling mechanism.

To collect errors (and the error messages generated in the process) as
they occur for later resolution, the client-side code can install a
specialization of the error handler of type {\tt MSSelectionLogError},
a derivative of the {\tt MSSelectionErrorHandler}, using the {\tt
  MSSelection::setErrorHandler()} method, as shown in the
Listing~\ref{FIG:EHCODE}.
\begin{lstlisting}[frame=single, backgroundcolor=\color{light-gray},
  basicstyle=\footnotesize\ttfamily, language=C, numbers=left,
  numberstyle=\tiny\color{black},caption= {Code snippet showing use of
    external error handlers.},label=FIG:EHCODE]
      MS ms(MSNBuf,TableLock(TableLock::AutoNoReadLocking));
      //
      // Setup the MSSelection thingi
      //
      MSSelection msSelection;
      MSSelectionLogError mssLE;
      msSelection.setErrorHandler(MSSelection::ANTENNA_EXPR,&mssLE);
      msSelection.reset(ms,MSSelection::PARSE_NOW,
                        timeStr,baselineStr,fieldStr,spwStr,
                        uvdistStr,taqlStr,polnStr,scanStr,arrayStr,
                        stateObsModeStr,observationStr);
\end{lstlisting}
At the appropriate place in the client code, a call to {\tt
  MSSelectionErrorHandler::reportError()} can be made to display the
collected error messages as warning messages. This behavior can be
changed in a specialization of the {\tt MSSelectionErrorHandler} class
by overloading the {\tt reportError} method.

This mechanism of error handling is currently available for ANTENNA
and STATE (a.k.a. ``intent selection'') selection expressions only.

\newpage
\section{Appendix: API Note - Using the {\tt MSSelection} module for other
  MS-like Tables}

The \MSS\ module was originally written to provide a higher-level,
simpler language called STaQL (Simpler TaQL) specifically for applying
selection on Measurement Sets.  Parsers in the MSSelection module
compile the various STaQL expressions and emit the equivalent tree of
Table Expression Nodes (TEN), which is then used by the {\tt
  MeasurementSet} class to generate a selected Table containing rows
from the original Table for which the supplied TEN evaluates to True.

The information required to compile the STaQL expressions is derived
from various sub-tables of the Measurement Set format (e.g. the {\tt
  ANTENNA} sub-table, {\tt SPECTRAL\_WINDOW} sub-table, etc.).  Since
the {\tt MeasurementSet} class is a specialization of the {\tt Table}
class and uses the services of the {\tt Table} class to do the
selection, in principle, STaQL can be used for any database that
follows the general Table structure of the Measurement Set format.  We
refer to classes/objects which provide such a view of the
underlying data as MS-like objects/classes.  To use the \MSS\ module
for selection, the basic requirement is that the MS-like formats be
organized as pseudo-relational database (like the Measurement Set)
where {\it most} of the main-table entries are references to the rows
of sub-tables.  The information that these main-table entries
represent resides in these much smaller sub-tables.

Since there may be minor differences in the details of the target
databases (e.g. names of the sub-tables, or even absence of some
required sub-tables which can be generated on-the-fly), the
\MSS\ module provides an interface to the database via a translation
class inherited from the pure-virtual base-class of type
\MSSelectableTable.  The {\tt MSSelectableTable} class provides a
uniform interface for the \MSS\ class(es) and does any required
translation to interface with the database classes.  This also allows
the client database related classes to exist outside the CASACore
package.  The inheritance tree of the {\tt MSSelectableTable} line of
classes is shown in Fig.~\ref{FIG:MSSTABS}.
\begin{figure}[hb!]
\centerline{
  \includegraphics[width=8cm]{MSSelectableTable.png}\qquad
}

\caption{Class diagram of the implementations of the {\tt
    MSSelectableTable} pure-virtual base-class.}
\label{FIG:MSSTABS}
\end{figure}

For using the \MSS\ module on the Measurement Sets, the {\tt
  MSInterface} object can be constructed from the {\tt MeasurementSet}
object and passed to the \MSS\ object as shown in
Listing~\ref{LIST:MSCODE}.
\begin{lstlisting}[frame=single, backgroundcolor=\color{light-gray},
  basicstyle=\footnotesize\ttfamily, language=C, numbers=left,
  numberstyle=\tiny\color{black},caption= {Code snippet showing usage
    of \MSS\ for Measurement Sets.},label=LIST:MSCODE]
      MS ms(MSName,TableLock(TableLock::AutoNoReadLocking));
      //
      // Setup the MSSelection thingi
      //
      MSInterface msLike(ms);
      MSSelection msSelection;
      MSSelectionLogError mssLE;
      msSelection.setErrorHandler(MSSelection::ANTENNA_EXPR,&mssLE);
      msSelection.reset(msLike,MSSelection::PARSE_NOW,
                        timeStr,baselineStr,fieldStr,spwStr,
                        uvdistStr,taqlStr,polnStr,scanStr,arrayStr,
                        stateObsModeStr,observationStr);
\end{lstlisting}
Another method of using the \MSS\ class is to set the individual
expressions, get the TEN via the {\tt MSSelection::toTableExprNode()}
method and finally use the global method {\tt getSelectedTable()} to
apply the selection.  This style of usage is shown in
Listing~\ref{LIST:CTCODE}.  While for Measurement Sets the {\tt
  MSSelection::reset()} method also works with {\tt MeasurementSet}
object, for future compatibility reasons it is recommended that the
{\tt MSInterface} be used instead.

\subsection{Using \MSS\ for {\tt CalTables}}

The \MSS\ module can be used for selection on \CalTables\ , which are
implemented in the synthesis module of the CASA package, via the
interface object of type {\tt CTInterface}.

To use the \MSS\ module for selection on {\tt (New)CalTable} object,
the only difference from the code snippet above, is that a {\tt
  CTInterface} object needs to be constructed (instead of the {\tt
  MSInterface} object) from the {\tt (New)CalTable} class of the
synthesis module.  The {\tt CTInterface} object can be supplied to the
\MSS\ object via the {\tt reset()} method.  Alternatively, various
expressions can be set in the \MSS\ object and the {\tt CTInterface}
object supplied via the {\tt MSSelection::toTableExprNode()} method
which returns the tree of TENs.  The tree can then be used to get a
selected CalTable as shown in Listing~\ref{LIST:CTCODE}.
\begin{lstlisting}[frame=single, backgroundcolor=\color{light-gray}, basicstyle=\footnotesize\ttfamily, language=C, numbers=left, numberstyle=\tiny\color{black},caption= {Code snippet showing usage of \MSS\ for (New)CalTables.},label=LIST:CTCODE]
  NewCalTable calTab(CalName), selectedCalTable(calTab); 
  CTInterface msLike(calTab); 
  MSSelection mss; 
  MSSelectionLogError mssLE;
  mss.setErrorHandler(MSSelection::ANTENNA_EXPR,&mssLE);

  mss.setFieldExpr(fieldStr);
  mss.setAntennaExpr(antennaStr);
  mss.setSpwExpr(spwStr);

  TableExprNode ten=mss.toTableExprNode(&msLike);
  //
  // Now use the global method getSelectedTable() to apply the TEN on the calTab 
  // parameter and return the selected table in selectedCalTable parameter.
  //
  getSelectedTable(selectedCalTable, calTab, ten, "");
\end{lstlisting}
\newpage
\section{Appendix: Usage Examples}

\begin{table}[h!]
\caption{Summary of the MS used}
\begin{center}
\begin{tabular}{|c|c|c|c|l|c|}
\hline
FIELDID & SPWID &  NChan & Pol & NRows   & Source Name\\
\hline
   0    &  0    &   127  &  RR &  10260  &  0530+135  \\
   1    &  0    &   127  &  RR &  779139 &  05582+16320  \\
   2    &  0    &   127  &  RR &  296190 &  05309+13319  \\
   3    &  0    &   127  &  RR &  58266  &  0319+415      \\
   4    &  0    &   127  &  RR &  32994  &  1331+305      \\
   5    &  1,2  &    1   &  RR,RL,LL,RR  &  23166&  KTIP  \\
\hline
\end{tabular}
\end{center}
\end{table}

\subsection{Example 1}
\begin{verbatim}
--------------------------------------------------------------------
Select field IDs 0,1,2 and field Named KTIP
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas named "1" to "10"
       Spw:  0  Channels: 10 to 30 in steps of 1
--------------------------------------------------------------------
sbhatnag@atlas>mssplit
mssplit>inp
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = 0~2,KTIP
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 0:10~30
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [0, 1, 2, 5]
SPW  = [0]
Chan = [10, 30, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 99819
\end{verbatim}

\subsection{Example 2}

\begin{verbatim}
--------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas named "1" to "10"
       Spw:  All available channels for spw 1 and 2
--------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1,2
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [1, 2]
Chan = SPW 1 : Channels [0, 0, 1]
       SPW 2 : Channels [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 2376
\end{verbatim}

\subsection{Example 3}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas *named* "1" to "10"
       Spw:  SPW ID 0

       No data should be selected
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 0
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [0]
Chan = SPW 0 : Channel [0, 126, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 0
\end{verbatim}

\subsection{Example 4}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: All baselines between antennas *named* "1" to "10"
       Spw:  SPW ID 1
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~10&
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Ant2 = [21, 10, 17, 4, 24, 3, 11, 0, 23, 6]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channels [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 1188
\end{verbatim}


\subsection{Example 5}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Between antennas "1" to "3" and "4" to "6"
       Spw:  SPW ID 1
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1,2,3&4,5,6
scan       =
array      =
uvdist     =
mssplit>go
Ant1 = [21, 10, 17]
Ant2 = [4, 24, 3]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = Axis Lengths: [2, 0] []
UV in meters = []
Number selected rows: 198
\end{verbatim}

\subsection{Example 6}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Error in antenna specification
       Spw:  All spectral windows
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & $~6
uvdist     =
mssplit>go
###AipsError: Antenna Expression: Parse error at or near '$' (near
char. 7 in string "1~3 & $~6")
\end{verbatim}

\subsection{Example 7}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Use antenna ranges
       Spw:  1
       UVRange: [0,5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
Ant1 = [21, 10, 17]
Ant2 = [4, 24, 3]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = [0, 5000] lambda
Number selected rows: 33
\end{verbatim}

\subsection{Example 8}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: 25/22:40:0 to 26/03:30:0
       Baselines: Baselines between antennas "1" to "3" and "4" to "6"
                  and baseline "10"-"11"
       Spw:  1
       UVRange: [0, 5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = ~/Data/CASATest/G192/g192_a.ms
outms      = tt.ms
field      = K*
time       = 25/22:40:0 ~ 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6 ; 10&11
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
Ant1 = [21, 10, 17, 6]
Ant2 = [4, 24, 3, 1]
Field= [5]
SPW  = [1]
Chan = SPW 1 : Channel [0, 0, 1]
Scan = []
Array = []
UVRange = [0, 5000] lambda
Number selected rows: 33
\end{verbatim}

\subsection{Example 9}
\begin{verbatim}
-------------------------------------------------------------------
Select field Named K* (wild card usage)
       Time range: Error in range operator
       Baselines: Baselines between antennas "1" to "3" and "4" to "6"
       Spw:  All spectral windows
       UVRange: [0, 5000] K-Lambda
-------------------------------------------------------------------
sbhatnag@atlas>mssplit
ms         = /home/rohir3/sanjay/CASATests/G192.ms/
outms      = tt.ms
field      = K*
time       = 25/22:40:0 - 26/03:30:0
spw        = 1
baseline   = 1~3 & 4~6 ; 10&11
scan       =
array      =
uvdist     = 0~5klambda
mssplit>go
First selected timestamp = 26-Apr-2003/03:20:45.0
###MSSelectionError: MSSelection time error: Parse error at or near
token '-' (near char. 12 in string "25/22:40:0 - 26/03:30:0")
(Did you know we use "~" as the range operator (for a good reason)?)
\end{verbatim}

% \newpage
% \section{Appendix: Formal Grammar Specifications}

% {\tt TEN} in the following refers to the TableExprNode object of the
% {\tt Tables} module of CASA.

% \subsection{Baseline Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   char* str;
%   double dval;
%   Vector<Int>* iv;
%   std::vector<double>* dv;
%   Vector<String>* is;
% }

% %token AT
% %token COMMA
% %token SEMICOLON
% %token AMPERSAND
% %token DASH
% %token NOT
% %token LPAREN
% %token RPAREN
% %token LT
% %token LE
% %token GT
% %token GE

% %token <str> INT
% %token <str> FLOAT
% %token <str> UNIT
% %token <str> QSTRING
% %token <str> REGEX
% %token <str> IDENTIFIER

% %type <node> antennastatement 
% %type <node> indexcombexpr    
% %type <node> baseline         
% %type <node> gbaseline        
% %type <str> identstr          
% %type <dval> flt              
% %type <dval> flint            
% %type <dval> unit             
% %type <dval> flintunit        
% %type <dval> flunit           
% %type <iv> antlist            
% %type <iv> antidrange
% %type <iv> antids
% %type <iv> antid
% %type <iv> stationid
% %type <iv> stationlist
% %type <iv> antatstation
% //%type <iv> antatstationlist
% %type <iv> antcomp
% %type <iv> stancomp
% %type <dv> blength
% %type <dv> blengthlist

%     0 $accept: antennastatement $end

%     1 antennastatement: indexcombexpr

%     2 indexcombexpr: gbaseline
%     3              | indexcombexpr SEMICOLON gbaseline

%     4 @1: /* empty */

%     5 gbaseline: NOT @1 baseline

%     6 @2: /* empty */

%     7 gbaseline: @2 baseline

%     8 baseline: antlist AMPERSAND antlist
%     9         | antlist AMPERSAND
%    10         | antlist
%    11         | antlist AMPERSAND AMPERSAND antlist
%    12         | antlist AMPERSAND AMPERSAND
%    13         | antlist AMPERSAND AMPERSAND AMPERSAND
%    14         | blengthlist

%    15 identstr: IDENTIFIER
%    16         | UNIT

%    17 stationid: IDENTIFIER
%    18          | QSTRING
%    19          | REGEX

%    20 antid: identstr
%    21      | QSTRING
%    22      | REGEX

%    23 antidrange: INT
%    24           | INT DASH INT

%    25 stationlist: stationid
%    26            | stationlist COMMA stationid

%    27 antlist: antids
%    28        | antlist COMMA antids

%    29 antcomp: antid
%    30        | antidrange
%    31        | LPAREN antlist RPAREN

%    32 stancomp: stationid
%    33         | LPAREN stationlist RPAREN

%    34 antatstation: antcomp AT stancomp
%    35             | AT stancomp

%    36 antids: antid
%    37       | antidrange
%    38       | antatstation

%    39 blengthlist: blength
%    40            | blengthlist COMMA blength

%    41 blength: LT flunit
%    42        | LE flunit
%    43        | GT flunit
%    44        | GE flunit
%    45        | flt DASH flt
%    46        | flt DASH flt unit
%    47        | flintunit DASH flintunit

%    48 flunit: flint
%    49       | flintunit

%    50 flintunit: flint unit

%    51 unit: UNIT

%    52 flint: flt
%    53      | INT

%    54 flt: FLOAT
% \end{verbatim}


% \subsection{Frequency Selection Expression}

% \begin{verbatim}

% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   Float fval2[2], fval4[4],fval;
%   char * str;
%   Int ival;
%   Vector<Float>* fv;
%   Vector<Int>* iv;
% }


% %token SQUOTE
% %token <str> IDENTIFIER
% %token COMMA

% %token LPAREN
% %token RPAREN
% %token WHITE
% %token COLON
% %token CARET
% %token SEMICOLON

% %token <str> UNIT
% %token <str> INT
% %token <str> FNUMBER
% %token <str> QSTRING
% %token <str> REGEX

% %type <node> SpwStatement
% %type <node> FullSpec
% %type <node> FullExpr
% %type <fval2> OneFreq
% %type <fval4> FreqRange
% %type <fval2> Physical
% %type <fval4> IndexRange
% %type <fval4> PhyRange
% %type <iv>    Spw
% %type <fval4> FListElements
% %type <fv>   FreqList
% %type <fval> PhyVal
% %type <fval2> UnitCode

% %nonassoc GT GE LT LE NE COMMA DASH AMPERSAND SEMICOLON COLON CARET
% %right TILDA

%     0 $accept: SpwStatement $end

%     1 SpwStatement: FullExpr
%     2             | LPAREN FullExpr RPAREN

%     3 PhyVal: FNUMBER

%     4 UnitCode: UNIT

%     5 Physical: PhyVal UnitCode

%     6 PhyRange: Physical DASH Physical
%     7         | PhyVal DASH PhyVal UnitCode
%     8         | PhyRange CARET Physical
%     9         | CARET Physical

%    10 IndexRange: PhyVal DASH PhyVal
%    11           | IndexRange CARET PhyVal
%    12           | CARET PhyVal

%    13 FreqRange: IndexRange
%    14          | PhyRange

%    15 OneFreq: PhyVal
%    16        | Physical

%    17 FListElements: FreqRange
%    18              | OneFreq

%    19 FreqList: FListElements
%    20         | FreqList SEMICOLON FListElements

%    21 Spw: IDENTIFIER
%    22    | QSTRING
%    23    | REGEX
%    24    | GT OneFreq
%    25    | LT OneFreq
%    26    | DASH OneFreq
%    27    | FreqList

%    28 FullSpec: Spw
%    29         | Spw COLON FreqList

%    30 FullExpr: FullSpec
%    31         | FullExpr COMMA FullSpec
% \end{verbatim}


% \subsection{Field Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   Int ival[2];
%   char * str;
%   Double dval;
%   Vector<Int>* iv;
%   Vector<String>* is;
% }


% %token EQASS
% %token SQUOTE
% %token <str> IDENTIFIER
% %token COMMA

% %token LBRACKET
% %token LPAREN
% %token RBRACKET
% %token RPAREN
% %token LBRACE
% %token RBRACE
% %token WHITE

% %token <str> INT
% %token <str> QSTRING
% %token <str> REGEX

% %token COLON
% %token SEMICOLON

% %type <node> fieldstatement
% %type <node> indexcombexpr
% %type <iv> indexlist
% %type <iv> fieldidrange
% %type <iv> fieldidlist
% %type <iv> fieldid
% %type <iv> fieldidbounds

% %nonassoc EQ EQASS GT GE LT LE NE COMMA DASH AMPERSAND

%     0 $accept: fieldstatement $end

%     1 fieldstatement: indexcombexpr
%     2               | LPAREN indexcombexpr RPAREN

%     3 indexcombexpr: indexlist

%     4 fieldid: IDENTIFIER
%     5        | QSTRING
%     6        | REGEX

%     7 fieldidrange: INT
%     8             | INT DASH INT

%     9 fieldidbounds: LT INT
%    10              | GT INT
%    11              | GT INT AMPERSAND LT INT

%    12 fieldidlist: fieldid
%    13            | fieldidrange
%    14            | fieldidbounds

%    15 indexlist: fieldidlist
%    16          | indexlist COMMA fieldidlist
% \end{verbatim}


% \subsection{Scan/Sub-Array Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   Int ival[2];
%   char * str;
%   Double dval;
%   std::vector<Int>* iv; // std::vectors have push_back, insert, etc.
%   Vector<String>* is;
% }


% %token EQASS
% %token SQUOTE
% %token <str> IDENTIFIER
% %token COMMA

% %token LBRACKET
% %token LPAREN
% %token RBRACKET
% %token RPAREN
% %token LBRACE
% %token RBRACE
% %token WHITE

% %token <str> INT
% %token <str> QSTRING
% %token <str> REGEX

% %token COLON
% %token SEMICOLON

% %type <node> scanstatement
% %type <node> compoundexpr
% %type <node> scanboundsexpr
% %type <node> scanidbounds
% %type <iv> scanids

% %nonassoc EQ EQASS GT GE LT LE NE COMMA DASH AMPERSAND

%     0 $accept: scanstatement $end

%     1 scanstatement: compoundexpr

%     2 compoundexpr: scanids
%     3             | scanboundsexpr
%     4             | compoundexpr COMMA scanids
%     5             | compoundexpr COMMA scanboundsexpr

%     6 scanidbounds: LT INT
%     7             | GT INT
%     8             | LE INT
%     9             | GE INT
%    10             | GE INT AMPERSAND LE INT
%    11             | GT INT AMPERSAND LT INT

%    12 scanboundsexpr: scanidbounds

%    13 scanids: INT
%    14        | INT DASH INT
% \end{verbatim}


% \subsection{Time Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   Block<TableExprNode>* exprb;
%   TableExprNodeSetElem* elem;
%   TableExprNodeSet* settp;
%   const MEpoch* tval;
%   Int ival;
%   Double dval;
%   Double dval3[3];
%   Int ival3[3];
%   TimeFields timeFields;
% }

% %token <ival> NUMBER
% %token <dval> FNUMBER
% %token SQUOTE

% %token DASH
% %token LT
% %token GT
% %token COLON
% %token COMMA
% %token SLASH
% %token DOT
% %token PERCENT
% %token STAR

% %token UNKNOWN

% %type <node> timestatement
% %type <node> timeexpr
% %type <node> singletimeexpr
% %type <node> rangetimeexpr
% %type <node> upboundtimeexpr
% %type <node> lowboundtimeexpr
% %type <timeFields> yeartimeexpr
% %type <dval> wildFloat
% %type <ival> wildNumber
% %type <ival> tFields
% %type <dval3> timeObj
% %type <ival> yFields
% %type <ival3> yearObj

% %left OR
% %left AND
% %nonassoc GT LT LE COLON SLASH
% %left PLUS MINUS
% %left TIMES DIVIDE MODULO
% %nonassoc UNARY
% %nonassoc NOT
% %right POWER

%     0 $accept: timestatement $end

%     1 timestatement: timeexpr
%     2              | timestatement COMMA timeexpr

%     3 timeexpr: singletimeexpr
%     4         | rangetimeexpr
%     5         | lowboundtimeexpr
%     6         | upboundtimeexpr

%     7 wildNumber: STAR
%     8           | NUMBER

%     9 wildFloat: wildNumber
%    10          | FNUMBER

%    11 singletimeexpr: yeartimeexpr

%    12 rangetimeexpr: yeartimeexpr DASH yeartimeexpr
%    13              | yeartimeexpr PLUS yeartimeexpr

%    14 lowboundtimeexpr: GT yeartimeexpr

%    15 upboundtimeexpr: LT yeartimeexpr

%    16 tFields: wildNumber COLON
%    17        | COLON

%    18 yFields: wildNumber SLASH
%    19        | SLASH

%    20 timeObj: tFields tFields wildFloat
%    21        | tFields tFields
%    22        | tFields wildFloat
%    23        | tFields
%    24        | wildNumber

%    25 yearObj: yFields yFields wildNumber
%    26        | yFields yFields

%    27 yeartimeexpr: yearObj SLASH timeObj
%    28             | yearObj
%    29             | timeObj
% \end{verbatim}

% \subsection{UV-distance Selection Expression}

% \begin{verbatim}
% %union {
%   const TableExprNode* node;
%   char * str;
%   Double dval;
% }

% %token <str> UNIT
% %token <dval> FNUMBER
% %token COLON
% %token COMMA
% %token PERCENT

% %type <dval> fnumwithunits
% %type <node> uvwdiststatement
% %type <node> uvwdistexprlist
% %type <node> uvwdistexpr
% %left UNIT
% %right PERCENT
% %nonassoc EQ EQASS GT GE LT LE NE DASH COLON 

%     0 $accept: uvwdiststatement $end

%     1 uvwdiststatement: uvwdistexprlist

%     2 uvwdistexprlist: uvwdistexpr
%     3                | uvwdistexprlist COMMA uvwdistexpr

%     4 fnumwithunits: FNUMBER
%     5              | FNUMBER UNIT

%     6 uvwdistexpr: fnumwithunits
%     7            | FNUMBER DASH fnumwithunits
%     8            | LT fnumwithunits
%     9            | GT fnumwithunits
%    10            | fnumwithunits COLON FNUMBER PERCENT
% \end{verbatim}

\end{document}

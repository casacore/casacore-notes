
%%\externallabels{../../user/Refman}{../../user/Refman/labels.pl}

\section{Introduction}
The Table Query Language (TaQL, rhymes with bagel (though many people
pronounce it as tackle)) makes it possible to select
rows from an arbitrary table based on the contents of its
columns and keywords. It supports arbitrary complex
expressions including units, extended regular expressions, and many
functions. User defined functions written in C++ are also supported.
TaQL also makes sorting and column selection possible.
Furthermore TaQL has commands to create a table and to modify data
in a table.

TaQL is modeled after SQL and contains most of SQL's
functionality. Some familiarity with SQL makes it easier to understand
the TaQL syntax.
The most important features of TaQL different from SQL are:
\begin{itemize}
\item The result of a SELECT is not ASCII output. Instead it always
creates another table (either temporary or persistent). Usually this
is a so-called reference table, but it is also possible to make a deep
copy and create a plain table.
\\A reference table is a table that can be used as any other table,
but it does not contain data. Instead it contains references to the
rows and columns in the original table. Thus modifying data in a
reference table means that effectively the data in the original
table are modified.
\item Any operand can be a scalar or an N-dimensional array.
Many reduction functions can be applied to arrays.
\item A very rich set of mathematical functions.
\item Full support of units and automatic conversion of units.
\item Support of various types of patterns/regular expressions and
maximum string distances (Levensthein or Edit distance).
\item Specific operators and functions for cone searching
(i.e. spatial searching with a search radius).
\item An advanced way of specifying intervals.
\item No support of indices, thus always a linear search is done.
Because data are stored column-wise, a linear search is usually very
 fast, even for very large tables.
\item Joins are not supported yet.
\item In the SELECT command GROUPBY and HAVING are not supported yet.
\item The COUNT command exists to count the ocurrences of column values.
\item The CALC command exists to
calculate an arbitrary expression (including subqueries) on a
table. This can be useful to derive values from a table (e.g. the
number of flags set in a measurement set). It can even be used as a
desk calculator.
\item TaQL can be used from languages with different conventions, for
example the order of array axes. Therefore it is possible to set the
language style to be used.
\end{itemize}
TaQL has a keyword that makes it possible to time the various parts of
a TaQL command.

The first sections of this document explain the syntax and show the options.
The last sections show the interface to TaQL using Python or C++.
The Python interface makes it possible to embed Python
variables and expressions in a TaQL command.

\section{TaQL Commands}
\subsection{Command summary}
TaQL contains six commands.
In the commands shown below the square brackets are not part of the
syntax, but indicate the optional parts of the commands.

\begin{itemize}
\item selection
\begin{verbatim}
  SELECT [[DISTINCT] column_list] [INTO table [AS type]]
    FROM table_list [WHERE expression]
    [ORDERBY [DISTINCT] sort_list]
    [LIMIT expression] [OFFSET expression]
    [GIVING table [AS type] | set]
\end{verbatim}
It can be used to get an optionally sorted subset from a table. It can
also be used to do a subquery (see \htmlref{section 4.11}{TAQL:SUBQUERIES} 
for more information on subqueries).

\item updating
\begin{verbatim}
  UPDATE table_list SET update_list [FROM table_list]
    [WHERE ...] [ORDERBY ...] [LIMIT ...] [OFFSET ...]
\end{verbatim}
It can be used to update data in (a subset of) the first table in the
table list. 

\item addition
\begin{verbatim}
  INSERT INTO table_list [(column_list)] VALUES (expr_list)
or
  INSERT INTO table_list [(column_list)] SELECT_command
\end{verbatim}
It can be used to add and fill new rows in the first table in the
table list.

\item deletion
\begin{verbatim}
  DELETE FROM table_list
    [WHERE ...] [ORDERBY ...] [LIMIT ...] [OFFSET ...]
\end{verbatim}
It can be used to delete some or all rows from the first table
in the table list.

\item counting
\begin{verbatim}
  COUNT [column_list] FROM table_list [WHERE ...]
\end{verbatim}
It can be used to count occurrences of column values. It is similar to
the GROUPBY clause in SQL which is not impemented yet.

\item calculation
\begin{verbatim}
  CALC [FROM table_list CALC] expression
\end{verbatim}
It can be used to calculate an expression, in which columns
in a table can be used.

\item table creation
\begin{verbatim}
  CREATE TABLE table [column_spec] [DMINFO datamanager_list]
\end{verbatim}
It can be used to create a new table with the given columns.
Optionally specific data manager info can be given.

\end{itemize}
The commands and verbs in the commands are
case-insensitive, but case is important in string values and
in names of columns and keywords. Whitespace (blanks and tabs) can
be used at will.
\\\htmlref{Section 6 (Modifying a table)}{TAQL:MODIFYING} explains the
UPDATE, INSERT, and DELETE commands in more detail. The CREATE TABLE command is
explained in \htmlref{section 7 (Creating a table)}{TAQL:CREATETABLE}.
\\\htmlref{Section 8 (Counting in a table)}{TAQL:COUNTING}
explains the COUNT command in more detail.
\\\htmlref{Section 9 (Calculations on a table)}{TAQL:CALCULATING}
explains the CALC command in more detail.

\subsection{Using a style}
TaQL can be used from different languages, in particular Python and
Glish. Each has its own conventions breaking down into three important
categories: 
\begin{itemize}
\item 0-based or 1-based indexing.
\item Fortran-order or C-order of arrays.
\item Inclusive or exclusive end in \texttt{start:end} ranges.
\end{itemize}
The user can set the style (convention) to be used by preceeding a
TaQL statement with
\begin{verbatim}
  USING STYLE value, value, ...
\end{verbatim}
The possible (case-independent) values are:
\begin{itemize}
\item \texttt{BASE0} or \texttt{BASE1} telling the indexing style.
\item \texttt{ENDEXCL} or \texttt{ENDINCL} telling the range style.
\item \texttt{CORDER} or \texttt{FORTRANORDER} telling the array style.
\item \texttt{PYTHON} which is equivalent to \texttt{BASE0,ENDEXCL,CORDER}
\item \texttt{GLISH} which is equivalent to \texttt{BASE1,ENDINCL,FORTRANORDER}
\end{itemize}
If multiple values are given for a category, the last one will be used.
The default style used is \texttt{GLISH}, which is the way TaQL always
worked before this feature was introduced.

It is important to note that the interpretation of the axes numbers
depends on the style being used. E.g. when using glish style, axes numbers are
1-based and in Fortran order, thus axis 1 is the most rapidly varying
axis. When using python style, axis 0 is the most slowly varying axis.
\\AIPS++ arrays are in Fortran order, but TaQL maps it to the
style being used. Thus when using python style, the axes will be
reversed (data will not be transposed).

The style feature has to be used with care. A given TaQL statement will
behave differently when used with another style.

\subsection{Timing}
It is possible to time a TaQL command by giving the case-insensitive
keyword \texttt{TIME} after the optional style keywords described
above. If given, the total execution time and the times needed for various parts of the
TaQL command will be shown on stdout. For example:
\begin{verbatim}
time select distinct ANTENNA1,ANTENNA2
from ~/3C343.MS where any(FLAG)'

  Where          2.87 real    2.16 user    0.69 system
  Projection        0 real       0 user       0 system
  Distinct       0.18 real    0.16 user    0.03 system
 Total time      3.07 real    2.33 user    0.72 system
\end{verbatim}
shows the time to do the where part (i.e. row selection on FLAG),
projection (selection of columns), and distinct (unique column values).

\subsection{\label{TAQL:RESERVEDWORDS}Reserved words}
TaQL uses the following words as part of its language.
\begin{verbatim}
  ALL           AND      AS        ASC
  BETWEEN 
  CALC          CREATETABLE
  DELETE        DESC     DISTINCT  DMINFO
  EXCEPT        EXISTS
  F             FALSE    FROM
  GIVING        GROUPBY
  HAVING
  IN            INCONE   INSERT    INTERSECT  INTO
  JOIN
  LIKE          LIMIT
  MINUS
  NODUPLICATES  NOT
  OFFSET        ON       OR        ORDERBY
  SAVETO        SELECT   SET
  T             TRUE
  UNION         UNIQUE   UPDATE    USINGSTYLE
  VALUES 
  WHERE
  XOR
\end{verbatim}
These words are reserved. Note that the words in the TaQL vocabulary
are case insensitive, 
thus the lowercase (or any mixed case) versions are also reserved.

The reserved words cannot directly be used as
\htmlref{column name}{TAQL:COLUMNS},
\htmlref{keyword name}{TAQL:KEYWORDS}, or 
\htmlref{unit}{TAQL:UNITS}.
However, a reserved word can be used by escaping it with a backslash like
\verb+\+\texttt{AS}. When reading further, the meaning of
\begin{verbatim}
     \IN  \in  IN [3mm,4mm]
   column unit IN    set
\end{verbatim}
might come clear. It means: use unit \texttt{in} (inch) for column
\texttt{IN} and test if it is in the given set. 
\\Note this is unlike SQL where quotes have to be used to use a
reserved word as a column name.

\section{Selection from a table}
The SELECT is the main TaQL command. It can be used to select a subset
of rows and/or columns from a table or to generate new columns based
on expressions.

As explained above, the result of a selection is usually a reference
table. This table can be used as any other table, thus it is possible
to do another selection on it or to update it (which updates the
underlying original table). It is, however, not possible to insert
rows in a reference table or to delete rows from it.

If the select column list contains expressions, it is not possible to
generate a reference table. Instead a normal plain table is generated
(which can take some time if it contains large data arrays).
It should be clear that updating such a table does not update the
original table.

The various parts of the SELECT command are explained in the following
sections.
\\Although the clauses column\_list, WHERE, ORDERBY, LIMIT, and OFFSET
are optional,
at least one of them has to be used. Otherwise no operation is
performed on the primary table (which makes no sense).
Note that the GIVING clause with a value set is seen as an operation
as well.

\subsection{\label{TAQL:COLUMNLIST}SELECT column\_list}
Columns to be selected can be given as
a comma-separated list with names of columns that have to be
selected from the primary table in the table\_list (see below).
If no column\_list is given, all columns will be selected.
It results in a so-called reference table. Optionally a
selected column can be given another name in the reference
table using \texttt{AS name} (where AS is optional).
For example:
\begin{verbatim}
  select TIME,ANTENNA1,ANTENNA2,DATA from 3C343.MS
  select TIME,ANTENNA1,ANTENNA2,MODEL_DATA AS DATA from 3C343.MS
\end{verbatim}
It is possible to change the data type of a column by specifying a
data type (see below) after the new column name. Giving a data type
(even if the same as the existing one) counts as an expression,
thus results in the generation of a plain table.
For example:
\begin{verbatim}
  select MODEL_DATA AS DATA FCOMPLEX from 3C343.MS
\end{verbatim}

Apart from giving exact column names, it is also possible to use
wildcards by means of a UNIX filename-like pattern (like \texttt{p/pattern/})
or a regular expression (like \texttt{f/regex/} for a full match or
\texttt{m/regex/} for a partial match). They can be suffixed with an
\texttt{i} indicating case-insensitive matching.
See \htmlref{section 4.3.6}{TAQL:REGEXCONST} for a discussion of these constants.
The operator \verb+~+ needs to be given before the pattern or regex
to indicate that columns have to be included. Thereafter operator
\verb+!~+ can be used with another pattern or regex to remove columns.
Such an excluding pattern or regex only removes columns from the
wildcarded columns before it until the latest non-wildcarded column.
\\A special pattern is * (which is the same as \texttt{~p/*/}).
 For example:
\begin{verbatim}
  select *, !~p/*_DATA/ from 3C343.MS
\end{verbatim}
selects all columns except the ones ending in \texttt{\_DATA}.
\begin{verbatim}
  select ~m/DATA/, !~p/*_DATA/ from 3C343.MS
\end{verbatim}
selects columns with a name containing \texttt{DATA} except the ones
ending in \texttt{\_DATA}.
\begin{verbatim}
  select CORRECTED_DATA, *, !~p/*_DATA/ from 3C343.MS
or
  select *, !~p/*_DATA/, CORRECTED_DATA from 3C343.MS
\end{verbatim}
does select the \texttt{CORRECTED\_DATA} column.
\\Note it is not possible to change the name or data type of
wildcarded columns.

It is also possible to use expressions in the column list to create
new columns based on the contents of other columns. When doing this,
the resulting table is a plain table (because a reference table
cannot contain expressions). The new column can be given a name
by giving \texttt{AS name} after the expression (where AS is
optional). If no name is given, a unique name like
\texttt{Col\_1} is constructed.
After the name a \htmlref{data type string}{TAQL:DATATYPESTRING} can
be given for the new column. If no data type is given, the expression
data type is used.
\begin{verbatim}
  select max(ANTENNA1,ANTENNA2) AS ANTENNA INT from 3C343
  select means(DATA,1) from 3C343
\end{verbatim}
Note that unit conversion can be (part of) an expression. For example:
\begin{verbatim}
  select TIME d AS TIMEH from my.ms
\end{verbatim}
to store the time in unit \texttt{d} (days). Units are discussed in
\htmlref{section 4.9}{TAQL:UNITS}.

Note that for subqueries the GIVING clause offers a
better (faster) way of specifying a result expression. It also makes it
possible to use intervals.

If a column\_list is given and if all columns are scalars, the
column\_list can be preceeded by the word DISTINCT.
It means that the result is made unique by removing the rows
with duplicate values in the columns of the column\_list.
Instead of DISTINCT the synonym NODUPLICATES or UNIQUE can also
be used.
To find duplicate values, some temporary sorting is done,
but the original order of the remaining rows is not changed.
\\Note that support of this keyword is mainly done for SQL
compliance. The same (and more) can be achieved with the
DISTINCT keyword in the \htmlref{ORDERBY}{TAQL:ORDERBY} clause
with the difference that ORDERBY DISTINCT will change the order.
\\For full SQL compliance it is also possible to give the keyword
ALL which is the opposite of DISTINCT, thus all values are
returned. This is the default. Because there is an ambiguity between
the keyword ALL and function ALL, the first element of the column
list cannot be an expression starting with a parenthesis if the
keyword ALL is used.

\subsection{\label{TAQL:INTO}INTO [table] [AS type]}
This indicates that the ultimate result of the SELECT command should be
written to a table (with the given name). This table can be a
reference table, a plain table, or a memory table.

The table argument gives the name of the resulting table. It can be
omitted if a memory table is created.

The type argument is optional and can be one of several values:
\begin{description}
  \item[MEMORY ]to store the result in a memory table.
  \item[PLAIN ]to store the result in a plain table. Its endian format
is determined by the aipsrc definition.
  \item[PLAIN\_BIG ]to store the result in a plain table in big-endian format.
  \item[PLAIN\_LITTLE ]to store the result in a plain table in little-endian format.
  \item[PLAIN\_LOCAL ]to store the result in a plain table in native endian format.
\end{description}
If type is not given, the result will be written in a reference table.
However, if expressions are given in the column list of a projection,
the result is written in a plain table.
\\The standard TaQL way to define the output table is the
\htmlref{GIVING}{TAQL:GIVING} clause. INTO is available
for SQL compliance.

\subsection{\label{TAQL:TABLE_LIST}FROM table\_list}
The FROM part defines which tables are used in the selection.
It is a comma-separated list of table names which can contain
path specification and environment variables or the UNIX
\verb+~+ notation.
The first table in the list is the primary
table and is used for all columns in the other clauses.
Usually only one table is used in which case the list consists
of only one table name. E.g.
\begin{verbatim}
  SELECT col1,col2 FROM mytable
    WHERE col1>col2
    ORDERBY col1
\end{verbatim}
In this example columns \texttt{col1} and \texttt{col2}
are taken from \texttt{mytable}.

However, it is possible to specify more tables in the table\_list.
In the WHERE clause these secondary tables can be used to take
keywords from. E.g.
\begin{verbatim}
  SELECT FROM mytable,othertable
    WHERE col1>othertable.key
\end{verbatim}
As shown in the example above a qualifying name (\verb+othertable.+)
can be used in the WHERE
clause to specify from which table a keyword has to be taken.
If no qualifying name is given, the keyword (or column) is taken
from the primary table (i.e., the first table in the table\_list).
This means that qualifying names are only needed in special cases.
The qualifying name can not contain special characters like a slash.
Therefore a table\_name needs an explicit shorthand alias
if it contains special characters.

The full table\_list syntax is:
\\
\texttt{table\_name1 [shorthand1], table\_name2 [shorthand2], etc.}
\\The shorthand defaults to the table\_name. A shorthand is needed if
the table name contains non-alphanumeric characters.
In the following example shorthand \texttt{my} is not really needed.
Shorthand \texttt{other} is needed though.
\begin{verbatim}
  SELECT FROM mytable my, ~user/othertable other
    WHERE my.col1>other.key
\end{verbatim}
Similar to SQL and OQL the shorthand can also be given using
\texttt{AS} or \texttt{IN}. E.g.
\begin{verbatim}
  SELECT FROM mytable AS my, other IN ~user/othertable
\end{verbatim}
Note that if using \texttt{IN}, the shorthand has to preceed
the table name. It can be seen as an iterator variable.

There are three special ways to specify a table:
\begin{enumerate}

\item
A table name can be taken from a keyword in a previously
specified table. This can be useful in a
\htmlref{subquery}{TAQL:SUBQUERIES}. The syntax for this is
the same as that for specifying \htmlref{keywords}{TAQL:KEYWORDS}
in an expression. E.g.
\begin{verbatim}
  SELECT FROM mytable tab
    WHERE col1 IN [SELECT subcol FROM tab.col2::key]
\end{verbatim}
In this example \texttt{key} is a table keyword of column
\texttt{col2} in table \texttt{mytable} (note that \texttt{tab}
is the shorthand for \texttt{mytable} and could be left out).
\\It can also be used for another table in the main query. E.g.
\begin{verbatim}
  SELECT FROM mytable, ::key subtab
    WHERE col1 > subtab.key1
\end{verbatim}
In this example the keyword \texttt{key1} is taken from the
subtable given by the table keyword \texttt{key} in the main
table.
\\If a keyword is used as the table name, the keyword is
searched
in one of the tables previously given. The search starts at
the current query level and proceeds outwards (i.e., up to the
main query level). If a shorthand is given, only tables with
that shorthand are taken into account. If no shorthand is
given, only primary tables are taken into account.

\item
Like in OQL it is possible to use a
\htmlref{nested query}{TAQL:SUBQUERIES}
command in the FROM clause. This is a normal query command
enclosed in square brackets or parentheses. Besides the SELECT command
the COUNT command can also be used.
It results in a temporary table
which can thereafter be used as a table in the rest of the
query command. A shorthand has to be defined for it in order
to be able to refer to that table.
\\Use of a query in the FROM command can be useful to avoid
multiple equal subqueries. E.g.
\begin{verbatim}
  select from MS,
   [select from MS where sumsqr(UVW[1:2]) < 625]
    as TIMESEL
   where TIME in [select distinct TIME from TIMESEL]
    &&  any([ANTENNA1,ANTENNA2] in
      [select from TIMESEL giving
        [iif(UVW[3] < 0, ANTENNA1, ANTENNA2)]])
\end{verbatim}
is a command to find shadowed antennas for the VLA.
Without the query in the FROM command the subqueries in the
remainder of the command would have been more complex.
Furthermore, it would have been necessary to execute that
select twice.
\\The command is quite complex and cannot be fully understood
before reading the rest of this note.
Note, however, that the command uses the shorthand \texttt{TIMESEL}
to be able to use the temporary table in the subqueries.

\item
Normally only persistent tables (i.e. tables on disk) can
be used. However, it is also possible to use transient tables
in a TaQL command given in
\htmlref{Python, Glish, or C++}{TAQL:GLISHPC}.
This is done by passing one or more table objects to the
function executing the TaQL command. In the TaQL command a
\$-sign followed by a sequence number has to be given to
indicate the correct object containing the transient table.
E.g. if two
table objects are passed \$1 indicates the first table, while \$2
indicates the second one.
\end{enumerate}

\subsection{\label{TAQL:WHERE}WHERE expression}
It defines the selection expression which must have a boolean
scalar result. A row in the primary table
is selected if the expression is true for the values in that row.
The syntax of the expression is explained
in a \htmlref{section 4}{TAQL:EXPRESSIONS}.

\subsection{\label{TAQL:ORDERBY}ORDERBY sort\_list}
It defines the order in which the result of the selection
has to be sorted. The sort\_list is a comma separated list of
expressions.
\\The sort\_list can be preceeded by the word \texttt{ASC} or
\texttt{DESC} indicating if the given expressions are by
default sorted in ascending or descending order (default is ASC).
Each expression in the sort\_list can optionally be
followed by \texttt{ASC} or \texttt{DESC} to override the
default order for that particular sort key.
\\To be compliant with SQL whitespace can be used between the
words ORDER and BY.

The word ORDERBY can optionally be followed by DISTINCT
which means that only the first row of multiple rows with
equal sort keys is kept in the result. To be compliant with
SQL dialects the word UNIQUE or NODUPLICATES can be used
instead of DISTINCT.

An expression can be a scalar column or a single element from
an array column. In these cases some optimization is performed
by reading the entire column directly.
\\It can also be an arbitrarily complex expression
with exactly the same syntax rules as the expressions in the
\htmlref{WHERE}{TAQL:EXPRESSIONS} clause.
The resulting data type of the expression must
be a standard scalar one, thus it cannot be a Regex or
DateTime (see \htmlref{below}{TAQL:DATATYPES} for a discussion
of the available data types).
E.g.
\begin{verbatim}
  ORDERBY col1, col2, col3
  ORDERBY DESC col1, col2 ASC, col3
  ORDERBY NODUPLICATES uvw[1] DESC
  ORDERBY square(uvw[1]) + square(uvw[2])
  ORDERBY datetime(col)      incorrect data type
  ORDERBY mjd(datetime(col)) is correct
\end{verbatim}

\subsection{LIMIT expression}
It indicates that up to N rows have to be selected, where N is
the result of the expression. 
\\\texttt{LIMIT} is applied after \texttt{ORDERBY}, so it is
particularly useful in combination with
\texttt{ORDERBY} to select, for example, the highest 10 values.

\subsection{OFFSET expression}
It indicates that the first N rows of the selection have to be 
skipped. As \texttt{LIMIT} it is particularly useful in
combination with \texttt{ORDERBY}. For example:
\begin{verbatim}
  SELECT FROM my.tab ORDERBY DISTINCT TIME LIMIT 1 OFFSET 10
\end{verbatim}
sorts uniquely by time, skips the first 10 values, and selects a
single row.

\subsection{\label{TAQL:GIVING}GIVING [table] [AS type] $|$ set}
It indicates that the ultimate result of the SELECT command should be
written to a table (with the given name).
\\Another (more SQL compliant) way to define the output table
is the \htmlref{INTO}{TAQL:INTO} clause. See \htmlref{INTO}{TAQL:INTO}
for a more detailed description including the possible types.

It is also possible to specify a set in the GIVING clause
instead of a table name. This is very useful if the result of a
\htmlref{subquery}{TAQL:SUBQUERIES} is used in the main query.
Such a \htmlref{set}{TAQL:SETS} can contain multiple elements
Each element can be a single value, range and/or interval as
long as all elements have the same data type.
The parts of each element have to be expressions resulting in a scalar.

In the main query and in a query in the FROM command the
GIVING clause can only result in a table and not in a set.
\\To be compliant with SQL dialects, the word SAVETO can be
used instead of GIVING. Whitespace can be given between SAVE and TO.
 

\section{\label{TAQL:EXPRESSIONS}Expressions}
An expression is the basic building block of TaQL. They similar to
expressions in other languages. An expression is formed by
applying an operator or a function to operands which can be
a table column or keyword, a constant, or a subexpression.
An operand can be a scalar value or an array or set of various data types.
The next subsections discuss them in detail.

An expression can be used in several places:
\begin{itemize}
\item In the WHERE clause where the result must be a boolan scalar value. It
tells if a table row will be selected.
\item As a sort key in the ORDERBY clause where the result must be a
  scalar value (numeric, bool, or string)
\item As an element in the set in the GIVING clause. It must be a
  scalar value of any type except regex.
\item As a scalar or array value in the INSERT and UPDATE command.
\item As a column expression in column-list part of the SELECT
  command. The result can be a scalar or array value.
\item As a scalar or array value in the CALC command.
\end{itemize}

The expression in the clause can be as complex as one likes using
\htmlref{arithmetic, comparison, and logical operators}{TAQL:OPERATORS}, 
\htmlref{functions}{TAQL:FUNCTIONS}, and \htmlref{units}{TAQL:UNITS}.
Parentheses can be used to group subexpressions.
\\The operands in an expression can be
\htmlref{table columns}{TAQL:COLUMNS},
\htmlref{table keywords}{TAQL:KEYWORDS},
\htmlref{constants}{TAQL:CONSTANTS},
\htmlref{units}{TAQL:UNITS},
\htmlref{functions}{TAQL:FUNCTIONS},
\htmlref{sets and intervals}{TAQL:SETS}, and
\htmlref{subqueries}{TAQL:SUBQUERIES}.
\\The \htmlref{index operator}{TAQL:INDEXING} can be used to take a
single element or a subsection from an array expression.
\\E.g.
\begin{verbatim}
  column1 > 10
  column1 + arraycolumn[index] >= min (column2, column3)
  column1 IN [expr1 =:< expr2]
\end{verbatim}
The last example shows a \htmlref{set}{TAQL:SETS} with a continuous interval.

\subsection{\label{TAQL:DATATYPES}Data Types}
Internally TaQL uses the following data types:
\begin{description}
  \item[Bool ] logical values (true or T or false or F)
  \item[Integer ] integer numbers up to 64 bits
  \item[Double ] 64 bit floating point numbers including times/positions
  \item[Complex ] 128 bit complex numbers
  \item[String ] string values on which operator + can be used (concatenation).
  \item[Regex ] regular expressions can be used for string
    matching (see \htmlref{section 4.2}{TAQL:REGEX}). Maximum string
    distances can also be used in a way similar to regular
    expressions. 
  \item[DateTime ] representing a date/time. There are several functions
       acting on a date/time. Operator + and - can be used on them.
\end{description}
Scalars and arbitrarily shaped arrays of these data types can be used.
However, arrays of Regex are not possible.
\\If an operand or function argument with a non-matching data type
is used, TaQL will do the following automatic conversions:
\\- from Integer to Double or Complex.
\\- from Double to Complex.
\\- from String to DateTime.

In this document some special data types are used when describing the functions.
\\- \textbf{Real} means Integer or Double.
\\- \textbf{Numeric} means Integer, Double, or Complex.
\\- \textbf{DNumeric} means Double or Complex.

\label{TAQL:DATATYPESTRING}
TaQL supports any possible data type of a table column or keyword.
In some commands (\htmlref{column list}{TAQL:COLUMNLIST} and
\htmlref{CREATE TABLE}{TAQL:CREATETABLE}) columns are created where
it is possible to specify the data type of a column. 
The following case-insensitive values can be used to specify a type:
\begin{verbatim}
  B          BOOL       BOOLEAN
  U1         UCHAR      BYTE
  I2         SHORT      SMALLINT
  U2   UI2   USHORT     USMALLINT
  I4         INT        INTEGER
  U4   UI4   UINT       UINTEGER
  R4   FLT   FLOAT
  R8   DBL   DOUBLE
  C4   FC    FCOMPLEX   COMPLEX
  C8   DC    DCOMPLEX
  S          STRING
\end{verbatim}

\subsection{\label{TAQL:REGEX}Regular Expressions and String Distances}
TaQL supports the use of extended regular expressions and string distances. They can be
specified in various ways as discussed in \htmlref{section 4.3.6}{TAQL:REGEXCONST}.
There are three basic types of regular expressions.
\begin{itemize}
\item An SQL-style pattern is quite simple. It has 2 special
  characters. The underscore (\_) means a single arbitrary character
  and the percent (\%) means zero or more arbitrary characters.
  Special characters can be escaped with a backslash to retain their
  normal meaning.
  For example:
\begin{verbatim}
  3c\_%
\end{verbatim}
matches \texttt{3c\_} and \texttt{3c\_xx}, but not \texttt{3caxx}.

\item A UNIX-style pattern, as often used for wildcarded file names, is
  more powerful than the SQL-style pattern. It has a few
  special characters that can be escaped with a backslash.
  \begin{itemize}
  \item The question mark (?) means a single arbitrary character.
  \item The asterisk (*) means zero or more arbitrary characters.
    For example: \texttt{3c\_*}
    does the same as the SQL-style pattern above.
  \item Square brackets indicate a bracket expression (character choice).
    For example: \texttt{[ab]} matches \texttt{a} and
    \texttt{b}, but not \texttt{c}.
    A few special characters can be used in a bracket expression:
    \begin{itemize}
    \item A leading \verb+^+ or ! means negation. Thus
      \texttt{[!ab]} matches every character except a and b.
    \item A minus sign indicates a range. For example
      \texttt{[0-9]} matches a digit or \texttt{[a-z]} matches a
      lowercase letter. If a minus sign cannot be interpreted as a
      range, it is a literal minus sign like in \texttt{[-ab]} or the
      second minus sign in \texttt{[a-z-A]}.
    \item Posix character classes \texttt{[:xx:]} where xx can be:
      \\- \textbf{alpha} matching any letter
      \\- \textbf{lower} matching any lowercase letter
      \\- \textbf{upper} matching any uppercase letter
      \\- \textbf{alnum} matching any digit or letter
      \\- \textbf{digit} matching any digit
      \\- \textbf{xdigit} matching any hexadecimal digit (0-9a-fA-F)
      \\- \textbf{space} matching any whitespace character
      \\- \textbf{print} matching any printable character (alnum,
      punct, space)
      \\- \textbf{punct} matching any non-alnum visible character
      (.,!? etc.)
      \\- \textbf{graph} matching any visible printable character (alnum, punct)
      \\- \textbf{cntrl} matching any control character.
      \\For example
      \texttt{[\_[:isalpha:]][\_[:isalnum:]]*} to match variable names.
    \item A bracket expression cannot be empty, thus if ] is the first
      character in the bracket expression, it is interpreted
      literally. Note that is also true if it is the first character
      after the negation character.
    \item A backslash in a character class is always interpreted
      literally, thus special characters cannot be escaped.
      However, as shown above they can always be placed such
      that they are interpreted literally.
    \end{itemize}
  \item Braces can be used for a choice between (possible empty)
    multi-character strings separated by commas.
    Escape a comma or brace with a backslash to treat it literally.
    For example:
    \\\texttt{*.\{h,hpp,c,cc,cpp\}}
    \\It is fully nestable, thus choice strings can be patterns. For example:
    \\\texttt{*.\{[hc]\{,pp\},c\}}
    \\does the same as the example above. Note that the inner choice
    is between an empty string and \texttt{pp}.
  \end{itemize}

\item An awk/egrep-like extended regular expression is most powerful. A
  full explanation can be found on Wikipedia. Here only a
  summary of its special characters is given. They can be escaped
  using backslashes.
  \begin{itemize}
  \item \texttt{.} matches any character.
  \item \verb+^+ matches beginning of string.
  \item \$ matches end of string.
  \item Square brackets for a bracket expression. It is the same as
    described above with the exception that ! cannot be used as negation character).
  \item * matches zero or more occurrences of previous character or subexpression.
  \item + matches one or more occurrences.
  \item ? matches zero or one occurrence.
  \item \{ and \} for an interval giving minimum and maximum number of
    occurrences. For example:
    \\\texttt{[a-z]\{3,5\}} matches lowercase string with a minimum of 3
    and maximum of 5 characters.
    \\\texttt{[a-z]\{3\}} matches exactly 3 characters.
    \\\texttt{[a-z]\{3,\}} matches at least 3 characters.
    \\\texttt{[a-z]\{,5\}} matches at most 5 characters.
  \item \verb+|+ matches left or right substring
  \item ( and ) to form subexpressions for operators like *.
  \item \verb+\1+ till \verb+\9+ mean backreference to a subexpression (first one is
    \verb+\1+). A string part matches if it is equal to the string
    part matching that subexpression.
    E.g. \verb+(a*)x\1+ matches x, axa, aaxaa, etc.,
    but not axaa nor aaxa.
  \end{itemize}
  For example:
\begin{verbatim}
  .*\.(h|hpp|c|cc|cpp)
  .*\.[hc](pp)?|cc
\end{verbatim}
  do the same as the pattern examples above.
\end{itemize}
Furthermore it is possible to specify maximum string distances
(known as Levensthein or Edit distance). It is explained in 
\htmlref{section 4.3.6}{TAQL:REGEXCONST}.

\begin{verbatim}
  column ~ d/string/ibnn
\end{verbatim}

\subsection{\label{TAQL:CONSTANTS}Constants}
Scalar constants of the various data types can be formed in a way similar
to Python and Glish. Array constants can be formed from scalar
constants.
\subsubsection{Bool}
  A Bool constant is the value \texttt{T} or \texttt{F} (both in
  uppercase) or the value \texttt{true} or \texttt{false} (any case).
\subsubsection{Integer}
  An integer constant is a numeric value without decimal point or exponent.
  It can also be given as a hexadecimal value like \texttt{0xffff}.
\subsubsection{Double (and time/position)}
  A floating-point constant is given with a decimal point and/or
  exponent. Both E and D as well as their lowercase versions can be
  used to specify an exponent. An integer
  number followed by a unit is also regarded as a double constant.
  \\Another way to define a Double constant is by means of
  a Time or Position. Such a constant is always converted to radians.
  It can be given in several ways:
  \begin{itemize}
  \item An integer or floating-point number immediately
    followed by a simple unit
    (thus without whitespace). E.g. \texttt{12.43deg}
    \\Some valid units are deg, arcmin, arcsec (or as), rad.
    The units can be scaled by preceeding them with a letter
    (e.g. mrad is millirad).
  \item A time/position in HMS format. Minutes and/or
    seconds can be left out.
    E.g. \texttt{12h34m34.5} or \texttt{8h}
  \item A position in DMS format. Only seconds can be
    left out because \texttt{12d3} is the floating point constant 12000.
    E.g. \texttt{12d34m34.5} or \texttt{8d0m}
  \item A position as DMS in dot format. Note that the dots
    for degrees and minutes must always be present.
    E.g. \texttt{12.34.34.5} or \texttt{8..34.5}
  \end{itemize}
  Note that DMS positions and units have an ambiguity.
  \texttt{2d3m} will be seen as a position and not
  as 2000 meter (note that 2d3 is a floating point constant).
  Use \texttt{2.d3m} or \texttt{2d3 m} to indicate the meters case.
\subsubsection{Complex}
  The imaginary part of a Complex constant is formed by an
  Integer or Double
  constant immediately followed by a lowercase \textbf{i} or
  \textbf{j}. A full Complex constant is formed by adding another
  Integer or Double constant as the real part. E.g.
  \begin{verbatim}
  1.5 + 2j
  2i+1.5            is identical
  \end{verbatim}
  Note that a full Complex constant has to be enclosed
  in parentheses if, say, a multiplication is performed on it. E.g.
  \begin{verbatim}
  2 * (1.5+2i)
  \end{verbatim}
\subsubsection{String}
  A String constant has to be enclosed in " or ' and can be
  concatenated (as in C++). E.g.
  \begin{verbatim}
  "this is a string constant"
  'this is a string constant containing a "'
  "ab'cd"'ef"gh'
      which results in:   ab'cdef"gh
  \end{verbatim}
\subsubsection{\label{TAQL:REGEXCONST}Regular expression and String distance}
A \htmlref{regular expression}{TAQL:REGEX} constant can be given
directly or using a function.
\begin{itemize}
\item An SQL-style pattern can be given directly as a string constant
  preceeded by operator LIKE or NOT LIKE.
\item A pattern or regular expression can be given like
  \texttt{x/expr/q} preceeded by operator \verb+~+ or \verb+!~+.
  Instead of a slash, the characters \% and \# can also be used as
  delimiter, as long as the same delimiter is used on both sides.
  The delimiter can not be part of the expression 
  (not even escaped with a backslash).
  \\The x denotes the type:
  \\- \textbf{p} means a pattern matching the full string.
  \\- \textbf{f} means a regular expression matching the full string.
  \\- \textbf{m} means a regular expression matching part of the string (a la Perl).
  \\The q denotes optional qualifiers. Currently only \textbf{i} is supported
  meaning a case-insensitive match. For example:
\begin{verbatim}
  name~p/3[cC]*/
  name ~ p%3c*%i
  lower(name) ~ p%3c*%
  name ~ m/^3c/i
  name ~ f/3c.*/i
  filename !~ p#/usr/*.{h,cc}#
\end{verbatim}
  All examples but the last one do the same: matching a name starting with
  3c or 3C.
  \\The last example shows a glob-style pattern to find files on
  \texttt{/usr} not ending in \texttt{.h} or \texttt{.cc}.
\item Apart from these Perl-like specifications, a regular expression can
  also be formed by applying a function to a string constant. The operator
  = or != has to be applied to it.
  \begin{itemize}
  \item Function \texttt{sqlpattern} treats its argument as an SQL-style pattern.
    For example:
\begin{verbatim}
  lower(name) LIKE '3c%'
  lower(name) = sqlpattern('3c%')
\end{verbatim}
    do the same.
  \item Function \texttt{pattern} treats its argument as a UNIX-style pattern.
  \item Function \texttt{regex} treats its argument as a full regular expression.
  \end{itemize}
  Case-insensitive matching can only be done as shown in the example
  above by downcasing the string to be matched.
  \\Please note that these functions are not limited to constants. They can
  also be used to form regular expressions from variables.
\end{itemize}

A maximum string distance constant can be specified in a similar way.
Such a distance is known as the Levensthein or Edit distance.
It is a measure
of the similarity of strings by counting the minimum number of edits
(deletions, insertions, substitutions, and swaps of adjacent
characters) that need to be done to make the strings equal.
\begin{verbatim}
  column ~ d/string/ibnn
\end{verbatim}
This tests if the strings in the given column are within the maximum
distance of the string given in the constant. The following qualifiers
can be given (in any order):
\begin{itemize}
  \item \textbf{i} means a case insensitive test.
  \item \textbf{b} means that blanks in the strings are ignored.
  \item \textbf{nn} is an integer value giving the maximum
    distance. If not given it defaults to \texttt{1 + len(string) / 3}.
\end{itemize}

\subsubsection{\label{TAQL:DATETIMECONST}Date/time}
  DateTime constant can be formed in 2 ways:
  \begin{enumerate}
  \item From a String constant using the \texttt{datetime} function.
    In this way all possible formats as explained in class
    \htmladdnormallink{MVTime}{../html/classcasa_1_1MVTime.html}
    are supported. E.g.
\begin{verbatim}
  datetime ("11-Dec-1972")
\end{verbatim}
  \item A more convenient way is to specify it directly. Since this
    makes use of the delimiters - or /, it conflicts with the
    expression grammar as such. However, such conflicts can be
    solved by using whitespace in a expression and it is believed
    that in practice the convenience surpasses the possible
    conflicts.
    \\A large subset of the MVTime formats is supported.
    A DateTime has to be specified as \texttt{date/time}
    or \texttt{date-time}, where the time part (including
    the / or - delimiter) is optional.
    The possible date formats are:
    \\- YYYY/MM/DD or DD-MM-YYYY
    \\- DD-MMMMMMMM-YY where the - is optional and MMMMMMM is the
    case-insensitive name of the month (at least 3 letters).
    \\- YYYY//DDD or DDD--YYYY where DDD is the day number in
    the year.
    \\In the DMY format, 2000 is added if year$<$50 and
    1900 is added if 50$<=$year$<$100.
    \\If MM$>$12, YYYY will be incremented accordingly.
    \\The general time format in a DateTime constant is:
    \\- hh:mm:ss.s
    \\where the delimiter \textbf{h} or \textbf{H} can be used
    for the first colon and \textbf{m} or \textbf{M} for the second.
    Trailing parts can be omitted. E.g.
\begin{verbatim}
  10-2-97
  10-02-1997
  10-February-97
  10feb97
  1997/2/10          are all identical

  1May96/3:          : (or h) is mandatory
  1May96/3:0
  1May96/3:0:0
  1May96/3h          h (or :) is mandatory
  1May96/3H0
  1May96/3h0M
  1May96/3hm0.0
\end{verbatim}
    A DateTime constant with the current date/time can be made
    by using the function \texttt{datetime} without arguments.
  \end{enumerate}

\subsubsection{Arrays}
N-dimensional arrays of all data types can be created with the
exception of regular expressions. 
\\It is possible to form a 1-dimensional array from a constant bounded discrete
\htmlref{set}{TAQL:SETS}. When needed such a set is automatically
transformed to an array. E.g.
\begin{verbatim}
  [1:10]
  ['str1', 'str2', 'str3']
  'str' + ['1', '2', '3']
\end{verbatim}
The first example results in an integer array of 10 elements with values 1..10.
The others result in a string array of 3 elements. The second version already
shows that strings can be concatenated (as explained further on).

Furthermore it is possible to use the \texttt{array} function to
create an array of any shape. The values are given in the first
argument as a scalar, srt, or another array. The shape is given in the latter
arguments as scalars or as a set. The array is initialized to the
values given which are wrapped if the array has more elements.
\begin{verbatim}
  array([1:10],10,4)
  array([1:10], [10,4])
  array(F,shape(DATA))
\end{verbatim}
The first examples create an array with shape [10,4] containing the values
1..10 in each line.
The latter results in a boolean array having the same
shape as the DATA array and filled with False.

\subsection{\label{TAQL:COLUMNS}Table Columns}
A table column can be used in a query by giving its name in the
expression.
Note that only columns in the primary table can be handled directly.
A column in another table can be used via a subquery. E.g.
\begin{verbatim}
  SELECT FROM tab WHERE col >
        mean([SELECT othercol FROM othertab])
\end{verbatim}
An expression has to contain at least one column, since columns
are the only variable part in it. That is, a row can only be selected
or sorted by means of the column values in each row.

A column can contain a scalar or an array value of any data type
supported by the table system. It will be mapped to the available TaQL
\htmlref{data types}{TAQL:DATATYPES}.

If the column keywords define a \htmlref{unit}{TAQL:UNITS} for the
column, the unit will be used by TaQL.

The name of a column can contain alphanumeric characters and underscores.
It should start with an alphabetic character or underscore.
A column name is case-sensitive.
\\It is possible to use other characters in the name by
escaping them with a backslash. E.g. \texttt{DATE}\verb+\+\texttt{-OBS}.
\\In the same way a numeric character can be used as the first
character of the column name. E.g. \verb+\+\texttt{1stDay}.
\\
A  \htmlref{reserved word}{TAQL:RESERVEDWORDS} cannot
be used directly as column name.
It can, however, be used as a column name by escaping
it with a backslash. E.g. \verb+\+\texttt{IN}.
\\Note that in programming languages like C++ and Python a backslash
itself has to be escaped by another backslash. E.g. in Python:
\texttt{tab.query('DATE}\verb+\\+\texttt{-OBS$>$10MAR1996')}.

If a column contains a record, one has to specify a field in it
using the dot operator; e.g. \texttt{col.fld} means use field
\texttt{fld} in the column. It is fully recursive, so
\texttt{col.fld.subfld} can be used if field \texttt{fld} is a record
in itself.
\\Alas records in columns are not really supported yet. One can specify
fields, but thereafter an error message will be given.

\subsection{\label{TAQL:KEYWORDS}Table Keywords}
It is possible to use table or column keywords, which can have
a scalar or an array value. A table keyword has to be specified
as \texttt{::key}. In an expression the \texttt{::} part can be omitted
if there is no column with such a name.
A column keyword has to be specified as \texttt{column::key}.
\\Note that the \texttt{::} syntax is chosen, because it is similar
to the scope operator in C++.
\\
As explained in the \htmlref{FROM clause}{TAQL:TABLE_LIST} of the syntax
section, keywords from the primary table and from secondary tables
can be used. If used from a secondary table, it has to be qualified
with the (shorthand) name of the table. E.g.
\\\texttt{sh.key} or \texttt{sh.::key}
\\takes table keyword \texttt{key} from the table with the shorthand name
\texttt{sh}.

If a keyword value is a record, it is possible to use
a field in it using the dot operator. E.g. \texttt{::key.fld}
to use field \texttt{fld}. It is fully recursive, so if the
field is a record in itself, a subfield can be used like
\texttt{col::key.fld.subfld}

A keyword can be used in any expression. It is evaluated immediately
and transformed to a constant value.

\subsection{\label{TAQL:OPERATORS}Operators}
TaQL has a fair amount of operators which have the same meaning as
their C and Python counterparts.
The operator precedence order is:
\begin{verbatim}
  **
  !  ~  +  -       (unary operators)
  *  /  // %
  +  -
  &
  ^
  |
  == != >  >= <  <=  IN INCONE BETWEEN EXISTS LIKE  ~  !~
  &&
  ||
\end{verbatim}
Operator names are case-insensitive.
For SQL compliancy some operators have a synonym.
\begin{verbatim}
  ==     =
  !=     <>
  &&     AND
  ||     OR
  !      NOT
  ^      XOR
\end{verbatim}
All operators can be used for scalars and arrays and a mix of them.
Note that arrays of regular expressions cannot be used.

The following table shows all available operators and the data types
that can be used with them.

\begin{tabular}{lp{2cm}p{10cm}}
  Operator & Data Type & Description \\ \hline
  \texttt{**} & numeric & power. It is right associative, thus \texttt{2**1**2} results in
  \texttt{2}. \\
  \texttt{*} & numeric & multiplication \\
  \texttt{/} & numeric & non-truncated division, thus \texttt{1/2} results
  in \texttt{0.5} \\
  \texttt{//} & real & truncated division (a la Python)
 resulting in an integer, thus \texttt{1./2.} results in \texttt{0} \\
  \texttt{\%} & real & modulo; \texttt{3.5\%1.2} results in
  \texttt{1.1}; \texttt{-5\%3} results in \texttt{-2} \\
  \texttt{+} & no bool & addition. If a date is
  used, only a real (converted to unit day) can be added to it. String addition means
  concatenation. \\
  \texttt{-} & numeric,date & subtraction. Substracting a date from a
  date results in a real (with unit day). Subtracting a real
  (converted to unit day) from a date results in a date. \\
  \texttt{\&} & integer & bitwise and \\
  \verb+|+ & integer & bitwise or \\
  \verb+^+, XOR & integer & bitwise xor \\
  $==$, $=$& all & comparison for equal. The norm is used when
  comparing complex numbers. \\
  $>$ & no bool & comparison for greater \\
  $>=$ & no bool & comparison for greater or equal \\
  $<$ & no bool & comparison for less \\
  $<=$ & no bool & comparison for less or equal \\
  $!=$, $<>$ & all & comparison for not equal \\
  \texttt{\&\&}, AND & bool & logical and \\
  \verb+||+, OR & bool & logical or \\
  \texttt{!}, NOT & bool & logical not \\
  \verb+~+ & integer & bitwise negation \\
  \texttt{+} & numeric & unary plus \\
  \texttt{-} & numeric & unary minus \\
  \verb+~+ & string & test if string matches a regular expression
       \htmlref{constant}{TAQL:CONSTANTS}. \\
  \verb+!~+ & string & test if string does not match a regular expression
  constant. \\
  LIKE & string & test if a string matches an SQL pattern. \\
  NOT LIKE & string & test if string does not match SQL pattern. \\
  IN & all & test if a value is present in a set of
       values, ranges, and/or intervals.
       (See the discussion of \htmlref{sets}{TAQL:SETS}). \\
  NOT IN & all & negation of IN \\
  BETWEEN & no bool & \texttt{a BETWEEN b AND c} is similar to
  \texttt{a>=b AND a<=c} and \texttt{a IN [b:=:c]} \\
  NOT BETWEEN & no bool & \texttt{a NOT BETWEEN b AND c} is negation
  of above. \\
  INCONE & & cone search. (See the discussion of
       \htmlref{cone search functions}{TAQL:CONESEARCH}). \\
  NOT INCONE & & negation of INCONE \\
  EXISTS & & test if a subquery finds at least N matching rows.
       The value for N is taken from its LIMIT clause; if LIMIT is
       not given it defaults to 1. The subquery loop stops as soon as
       N matching rows are found.
       E.g.
    \texttt{EXISTS(select from ::ANTENNA where NAME=''somename'' LIMIT 2)}
       results in true if at least 2 matching rows in the ANTENNA table
       were found. \\
  NOT EXISTS & & negation of EXISTS \\
\end{tabular}

\subsection{\label{TAQL:SETS}Sets and intervals}
As in SQL the operator \texttt{IN} can be used to do a selection
based on a set. E.g.
\begin{verbatim}
  SELECT FROM table WHERE column IN [1,2,3]
\end{verbatim}
The result
of operator \texttt{IN} is true if the column value matches one of the
values in the set.
A set can contain any data type except a regex.

This example shows that (in its simplest form) a set
consists of one or more values (which
can be arbitrary expressions) separated by commas and enclosed in
square brackets. The elements in a set have to be scalars and their
data types have to be the same or convertible to a common data type.
 The square brackets can be left out if
the set consists of only one element. For SQL compliance
parentheses can be used instead of square brackets.

An array is also a set, so \texttt{IN} can also be used on an array
like:
\begin{verbatim}
  SELECT FROM table WHERE column IN expr1
\end{verbatim}
where \texttt{expr1} is the array result of some expression.
 It is also possible to use a scalar as the
righthand of operator \texttt{IN}.
So if \texttt{expr1} is a scalar, operator \texttt{IN}
gives the same result as operator \texttt{==}.

The lefthand operand of the \texttt{IN} operator can also be an array or
set. In that case its reult is a boolean array telling for each
element in the lefthand operand if it is found in the righthand
operand.

An element in a set can be more complicated than a single value.
It can define multiple values or an interval. The possible forms of
a set element are:
\begin{enumerate}
\item A single value as shown in the example above.
\item \texttt{start:end:incr}. This is similar to the
way an array index is specified. Incr defaults to 1.
End defaults to an open end (i.e., no upper bound) and results
in an unbounded set. Start and end can be a real or a datetime.
Incr has to be a real. Some examples:
\begin{verbatim}
  1:10     means 1,2,...,9,10  (10 only when using glish style)
  1:10:2   means 1,3,5,7,9
  1::2     means all odd numbers
  1:       means all positive integer numbers
  date('18Aug97')::2   means every other day from 18Aug97 on
\end{verbatim}
These examples show constants only, but \texttt{start}, \texttt{end},
and \texttt{incr} can be any expression.
\\Note that :: used here can conflict with the :: in the
\htmlref{keywords}{TAQL:KEYWORDS}. E.g. \texttt{a::b} is scanned as
a keyword specification. If the intention is \texttt{start::incr}
it should be specified as \texttt{a: :b}. In practice this conflict
will hardly ever occur.
\item Continuous intervals can be specified for data type real, string, and datetime.
The specification of an interval resembles the mathematical notation
\texttt{1<x<5}, where x is replaced by :. An open interval side
is indicated by \texttt{<}, while a closed interval side is indicated
by \texttt{=}.
\\Another way to specify intervals is using curly and/or angle brackets.
A curly bracket is a closed side, the angle bracket is an open side.
The following examples show how bounded and half-bounded,
(half-)open and closed intervals can be specified.
\begin{verbatim}
  1=:=5   {1,5}     means 1<=x<=5   bounded closed
  1<:<5   <1,5>     means 1<x<5     bounded open
  1=:<5   {1,5>     means 1<=x<5    bounded right-open
  1<:=5   <1,5}     means 1<x<=5    bounded left-open
  1=:  {1,}  {1,>   means 1<=x      left-bounded closed
  1<:  <1,}  <1,>   means 1<x       left-bounded open
  :=5  {,5}  <,5}   means x<=5      right-bounded closed
  :<5  {,5>  <,5>   means x<5       right-bounded open
\end{verbatim}
\end{enumerate}
It is very important to note that the 2nd form of set specification results in
discrete values, while the 3rd form results in a continuous interval.

Each element in a set can have its own form, i.e., one element can
be a single value while another can be an interval.
If a set consists of single or bounded discrete
\texttt{start:end:incr} values only, the set will be expanded to an
array.
This makes it possible for array operators and functions
(like \texttt{mean}) to be applied to such sets. E.g.
\begin{verbatim}
  WHERE column > mean([10,30:100:5])
\end{verbatim}

Another form of constructing a set is using a
\htmlref{subquery}{TAQL:SUBQUERIES} as described in section 4.11.

\subsection{\label{TAQL:INDEXING}Array Index Operator}
It is possible to take a subsection or a
single element from an array column, keyword or expression
using the index operator
\texttt{[index1,index2,...]}. This syntax
is similar to that used in Python or Glish.
Taking a single element can be done as:
\begin{verbatim}
  array[1, 2]
  array[1, some_expression]
\end{verbatim}
Taking a subsection can be done as:
\begin{verbatim}
  array[start1:end1:incr1, start2:end2:incr2, ...]
\end{verbatim}
If a start value is left out it defaults to the beginning of
that axis. An end value defaults to the end of the axis and
an increment defaults to one. If an entire axis is left out,
it defaults to the entire axis.
\\E.g. an array with shape [10,15,20] can be subsectioned as:
\begin{verbatim}
  [,,3]               resulting in an array of shape [10,15,1]
  [2:4, ::3, 2:15:2]  resulting in an array of shape [3,5,7]
                      (NB. shape is [2,5,7] for python style)
\end{verbatim}
The examples show that an index can be a simple constant (as it will
usually be). It can also be an expression which can be as complex
as one likes. The expression has to result in a positive real value
which will be truncated to an integer length.
\\For fixed shaped arrays checking if array bounds are exceeded
is done at parse time.
For variable shaped arrays
it can only be done per row. If array bounds are exceeded,
an exception is thrown. In the future a special undefined value
will be assigned if bounds of variable shaped arrays are exceeded
to prevent the selection process from aborting due to the exception.

Note that the index operator will be applied directly
to a column. This results in reading only the required part of the
array from the table column on disk.
It is, however, also possible to apply it to a
subexpression (enclosed in parentheses) resulting in an array.
E.g.
\begin{verbatim}
  arraycolumn[2,3,4] + 1
  (arraycolumn + 1)[2,3,4]
\end{verbatim}
can both be used and have the same result. However, the first
form is much faster, because only a single element is read
(resulting in a scalar) and 1 is added to it.
The second form results in reading the entire array.
1 is added to all elements and only then the requested element is taken.
\\From this example it should be clear that indexing an array
expression has to be done with care.

\subsection{\label{TAQL:UNITS}Units}
Units can be given at many places in an expression; in fact, each
subexpression can be ended with a unit meaning that the subexpression
result gets that unit or will be converted to that unit. A simple
unit (only letters) can always be given literally. A non-simple unit
can be given literally if only containing digits, underscores and/or
dots (e.g. \texttt{m2}, \texttt{fl\_oz}. or \texttt{m.m}).
Otherwise the unit has to be enclosed in single or double quotes
(e.g. \texttt{'m/s'}) or the backslash has to be used as escape
character (e.g. \verb+\+\texttt{in} or \texttt{m}\verb+\+\texttt{/s}).
\\Arguments to functions like \texttt{sin} will be converted to the
appropriate unit (radians) as needed. In a similar way, the units of
operands to operators like addition, will be converted as needed.
An exception is thrown if a unit conversion is not possible.

All units supported by module
\htmladdnormallink{Quanta}{../html/group__Quanta__module.html}
can be used. Note that the
units are case sensitive. Most common units use lowercase characters.
A unit can be preceeded by a scaling prefix (like \texttt{k} for kilo).
In glish one can use \texttt{dq.map()} to see the available units and
prefixes. Compound units are created when multiplying or
dividing values with units.

Units can be given as follows:
\begin{itemize}
 \item If a column has a unit defined in column keyword
	\texttt{QuantumUnits} or \texttt{UNIT}, it automatically
	gets that unit.
 \item A constant can immediately be followed by a simple unit..
	E.g. \texttt{2deg}.
 \item The result of several expressions have an implicit unit.
	\\Constants given as positions are in radians (rad).
	\\Difference of 2 dates is in days (d).
	\\Inverse trigonometric functions like \texttt{asin} give radians.
 \item When combining values with different units in e.g. an interval,
	a set, an addition, or a function like \texttt{min}, the values
	are converted to the unit of the first operand or argument
	with a unit. Values without a unit have by default the unit
	of the first operand or argument with a unit.
\begin{verbatim}
  3mm-7cm          result is -67 mm
  3+3mm            result is 6 mm
  3mm<:<3cm        result is interval <3mm,30mm>
  [3,4cm,5]        result is [3cm, 4cm, 5cm]
  [5, 7cm, 8mm]    result is [5cm, 7cm, 0.8cm]
  [5, 7mm, 8cm]    result is [5mm, 7mm, 80mm]
  max(3mm,2cm)     result is 20 mm
  5 'km/h' + 1 'm/s'      is 8.6 km/h
  iif(F,3min,30sec)       is 0.5 min
\end{verbatim}
 \item Similarly operands of comparison operators and arguments of
	comparison functions (like \texttt{near}) are converted to
	the unit of the first operand or argument with a unit.
 \item The result of a multiplication and division is a compound unit
	if both operands have a unit. Otherwise it is the unit of
	the argument with a unit.
        \\Before TaQL supported units, it was needed to divide the
	TIME column in a MeasurementSet by 86400 to convert it to
	days, so it could be compared with a given date/time.
	So, for backward compatibility, a division of a value with
	unit \texttt{s} by a constant 86400 results in unit \texttt{d}.
 \item The result of functions like \texttt{SUMSQR} and \texttt{SQRT} is a
	compound unit if the argument has a unit.
	Note that \texttt{sqrt(2m)} will fail, because the square root
	of a meter does not exist.
 \item A (sub)expression can be followed by a simple or compound unit.
       If the subexpression has no unit, it gets the given unit.
       Otherwise the resulting value is converted to the unit.
       \\Note that some units can be the same as a
       \htmlref{reserved word}{TAQL:RESERVEDWORDS}
       (e.g. \texttt{as} or \texttt{in}).
       In that case it has to be escaped or enclosed in quotes.
\begin{verbatim}
  COL \in          set/convert column COL to inch
  3 cm             result is 3 cm
  3 'km/s'         result is 3 km/second
  3mm cm           result is 0.3 cm
  (3mm cm)m        result is 0.003 m
  (3+3) cm         result is 6 cm
  (3+3mm) cm       result is 0.6 cm
  [3,4,5]mm        result is [3mm, 4mm, 5mm]
  [3,4cm,5]mm      result is [30mm, 40mm, 50mm]
      Note: all values in the set first get the same unit cm
  asin(1)          result is pi/2 radians
  asin(1) deg      result is 90 degrees
  (3mm+7cm) m      result is 0.073 m
\end{verbatim}
 \item If a function argument is expected in a certain unit, values
	are converted as needed. For example, arguments to functions 
	\texttt{sin} and \texttt{anycone}
	are automatically converted to radians.
 \item When adding or subtracting a value from a date, that value is
	converted to unit \texttt{d} (days).
\end{itemize}
Units will probably mostly be used in an expression in the WHERE
clause or in a CALC command. However, it is also possible to use a
unit in the selection of a column in the SELECT clause. For example:
\\\texttt{select TIME d as TIMED from my.ms}
In such a case the selection is an expression and the unit is stored
in the column keywords. Thus in this example, TIME is stored in a
column \texttt{TIMED} with keyword \texttt{QuantumUnits=d} and the 
values are converted to days.

\subsection{\label{TAQL:FUNCTIONS}Functions}
More than 100 functions exist to operate on scalar and/or array values.
Some functions have two names. One name is the CASA/Glish name, while the
other is the name as used in SQL.
In the following tables the function names are shown in uppercase,
while the result and argument types are shown in lowercase.
Note, however, that function names are case-insensitive.
\\Furthermore it is possible to have \htmlref{user defined  functions}{TAQL:UDF}
that are dynamically loaded from a shared library. In section
\htmlref{Writing user defined functions}{TAQL:UDFWRITE} it is
explained how to write user defined functions.

\htmlref{Sets}{TAQL:SETS}, and in particular
\htmlref{subqueries}{TAQL:SUBQUERIES}, can result in a 1-dim array.
This means that the functions accepting an array argument can also
be used on a set or the result of a subquery.

\subsubsection{String functions}
These functions can be used on a scalar or an array argument.
\begin{description}
  \item[] \texttt{integer STRLENGTH(string),  integer LEN(string)}\\
       Returns the number of characters in a string
       (trailing whitespace is significant).
  \item[] \texttt{string UPCASE(string), string UPPER(string) }\\
        Convert to uppercase.
  \item[] \texttt{string DOWNCASE(string),  string LOWER(string)}\\
        Convert to lowercase.
  \item[] \texttt{string LTRIM(string)}\\
       Removes leading whitespace.
  \item[] \texttt{string RTRIM(string)}\\
       Removes trailing whitespace.
  \item[] \texttt{string TRIM(string)}\\
       Removes leading and trailing whitespace.
\end{description}

\subsubsection{Regex functions}
Apart from using \htmlref{regex/pattern constants}{TAQL:REGEXCONST},
it is possible to use functions to form a regex or pattern.
These functions can only be used on a scalar argument.

\begin{description}
  \item[] \texttt{regex REGEX(string)}\\
       Handle the given string as a regular expression.
  \item[] \texttt{regex PATTERN(string)}\\
       Handle the given string as a UNIX filename-like pattern and
       convert it to a regular expression.
  \item[] \texttt{regex SQLPATTERN(string)}\\
       Handle the given string as an SQL-style pattern and
       convert it to a regular expression.
\end{description}
A regex formed this way can only be used in a comparison == or !=. E.g.
\\\texttt{object == pattern('3C*')}
\\to find all 3C objects in a catalogue.

A few remarks:
\begin{enumerate}
\item The regex/pattern functions and operator LIKE work on any string,
thus they can be used with any string expression.
\item A Regex is case sensitive. One should use 
function \texttt{upcase} or \texttt{downcase} on the string to test to
make it case insensitive or use the \textit{i} qualifier on a regex constant.
\item Usually a regex/pattern must match the full string, thus not part of
it. However, one can use the \texttt{m//} regex constant to do partial
matching. Thus something like \texttt{m/xx/} matches all strings
containing \texttt{xx}. Of course, \texttt{regex('.*xx.*')} can also be used.
In this way the \texttt{m//} regex works the same as in languages like
Perl, Python, and Glish. 
\end{enumerate}

\subsubsection{Date/time functions}
These functions make it possible to handle dates/times and can be used
on a scalar or an array argument. 
The syntax of a date/time string or constant is explained in
\htmlref{section 4.3.7}{TAQL:DATETIMECONST}.
\begin{description}
  \item[] \texttt{DateTime DATETIME(string)}\\
       Parse the string and convert it to a DateTime value.
  \item[] \texttt{DateTime MJDTODATE(real)}\\
       The real value, which has to be a MJD (ModifiedJulianDate), is
       converted to a DateTime.
  \item[] \texttt{double MJD(DateTime)}\\
        Get the DateTime as MJD (ModifiedJulianDate).
  \item[] \texttt{DateTime DATE(DateTime)}\\
        Get the date (i.e., remove the time part). This function is
        needed in something like:
       \\\texttt{DATE(column) == 12Feb1997}
       \\if the column contains date/times with times$>$0.
  \item[] \texttt{double TIME(DateTime)}\\
       Get the time part of the day. It is converted to radians to
       be compatible with the internal representation of times/positions.
       In that way the function can easily be used as in:
       \\\texttt{TIME(date) $>$ 12h}
  \item[] \texttt{integer YEAR(DateTime)}\\
        Get the year (which includes the century).
  \item[] \texttt{integer MONTH(DateTime)}\\
        Get the month number (1-12).
  \item[] \texttt{integer DAY(DateTime)}\\
        Get the day number (1-31).
  \item[] \texttt{integer WEEK(DateTime)}\\
        Get the week number in the year (0 ... 53).
        \\Note that week 1 is the week containing Jan 4th.
  \item[] \texttt{integer WEEKDAY(DateTime),  integer DOW(DateTime)}\\
        Get the weekday number (1=Monday, ..., 7=Sunday).
  \item[] \texttt{string CDATETIME(DateTime),  string CTOD(DateTime)}\\
        Get the DateTime as a string like YYYY/MM/DD/HH:MM:SS.SSS.
  \item[] \texttt{string CDATE(DateTime)}\\
        Get the date part of a DateTime as a string like DD-MMM-YYYY.
  \item[] \texttt{string CTIME(DateTime)}\\
        Get the time part of a DateTime as a string like HH:MM:SS.SSS.
  \item[] \texttt{string CMONTH(DateTime)}\\
        Get the abbreviated name of the month (Jan ... Dec).
  \item[] \texttt{string CWEEKDAY(DateTime),  string CDOW(DateTime)}\\
        Get the abbreviated name of the weekday (Mon ... Sun).
\end{description}
All functions can be used without an argument in which case the current
date/time is used. E.g. \texttt{DATE()} results in the current date.
\\It is possible to give a string argument instead of a date. In this
case the string is parsed and converted to a date (i.e., the
function DATETIME is used implicitly).

\subsubsection{Comparison functions}
The exact comparison of floating point values is quite tricky.
Two functions make it possible to compare 2 double or complex
values with a tolerance.
They can be used on scalar and array arguments (and a mix of them).
The tolerance must be a scalar though.
\begin{description}
  \item[] \texttt{bool NEAR(numeric val1, numeric val2, double tol)}\\
    Tests in a relative way if a value is near another. Relative
    means that the
    magnitude of the numbers is taken into account.
    \\It returns
    \texttt{abs(val2 - val1)/max(abs(val1),abs(val2)) < tol}.
    \\If \texttt{tol<=0}, it returns \texttt{val1==val2}.
    If either val is 0.0, it takes
    care of area around the minimum number that can be represented.
    The default tolerance is 1.0e-13.
  \item[] \texttt{bool NEARABS(numeric val1, numeric val2, double tol)}\\
    Tests in an absolute way if a value is near another. Absolute
    means that the
    magnitude of the numbers is not taken into account.
    \\It returns \texttt{abs(val2 - val1) < tol}.
    The default tolerance is 1.0e-13.
  \item[] \texttt{bool ISNAN(numeric val)}\\
    Tests if a numeric value is a NaN (not-a-number).
\end{description}

\subsubsection{Mathematical functions}
Standard mathematical can be used on scalar and array arguments (and a mix of them).
\begin{description}
  \item[] \texttt{double PI()}\\
    Return the value of \textbf{pi}.
  \item[] \texttt{double E()}\\
    Return the value of \textbf{e} (is equal to \texttt{EXP(1)}).
  \item[] \texttt{dnumeric SIN(numeric)}
  \item[] \texttt{dnumeric SINH(numeric)}
  \item[] \texttt{double ASIN(real)}
  \item[] \texttt{dnumeric COS(numeric)}
  \item[] \texttt{dnumeric COSH(numeric)}
  \item[] \texttt{double ACOS(real)}
  \item[] \texttt{double TAN(real)}
  \item[] \texttt{double TANH(real)}
  \item[] \texttt{double ATAN(real)}
  \item[] \texttt{double ATAN2(real y, real x)}\\
    Return \texttt{ATAN(y/x)} in correct quadrant.
  \item[] \texttt{dnumeric EXP(numeric)}
  \item[] \texttt{dnumeric LOG(numeric)}\\
    Natural logarithm.
  \item[] \texttt{dnumeric LOG10(numeric)}
  \item[] \texttt{dnumeric POW(numeric, numeric)}\\
    The same as operator \verb+**+.
  \item[] \texttt{numeric SQUARE(numeric),  numeric SQR(numeric)}\\
    The same as \verb+**+2, but much faster.
  \item[] \texttt{dnumeric SQRT(numeric)}
  \item[] \texttt{complex COMPLEX(real, real)}
  \item[] \texttt{dnumeric CONJ(numeric)}
  \item[] \texttt{double REAL(numeric)}\\
    Real part of a complex number. Returns argument if real.
  \item[] \texttt{double IMAG(numeric)}\\
    Imaginary part of a complex number. Returns 0 if argument is real.
  \item[] \texttt{real NORM(numeric)}
  \item[] \texttt{real ABS(numeric),  real AMPLITUDE(numeric)}
  \item[] \texttt{double ARG(numeric),  double PHASE(numeric)}
  \item[] \texttt{numeric MIN(numeric, numeric)}
  \item[] \texttt{numeric MAX(numeric, numeric)}
  \item[] \texttt{real SIGN(real)}\\
    Return -1 for a negative value, 0 for zero, 1 for a positive value.
  \item[] \texttt{real ROUND(real)}\\
    Return the rounded value of the number. Negative numbers are
    rounded in an absolute way.
    E.g. \texttt{ROUND(-1.6) = -2.}.
  \item[] \texttt{real FLOOR(real)}\\
    Works towards negative infinity.
    E.g. \texttt{FLOOR(-1.2) = -2.}
  \item[] \texttt{real CEIL(real)}\\
    Works towards positive infinity.
  \item[] \texttt{real FMOD(real, real)}\\
    The same as operator \%.
\end{description}
Note that the trigonometric functions need their arguments in radians.

\subsubsection{Array to scalar reduction functions}
The following functions reduce an array to a scalar.
They are meant for an array, but can also be used for a scalar.
\begin{description}
  \item[] \texttt{bool ANY(bool)}\\
    Is any element true?
  \item[] \texttt{bool ALL(bool)}\\
    Are all elements true?
  \item[] \texttt{integer NTRUE(bool)}\\
    Return number of true elements.
  \item[] \texttt{integer NFALSE(bool)}\\
    Return number of false elements.
  \item[] \texttt{numeric SUM(numeric)}\\
    Return sum of all elements.
  \item[] \texttt{numeric SUMSQUARE(numeric), numeric SUMSQR(numeric)}\\
    Return sum of all squared elements.
  \item[] \texttt{numeric PRODUCT(numeric)}\\
    Return product of all elements.
  \item[] \texttt{real MIN(real)}\\
    Return minimum of all elements.
  \item[] \texttt{real MAX(real)}\\
    Return maximum of all elements.
  \item[] \texttt{double MEAN(real)}\\
    Return mean of all elements.
  \item[] \texttt{double VARIANCE(real)}\\
    Return variance (the sum of
    \\\texttt{(a(i) - mean(a))**2/(nelements(a) - 1)}.
  \item[] \texttt{double STDDEV(real)}\\
    Return standard deviation (the square root of the variance).
  \item[] \texttt{double AVDEV(real)}\\
    Return average deviation. (the sum of
    \\\texttt{abs(a[i] - mean(a))/nelements(a)}.
  \item[] \texttt{double RMS(real)}\\
    Return root-mean-squares. (the square root of the sum of
    \\\texttt{(a(i)**2)/nelements(a)}.
  \item[] \texttt{double MEDIAN(real)}\\
    Return median (the middle element).
    If the array has an even number of elements, the mean of
    the two middle elements is returned.
  \item[] \texttt{double FRACTILE(real, doublescalar fraction)}\\
    Return the value of the element at the given fraction.
    Fraction 0.5 is the same as the median.
\end{description}

\subsubsection{Array to array reduction functions}
These functions reduce an array to a smaller array by collapsing
the given axes using the given function. The axes are the last argument(s).
They can be given in two ways:
\\- As a single set argument; for example, \texttt{maxs(ARRAY,[1,2])}
\\- As individual scalar arguments; for example, \texttt{maxs(ARRAY,1,2)}
\\For example, using
\texttt{MINS(array,1,2)} for a 3-dim array results in a 1-dim array
where each value is the minimum of each plane in the cube.
\\It is important to note that the interpretation of the axes numbers
depends on the style being used. E.g. when using glish style, axes numbers are
1-based and in Fortran order, thus axis 1 is the most rapidly varying
axis. When using python style, axis 0 is the most slowly varying axis.
\\Axes numbers exceeding the dimensionality of the array are ignored.
For example, \texttt{maxs(ARRAY,[2:10])} works for arrays
of virtually any dimensionality and results in a 1-dim array.
\\The function names are the 'plural' forms of the
functions in the previous section.
They can only be used for arrays, thus not for scalars.
\begin{description}
  \item[] \texttt{bool ANYS(bool)}\\
    Is any element true?
  \item[] \texttt{bool ALLS(bool)}\\
    Are all elements true?
  \item[] \texttt{integer NTRUES(bool)}\\
    Return number of true elements.
  \item[] \texttt{integer NFALSES(bool)}\\
    Return number of false elements.
  \item[] \texttt{numeric SUMS(numeric)}\\
    Return sum of elements.
  \item[] \texttt{numeric SUMSQUARES(numeric), numeric SUMSQRS(numeric)}\\
    Return sum of squared elements.
  \item[] \texttt{numeric PRODUCTS(numeric)}\\
    Return product of elements.
  \item[] \texttt{real MINS(real)}\\
    Return minimum of elements.
  \item[] \texttt{real MAXS(real)}\\
    Return maximum of elements.
  \item[] \texttt{double MEANS(real)}\\
    Return mean of elements.
  \item[] \texttt{double VARIANCES(real)}\\
    Return variance (the sum of
    \\\texttt{(a(i) - mean(a))**2/(nelements(a) - 1)}.
  \item[] \texttt{double STDDEVS(real)}\\
    Return standard deviation (the square root of the variance).
  \item[] \texttt{double AVDEVS(real)}\\
    Return average deviation. (the sum of 
    \\\texttt{abs(a(i) - mean(a))/nelements(a)}.
  \item[] \texttt{double RMSS(real)}\\
    Return root-mean-squares. (the square root of the sum of
    \\\texttt{(a(i)**2)/nelements(a)}.
  \item[] \texttt{double MEDIANS(real)}\\
    Return median (the middle element).
    If the array has an even number of elements, the mean of
    the two middle elements is returned.
  \item[] \texttt{double FRACTILES(real, doublescalar fraction)}\\
    Return the value of the element at the given fraction.
    Fraction 0.5 is the same as the median.
\end{description}

\subsubsection{Array downsampling functions}
These functions are a generalization of the functions in the previous
section. They downsample an array by taking, say, the mean of every
n*m elements. The functions in the previous section downsample by
taking the mean of a full line or plane, etc.
The most useful one is probably calculating the boxed mean, but
the other ones can be used similarly.
The width of each window axis has to be given. Missing axes default to 1.
Similarly to the partial reduction functions described above, the axes
can be given as scalars or as a set.
\\For example,
\texttt{BOXEDMEAN(array,3,3)} calculates the mean
in each 3x3 box. At the end of an axis the box used will be smaller
if it does not fit integrally.
\\The functions can only be used for arrays, thus not for scalars.
\begin{description}
  \item[] \texttt{bool BOXEDANY(bool)}\\
    Is any element true?
  \item[] \texttt{bool BOXEDALL(bool)}\\
    Are all elements true?
  \item[] \texttt{double BOXEDMIN(real)}\\
    Return minimum of elements.
  \item[] \texttt{double BOXEDMAX(real)}\\
    Return maximum of elements.
  \item[] \texttt{double BOXEDMEAN(real)}\\
    Return mean of elements.
  \item[] \texttt{double BOXEDVARIANCE(real)}\\
    Return variance (the sum of
    \\\texttt{(a(i) - mean(a))**2/(nelements(a) - 1)}.
  \item[] \texttt{double BOXEDSTDDEV(real)}\\
    Return standard deviation (the square root of the variance).
  \item[] \texttt{double BOXEDAVDEV(real)}\\
    Return average deviation. (the sum of 
    \\\texttt{abs(a(i) - mean(a))/nelements(a)}.
  \item[] \texttt{double BOXEDRMS(real)}\\
    Return root-mean-squares. (the square root of the sum of
    \\\texttt{(a(i)**2)/nelements(a)}.
  \item[] \texttt{double BOXEDMEDIAN(real)}\\
    Return median (the middle element).
\end{description}

\subsubsection{Array functions operating in running windows}
These functions transform an array into an array with the same shape
by operating on a rectangular window around each array element.
The most useful one is probably calculating the running median, but
the other ones can be used similarly.
The half-width of each window axis has to be given; the full width is
\texttt{2*halfwidth + 1}. Missing axes default to a half-width of 0.
Similarly to the partial reduction functions described above, the axes
can be given as scalars or as a set.
\\For example,
\texttt{RUNNINGMEDIAN(array,1,1)} calculates the median
in a 3x3 box around each array element.
See the \htmlref{examples}{TAQL:RUNEXAMPLES} how it is applied to an image.
\\In the result the edge elements (i.e. the elements where no full
window can be applied) are set to 0 (or false).
\\The functions can only be used for arrays, thus not for scalars.
\begin{description}
  \item[] \texttt{bool RUNNINGANY(bool)}\\
    Is any element true?
  \item[] \texttt{bool RUNNINGALL(bool)}\\
    Are all elements true?
  \item[] \texttt{double RUNNINGMIN(real)}\\
    Return minimum of elements.
  \item[] \texttt{double RUNNINGMAX(real)}\\
    Return maximum of elements.
  \item[] \texttt{double RUNNINGMEAN(real)}\\
    Return mean of elements.
  \item[] \texttt{double RUNNINGVARIANCE(real)}\\
    Return variance (the sum of
    \\\texttt{(a(i) - mean(a))**2/(nelements(a) - 1)}.
  \item[] \texttt{double RUNNINGSTDDEV(real)}\\
    Return standard deviation (the square root of the variance).
  \item[] \texttt{double RUNNINGAVDEV(real)}\\
    Return average deviation. (the sum of 
    \\\texttt{abs(a(i) - mean(a))/nelements(a)}.
  \item[] \texttt{double RUNNINGRMS(real)}\\
    Return root-mean-squares. (the square root of the sum of
    \\\texttt{(a(i)**2)/nelements(a)}.
  \item[] \texttt{double RUNNINGMEDIAN(real)}\\
    Return median (the middle element).
\end{description}

\subsubsection{Miscellaneous functions}
\begin{description}
  \item[] \texttt{bool ISDEFINED(anytype)}\\
    Return false if the value in the current row is undefined. Is
    useful to test if a cell in a column with variable shaped arrays
    contains an array. It can also be used to test if a field in a
    record is defined.
  \item[] \texttt{integer NELEMENTS(anytype), integer COUNT(anytype)}\\
    Return number of elements in an array (1 for a scalar).
  \item[] \texttt{integer NDIM(anytype)}\\
    Return dimensionality of an array (0 for a scalar).
  \item[] \texttt{integerarray SHAPE(anytype)}\\
    Return shape of an array (returns an empty array for a scalar).
  \item[] \texttt{integer ROWNUMBER()}\\
    Return the row number being tested (first row is row number 0 or 1
    depending on the style used).
    \\In combination with function RAND it can, for instance,
    be used to select arbitrary rows from a table.
  \item[] \texttt{integer ROWID()}\\
    Return the row number in the original table. This is especially
    useful for returning the result of a selection of a subtable
    of an AIPS++ measurement set
    (see also \htmlref{subqueries in section 4.11}{TAQL:SUBQUERIES}
    and \htmlref{examples in section 9}{TAQL:SELEXAMPLES}).
  \item[] \texttt{double RAND()}\\
    Return (per table row) a uniformly distributed random number
    between 0 and 1 using a Multiplicative Linear Congruential Generator.
    The seeds for the generator are deduced from the current date and
    time, so the results are different from run to run.
    \\The function can, for instance, be used to select a random
    subset from a table.
  \item[] \texttt{double ANGDIST(arg1,arg2)},
              \texttt{double ANGULARDISTANCE(arg1,arg2)}\\
    Return the angular distance (in radians) between the
    positions in \texttt{arg1} and \texttt{arg2}. Both arguments have
    to be numeric arrays containing an even number of values. Two subsequent values 
    give the RA and DEC (or longitude and latitude) of positions on a
    sphere. The result is a 2-dim array containing the angular
    distance between each position in \texttt{arg1} and \texttt{arg2}.
    If both arguments contain only 2 values, the result is a scalar.
    For example:
    \\\texttt{angdist(DELAY\_DIR[0,], [12h13m45,4d21m39.4, 12h13m49,10d8m4])}
    \\returns an array with shape [2,1] (when using Glish-style [1,2])
    containing the angular
    distance between the center of the field and the two posiitions given. 
  \item[] \texttt{anytype IIF(cond,arg1,arg2)}\\
    This is a special funtion which operates like the ternary \texttt{?:}
    operator in C++. 
    If all arguments are scalars, the result is a scalar, otherwise
    an array. In the latter case possible scalar arguments are
    virtually expanded to arrays.
    IIF evaluates the condition for each element. If True, it takes
    the corresponding element of \texttt{arg1}, otherwise of \texttt{arg2}.
  \item[] \texttt{anytypearray ARRAY(anytype,shape)}\\
    This function creates an array of the given type and shape.
    The shape is given in the last argument(s).
    It can be given in two ways:
    \\- As a single set argument; for example, \texttt{array(0,[3,4])}
    \\- As individual scalar arguments; for example, \texttt{array(0,3,4)}
    \\The first argument gives the values the array is filled with.
    It can be a scalar or an array of any shape. To initialize the
    created array, the value array is flattened to a 1D array.
    Its successive values are stored in the created array. If the
    new array has more values than the value array, the value array is
    reset to its beginning and the process continues.
\end{description}

\subsubsection{\label{TAQL:CONESEARCH}Cone search functions}
Cone search functions make it possible to test if a source is
within a given distance of a given sky position. The expression
\begin{verbatim}
  cos(0d1m) < sin(52deg) * sin(DEC) +
              cos(52deg) * cos(DEC) * cos(3h30m - RA)
\end{verbatim}
could be used to test if sources with their sky position defined
in columns \texttt{RA} and \texttt{DEC} are within 1 arcmin of the
given sky position.
\\The cone search functions implement this expression making life much
easier for the user. Because they
can also operate on arrays of positions, searching in
multiple cones can be done simultaneously. That makes it
possible to find matching source positions in two catalogues as shown
in an example at the end of this section.

The arguments of all functions are described below. All of them have
to be given in radians. However, usually one does not need to bother
because TaQL makes it possible
to specify positions in many formats automatically converted
to radians.
\begin{description}
  \item[] \texttt{SOURCES}\\
       is a set or array giving the positions of one or more
       sources (e.g. in equatorial coordinates)
       to be tested. Normally these are columns in a table.
       Where argument name \texttt{SOURCE} is mentioned below, only a
       single source can be used, otherwise multiple sources.
       \\For example:
       \\\texttt{[RA,DEC]} for scalar columns RA and DEC.
       \\\texttt{SKYPOS} for a column SKYPOS containing 2-element
       vectors with RA and DEC.
  \item[] \texttt{CONES}\\
       is a set or array giving the center positions and radii of
       one or more cones (e.g. as RA,DEC,radius).
       Usually the user will specify it as constants.
       \\For example:
       \\\texttt{[12:13:54, -5.3.34, 0d1m]} for a single cone.
       \\\texttt{[12:13:54, -5.3.34, 0d1m, 1:2:3, 4.5.6, 0d1m]} for two cones.
  \item[] \texttt{CONEPOS}\\
       is a set or array giving the positions of one or more
       cone centers (e.g. as RA,DEC).
  \item[] \texttt{RADII}\\
       is a scalar, set or array giving one or more radii.
       Each radius is applied to all positions in \texttt{CONEPOS}.
       Specifying a cone as \texttt{CONEPOS,RADIUS} is easier than specifying
       it as \texttt{CONES} if the same radius has to be used for
       multiple cones.
       \\For example:
       \\\texttt{[12:13:54, -5.3.34, 1:2:3, 4.5.6], 0d1m} is the same
       as the second \texttt{CONES} example above.
\end{description}
The following cone search functions are available.
\begin{description}
  \item[] \texttt{bool ANYCONE(SOURCE,CONES)}\\
       Return \texttt{T} if the source is contained in at least one of the cones.
       Operator \texttt{INCONE} is a synonym. So
       \texttt{ANYCONE(SOURCE,CONES)} is the same as
       \texttt{SOURCE INCONE CONES}.
  \item[] \texttt{bool ANYCONE(SOURCE,CONEPOS,RADII)}\\
       It does the same as above.
  \item[] \texttt{integer FINDCONE(SOURCES,CONES)}\\
       Return the index of the first cone containing the source.
       If a single source is given, the result is a scalar.
       If multiple sources are given, the result is an array with the
       same shape as the source array.
  \item[] \texttt{integer FINDCONE(SOURCES,CONEPOS,RADII)}\\
       It does the same as above. Note that in this case each radius is
       applied to each cone, so the resulting index array
       is a combination of the two input arrays
       (with the radius as the most rapidly varying axis).
  \item[] \texttt{bool CONES(SOURCES,CONES)}\\
       Return a 2-dim bool array. The length of the most rapidly
       varying axis is the
       number of cones. The length of the other axis is the number of
       sources. When using glish style, element \texttt{(i,j)}
       in the resulting array is \texttt{T}
       if source \texttt{j} is contained in cone \texttt{i}.
  \item[] \texttt{bool CONES(SOURCES,CONEPOS,RADII)}\\
       It does the same as above. However, the result is a 3-dim array
       with the radii as the most rapidly varying axis, cones as the
       next axis, and sources as the slowest axis.
\end{description}
Please note that \texttt{ANYCONE(SOURCE,CONES)} does the same as
\texttt{any(CONES(SOURCE,CONES))}, but is faster because it stops as
soon as a cone is found.
\\Function \texttt{CONES} makes it possible to do catalogue matching.
For example, to find sources matching other sources in the same
catalogue (within a radius of 10 arcseconds):
\begin{verbatim}
  CALC FROM table.cat CALC CONES([RA,DEC],
       [SELECT FROM table.cat GIVING [RA,DEC]], 0d0m10)
\end{verbatim}
Note that in this example the SELECT clause returns an array with positions
which are used as the cone centers. So each source in the catalogue is
tested against every source. It makes it an N-square operation, thus
potentially very expensive.
The result is a 4-dim boolean array with shape (in glish style)
\texttt{[1,nrow,1,nrow]} which can be processed in Glish. Please note
that the \texttt{CONES} function results for 
each row in a array with shape \texttt{[1,nrow,1]}.
\\The query can be done with multiple radii, for example also
with 1 arcsecond and 1 arcminute.
\begin{verbatim}
  CALC FROM table.cat CALC CONES([RA,DEC],
       [SELECT FROM table.cat GIVING [RA,DEC]], [0d0m1, 0d0m10, 0d1m])
\end{verbatim}
resulting in an array with glish shape \texttt{[3,nrow,1,nrow]}.
In this way one can get a better indication how close sources are to
the cone centers.

\subsubsection{\label{TAQL:UDF}User defined functions}
User defined functions (UDF) have to exist in a dynamically loadable
library. In TaQL the name of a UDF consists of the name of the
library (without  lib prefix and extension) followed by a dot and the function name.
For example:
\begin{verbatim}
  derivedmscal.pa1
\end{verbatim}
denotes function \texttt{pa1} in shared library
\texttt{libderivedmscal.so} or \texttt{libcasa\_derivedmscal.so}. On
OS-X the extension \texttt{.dylib} is used.
\\The library and function name are case-insensitive.

 In section
\htmlref{Writing user defined functions}{TAQL:UDFWRITE} it is
explained how to write user defined functions.

The casacore package comes with a few predefined UDFs in library
\texttt{libcasa\_derivedmscal}. The functions can be used on a
MeasurementSet or a CASA calibration table. 
All angles are returned in radians.
For a calibration table, where a row contains a single antenna, 
functions like PA1 are the same as PA2. 
\begin{description}
  \item[] \texttt{double DERIVEDMSCAL.HA()}\\
    is the hourangle of the array center (observatory position).
  \item[] \texttt{double DERIVEDMSCAL.HA1()}\\
    is the hourangle of ANTENNA1.
  \item[] \texttt{double DERIVEDMSCAL.HA2()}\\
    is the hourangle of ANTENNA2.
  \item[] \texttt{double DERIVEDMSCAL.LAST()}\\
    is the local sidereal time of the array center.
  \item[] \texttt{double DERIVEDMSCAL.LAST1()}\\
    is the local sidereal time of ANTENNA1.
  \item[] \texttt{double DERIVEDMSCAL.LAST2()}\\
    is the local sidereal time of ANTENNA2.
  \item[] \texttt{double DERIVEDMSCAL.PA1()}\\
    is the parallactic angle of ANTENNA1.
  \item[] \texttt{double DERIVEDMSCAL.PA2()}\\
    is the parallactic angle of ANTENNA2.
  \item[] \texttt{doublearray DERIVEDMSCAL.AZEL1()}\\
    is the azimuth/elevation of ANTENNA1.
  \item[] \texttt{doublearray DERIVEDMSCAL.AZEL2()}\\
    is the azimuth/elevation of ANTENNA2.
  \item[] \texttt{doublearray DERIVEDMSCAL.UVW\_J2000()}\\
    is the UVW coordinates in J2000 (in meters).
\end{description}

\subsection{\label{TAQL:SUBQUERIES}Subqueries}
As in SQL it is possible to create a set from a subquery. A
subquery has the same syntax as a main query, but has to be
enclosed in square brackets or parentheses. Basically it looks like:
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT time FROM othertable WHERE windspeed < 5]
\end{verbatim}
The subquery on \texttt{othertable} results in a constant set
containing the times
for which the windspeed matches. Subsequently the main query
is executed and selects all rows from the main table with times in
that set.
Note that like other bounded sets this set is transformed to a
constant array, so it is possible to apply functions to it (e.g. min, mean).
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT time FROM othertable WHERE windspeed <
           mean([SELECT windspeed FROM othertable])]
\end{verbatim}
This contains another subquery to get all windspeeds and
to take the mean of them. So the first subquery selects all times
where the windspeed is less than the average windspeed.
\\A subquery result should contain only one column, otherwise
an exception is thrown.

It may happen that a subquery has to be executed twice because
2 columns from the other table are needed. E.g.
\begin{verbatim}
  SELECT FROM maintable WHERE any(time >=
      [SELECT starttime FROM othertable WHERE windspeed < 5]
                               && time <=
      [SELECT endtime FROM othertable WHERE windspeed < 5])
\end{verbatim}
In this case the other table contains the time range for each windspeed.
For big tables it is expensive to execute the subquery twice.
A better solution
is to store the result of the subquery in a temporary table and reuse it.
\begin{verbatim}
  SELECT FROM othertable WHERE windspeed < 5 GIVING tmptab
  SELECT FROM maintable WHERE any(time >=
      [SELECT starttime FROM tmptab]
                               && time <=
      [SELECT endtime FROM tmptab])
\end{verbatim}
However, this has the disadvantage that the table \texttt{tmptab}
still exists after the query and has to be deleted explictly by the
user. Below a better solution for this problem is shown.

TaQL has a few extensions to support tables better,
in particular the AIPS++ measurement sets.
\begin{enumerate}
\item
The temporary problem above can be circumvented by using the
ability to use a \texttt{SELECT} expression in the \texttt{FROM}
clause. E.g.
\begin{verbatim}
  SELECT FROM maintable,
      [SELECT FROM othertable WHERE windspeed < 5] tmptab
      WHERE any(time >= [SELECT starttime FROM tmptab]
             && time <= [SELECT endtime FROM tmptab])
\end{verbatim}
However, below a even nicer solution is given. 

\item
The time range problem above can be solved elegantly by using
a set as the result of the subquery. Instead of a table name,
it is possible to give an expression in the GIVING clause (as mentioned
in \htmlref{section 3.8}{TAQL:GIVING}). E.g.
\begin{verbatim}
  select from MY.MS where TIME in
      [select FROM OTHERTABLE where WINDSPEED < 5
           giving [TIME-INTERVAL/2 =:= TIME+INTERVAL/2]]
\end{verbatim}
The set expression in the GIVING clause is filled with the
results from the subquery and used in the main query. So if
the subquery results in 5 rows, the resulting set contains 5
intervals. Thereafter the resulting intervals are sorted and combined
where possible. In this way the minimum number of intervals have to be
examined by the main query.

\item
In AIPS++ the other table will often be the name of a subtable,
which is stored in a table or column keyword of the main table.
The standard \htmlref{keyword syntax}{TAQL:KEYWORDS} can be used
to indicate that the other table is the table in the given keyword.
Note that for a table keyword the \texttt{::} part has to be given,
otherwise the name is treated as an ordinary table name. E.g.
\begin{verbatim}
  select from MY.MS where TIME in
      [select TIME from ::WEATHER where WINDSPEED < 5]
\end{verbatim}
In this example the other table is a subtable of table \texttt{my.ms}.
Its name is given by keyword \texttt{WEATHER} of \texttt{my.ms}.

\item
Often the result of a query on a subtable of a measurement set is
used to select columns from the main table. However, several
subtables do not have an explicit key, but use the row number as
an implicit key. The function \texttt{ROWID()} can be used to
return the row number as the subtable query result. E.g.
\begin{verbatim}
  select from MY.MS where DATA_DESC_ID in
      [select from ::DATA_DESCRIPTION where
         SPECTRAL_WINDOW_ID in [0,2,4] giving [ROWID()]] 
\end{verbatim}
Note that the function \texttt{ROWNUMBER} cannot be used here,
because it will give the row number in the selection and not
(as \texttt{ROWID} does) the row number in the original table.
Furthermore, \texttt{ROWID} gives a 0-relative row number which is
needed to be able to use it as a selection criterium on the 0-relative
values in the measurement set.
\end{enumerate}


\section{Some further remarks}
\subsection{Optimization}
A lot of development work can be done to improve the query optimization.
At this stage only a few simple optimizations are done.
\begin{itemize}
\item Constant subexpressions are calculated only once. E.g.
\\in \texttt{COL*sin(180/pi)} the part \texttt{sin(180/pi)} is
evaluated once.
\item If a subquery generates intervals of reals or dates, overlapping
intervals are combined and eliminated. E.g.
\begin{verbatim}
  select from GER.MS where TIME in [select from ::POINTING where
   sumsqr(DIRECTION[1])>0 giving [TIME-INTERVAL/2=:=TIME+INTERVAL/2]]
\end{verbatim}
can generate many identical or overlapping intervals. They are
sorted and combined where possible to make the set as small as possible.
\end{itemize}

TaQL does not recognize common subexpressions nor does it attempt to
optimize the query.
It means that the user can optimize a query by specifying the expression
carefully. When using operator $\mid\mid$ or \&\&,
attention should be
paid to the contents of the left and right branches. Both operators
evaluate the right branch only if needed, so if possible the left branch
should be the shortest one, i.e., the fastest to evaluate.

The user should also use functions, operators, and subqueries in a careful way.
\begin{itemize}

\item
\texttt{SQUARE(COL)} is (much) faster than \texttt{COL}\verb+**+\texttt{2}
or \texttt{POW(COL,2)}, because SQUARE is faster.
It is also faster than \texttt{COL*COL}, because it accesses column
\texttt{COL} only once.
\\Similarly \texttt{SQRT(COL)} is faster than \texttt{COL}\verb+**+\texttt{0.5}
or \texttt{POW(COL,0.5)}

\item
\texttt{SQUARE(U) + SQUARE(V) $<$ 1000}\verb+**+\texttt{2} is considerably faster
than
\\\texttt{SQRT(SQUARE(U) + SQUARE(V)) $<$ 1000}, because the
\texttt{SQRT} function does not need to be evaluated for each row.

\item
\texttt{TIME IN [$0<:<4$]} is faster than
\texttt{TIME$>$0 \&\& TIME$<$4}, because in the first way the column is
accessed only once.

\item
Returning a column from a subquery can be done directly or as a
set. E.g.
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT time FROM othertable WHERE windspeed < 5]
\end{verbatim}
could also be expressed as
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT FROM othertable WHERE windspeed < 5 GIVING [time]]
\end{verbatim}
The latter (as a set) is slower. So, if possible, the column should
be returned directly. This is also easier to write.
\\An even more important optimization for this query is writing it as:
\begin{verbatim}
  SELECT FROM maintable WHERE time IN
      [SELECT DISTINCT time FROM othertable WHERE windspeed < 5]
\end{verbatim}
Using the DISTINCT qualifier has the effect that duplicates are
removed which often results in a much smaller set.

\item
Testing if a subquery contains at least N elements can be done in two
ways:
\begin{verbatim}
  count([select column from table where expression]) >= N
and
  exists (select from table where expression limit N)
\end{verbatim}
The second form is by far the best, because in that case the subquery
will stop the matching process as soon as N matching rows are found.
The first form will do the subquery for the entire table.
\\Furthermore in the first form a column has to be selected, which is
not needed in the second form.

\item
Sometimes operator \texttt{IN} and function \texttt{ANY} can be used to test
if an element in an array matches a value. E.g.
\begin{verbatim}
  WHERE any(arraycolumn == value)
and
  WHERE value IN arraycolumn
\end{verbatim}
give the same result.
Operator \texttt{IN} is faster because it stops when it finds a
match. If using \texttt{ANY} all elements are compared first and thereafter
\texttt{ANY} tests the resulting bool array.

\item
It was already shown in the \htmlref{section 4.8}{TAQL:INDEXING}
that indexing arrays should be done with care.
\end{itemize}


\section{\label{TAQL:MODIFYING}Modifying a table}
Usually TaQL will be used to get a subset from a table. However, as
described in the first sections, it can also be used to change the
contents of a table using the UPDATE, INSERT, or DELETE command.
Note that a table has to be writable, otherwise those commands
exit with an error message.

\subsection{UPDATE}
\begin{verbatim}
  UPDATE table_list SET update_list [WHERE ...] [ORDERBY ...]
                                    [LIMIT ...] [OFFSET ...]
\end{verbatim}
updates selected rows in the selected part of the table.
\\\texttt{update\_list}
is a comma-separated list of \texttt{column=expression} parts.
Each part tells to update the given column using the
expression. Both scalar and array columns are supported.
E.g.
\begin{verbatim}
  UPDATE vla.ms SET ANTENNA1=ANTENNA1-1, ANTENNA2=ANTENNA2-1
\end{verbatim}
to make the antenna numbers zero-based if accidently they were
written one-based.
\\If an array gets an array value, the shape of the array can be
changed (provided it is allowed for that table column).
Arrays can also be updated with a scalar value causing all elements
in the array to be set to that scalar value.

It is also possible to update part of an array using
\htmlref{array indexing}{TAQL:INDEXING}. E.g.
\begin{verbatim}
  UPDATE vla.ms SET FLAG[1,1]=T
  UPDATE vla.ms SET FLAG[1,]=T
\end{verbatim}
The first example sets only the first array element, while the second
one sets an entire row in the array. The second example also
shows that it is possible to set an array to a scalar value.

Type promotion and demotion will be done as much as possible.
For example, an integer column can get the value of a double
expression (the result will be truncated).
\\Unit conversion will be done as needed. Thus if a column and
its expression have different units, the expression result is automatically
converted to the column's unit. Of course, the units must be of the
same type to be able to convert the data.

Note that if multiple \texttt{column=expression} parts are given,
the columns are changed in the order as specified in the update-list.
It means that if an updated column is used in an expression for
a later column, the new value is used when evaluating the
expression. E.g. in
\begin{verbatim}
  UPDATE vla.ms SET DATA=DATA+1, SUMD=sum(DATA)
\end{verbatim}
the \texttt{SUMD} update uses the new \texttt{DATA} values.
    

\subsection{INSERT}
The \texttt{INSERT} command adds rows to the table. It can take two forms:
\begin{verbatim}
  INSERT INTO table_list [(column_list)] VALUES (expr_list)
  INSERT INTO table_list [(column_list)] SELECT_command
\end{verbatim}
The first form adds one row to the table and puts the values given in
the expression list into the columns given in the column list.
If the column list is not given, it defaults to all stored columns in
the table in the order as they appear in the table description.
Each expression in the expression list can be as complex as needed;
for example, a subquery can also be given. Note that a subquery is
evaluated before the new row is added, so the new row is not taken
into account if the subquery is done on the table being modified.
\\It should be clear that the number of columns has to match the
number of expressions.
\\Note that row cells not mentioned in the column list,
are not written, thus may contain rubbish.
\\The data types and units of expressions and columns have to conform in
the same way 
as for the UPDATE command; values have to be convertible
to the column data type and unit.
\\For example:
\begin{verbatim}
  INSERT INTO my.ms (ANTENNA1,ANTENNA2) VALUES (0,1)
\end{verbatim}
adds one row, puts 0 in ANTENNA1 and 1 in ANTENNA2.

The second form evaluates the SELECT command and copies the rows
found in the selection to the table being modified (which is given
in the INTO part).
The columns used in the modified table are defined in the column list.
As above, they default to all stored columns. The columns used in the
selection have to be defined in the column-list part of the SELECT command.
They also default to all stored columns.
\\For example:
\begin{verbatim}
  INSERT INTO my.ms select FROM my.ms
\end{verbatim}
appends all rows and columns of \texttt{my.ms} to itself.
Please note that only the original number of rows is copied.
\begin{verbatim}
  INSERT INTO my.ms (ANTENNA1,ANTENNA2) select ANTENNA2,ANTENNA1
   FROM other.ms WHERE ANTENNA1>0
\end{verbatim}
copies rows from \texttt{other.ms} where ANTENNA1$>$0. It swaps the
values of ANTENNA1 and ANTENNA2. All other columns are not written,
thus may contain rubbish.

\subsection{DELETE}
\begin{verbatim}
  DELETE FROM table_list
    [WHERE ...] [ORDERBY ...] [LIMIT ...] [OFFSET ...]
\end{verbatim}
deletes some or all rows from a table.
\begin{verbatim}
  DELETE FROM my.ms WHERE ANTENNA1>13 OR ANTENNA2>13
\end{verbatim}
deletes the rows matching the WHERE expression.
\\If no selection is done, all rows will be deleted.
\\It is possible to specify more than one table in the FROM clause to
be able to use, for example, keywords from other tables.
Rows will be deleted from the first table mentioned in the FROM part.

\section{\label{TAQL:CREATETABLE}Creating a new table}
TaQL can be used to create a new table. The data managers to be used
can be given in full detail.

The syntax is:
\begin{verbatim}
  CREATE TABLE tablename colspec DMINFO datamans
\end{verbatim}
The columns are defined in the \texttt{colspec} part. If not given, an
empty table is created.
\\Data managers can be defined in the \texttt{datamans} part.

The \texttt{colspec} part can optionally be enclosed in square
brackets or parentheses (for SQL compatibility).
It is a comma separated list of column specifications.
Each specification looks like:
\begin{verbatim}
  columnname datatype [NDIM=n, SHAPE=[d1,d2,...], UNIT='s',
                       DMTYPE='s',DMGROUP='s',COMMENT='s']
\end{verbatim}
The possible data type strings are given in
\htmlref{section 4.1}{TAQL:DATATYPESTRING}.
The part enclosed in square brackets is optional. Zero or more of
these keywords can be used. It makes it possible
to define array columns and/or default data manager to be used.
The square brackets are optional if only one such keyword is used.
\begin{itemize}
\item \texttt{NDIM=n} defines if the column contains scalars or arrays.
\\A negative value means a scalar (unless shape is also given).
A value 0 means an array of any dimensionality. A positive value means
an array with the given dimensionality.
\item \texttt{SHAPE=[d1,d2,...]} makes it possible to define the exact
array shape.
\\If given and if NDIM is positive, they should be consistent.
\item \texttt{UNIT='s'} defines the unit to be used for the column.
\\It can be any valid unit (simple or compound). It is a string,
thus must always be enclosed in quotes. 
\item \texttt{COMMENT} defines comments for the column.
\\It has a string value, thus quotes
have to be used.
\item \texttt{DMTYPE, DMGROUP} are rather specific and are for the expert user.
\\They have a string value, thus quotes
have to be used.
\end{itemize}

The \texttt{dataman} part makes it possible for the expert user to
define the data managers to be used by columns. It is a comma separated
list of data manager specifications looking like the output of the
\texttt{table.getdminfo} command in Python or Glish.
Each specification has to be enclosed in square brackets.
For example:
\begin{verbatim}
  dminfo [NAME="ISM1",TYPE="IncrementalStMan",COLUMNS=["col1"]],
         [NAME="SSM1",TYPE="StandardStMan",
          SPEC=[BUCKETSIZE=1000],COLUMNS=["col2","col3"]]
\end{verbatim}
The case of the keyword names used (e.g. NAME) is important.
They have to be given in uppercase. The following keywords can be
given:
\\\texttt{NAME} defines the unique name of the data manager.
\\\texttt{TYPE} defines the type of data manager.
\\\texttt{SPEC} is a list of keywords giving the characteristics of the
data manager. This is highly data manager type specific. If shapes
have to be given here, they always have to be in AIPS++ format,
thus in Fortran order. TaQL has no knowledge about these internals.
\\\texttt{COLUMNS} is a list of column names defining all columns that
have to be bound to the data manager.


\section{\label{TAQL:COUNTING}Counting in a table}
TaQL does not have a GROUPBY command (yet). However, it has a command
that can be used to count the number of occurrences in a table.

The exact syntax is:
\begin{verbatim}
  COUNT column-list FROM table-list [WHERE expression]
\end{verbatim}
It counts the number of rows for each unique tuple in the column list
of the table (after the possible WHERE selection is done).
For example:
\begin{verbatim}
  COUNT TIME FROM my.ms
\end{verbatim}
counts the number of rows per timestamp.
\begin{verbatim}
  COUNT ANTENNA1,ANTENNA2 FROM my.ms
\end{verbatim}
counts the number of rows per baseline.

As in the other TaQL commands a column in the column list can be any
expression, but that will be slower than straight columns.

\section{\label{TAQL:CALCULATING}Calculations on a table}
TaQL can be used to get derived values from a table by means of an
expression. The expression can result in any data type and value type.
For example, if the expression uses an array column, the result might
be a vector of arrays (an array for each row). If the expression uses
a scalar column, the result might be a vector of scalars or even a
single scalar if a reduction function like SUM is used.

The exact syntax is:
\begin{verbatim}
  CALC [FROM table_list CALC] expression
\end{verbatim}
The part in square brackets can be omitted if no column is (directly)
used in the expression. The examples will make clear what that means.

\begin{verbatim}
  CALC 1in cm
\end{verbatim}
is a simple expression not using a table. It shows how the CALC
command can be used as a desk calculator to convert 1 inch to cm.

\begin{verbatim}
  CALC FROM mytable CALC mean(column1+column2)
\end{verbatim}
gives a vector of scalars containing the mean per row.

\begin{verbatim}
  CALC sum([SELECT FROM mytable GIVING [mean(column1+column2)]])
\end{verbatim}
gives a single scalar giving the sum of the means in each row.
Note that in this command the CALC command does not need the FROM
clause, because it does not use a column itself. Columns are only
used in the nested query which has a FROM clause itself.

\section{Examples}
\subsection{\label{TAQL:SELEXAMPLES}Selection examples}
Some examples are given starting with simple ones.
\subsubsection{Reference table results}
The result of the following queries is a reference table, because no
expressions have been given in the column-list. This will be the most
common case when using TaQL.
\begin{description}
  \item[] \texttt{ SELECT FROM mytable WHERE column1 $>$ 0 }
    \\selects the rows in which the value of column1 $>$ 0

  \item[] \texttt{ SELECT column0,column1 FROM mytable }
    \\selects 2 columns from the table.

  \item[] \texttt{ SELECT column0,column1 FROM mytable WHERE column1$>$0 }
    \\is a combination of the previous selections.

  \item[] \texttt{ SELECT FROM [SELECT FROM mytable ORDERBY column0 DESC] }
    \\\texttt{ WHERE rownumber()$<=$10 }
    \\selects the 10 highest values of \texttt{column0}.

  \item[] \texttt{ SELECT FROM mytable ORDERBY column0 DESC LIMIT 10 }
    \\is a more elegant solution using the newer LIMIT clause.

  \item[] \texttt{ SELECT FROM mytable ORDERBY column0 DESC GIVING outtable }
    \\\texttt{ SELECT FROM outtable WHERE rownumber()$<=$10 }
    \\is the SQL-like solution for the previous problem.
    It is less elegant, because it requires two steps.

  \item[] \texttt{ SELECT FROM mytable WHERE column0 IN }
    \\\texttt{ [SELECT column0 FROM mytable ORDERBY column0 DESC][1:10] }
    \\is similar to above, but can select more rows if there happen
    to be several equal values.

  \item[] \texttt{ SELECT FROM some.MS WHERE }
    \\\texttt{ near(MJD(1999/03/30/17:27:15), TIME) }
    \\selects the rows with the given time from a MeasurementSet.
    \\Note that the TIME is stored in seconds, but will automatically
	be converted to days.

   \item[] \texttt{ SELECT FROM some.MS where TIME in }
     \\\texttt{ [\{MJD(1999/03/30/17:27:15),MJD(1999/03/30/17:29:15)\}] }
     \\selects the rows in the given closed time interval.

   \item[] \texttt{ SELECT FROM some.MS where TIME in }
     \\\texttt{ [MJD(1999/03/30/17:27:15),MJD(1999/03/30/17:29:15)] }
     \\selects the rows having one of the given times.
     \\Note the difference with the previous example where an interval
     was given. Here a set of two individual time values is given.

  \item[] \texttt{ SELECT FROM resource.table WHERE}
     \\\texttt{any(PValues == pattern('synth*'))}
     \\selects the rows in which an element in array
     \texttt{PValues} matches the given regular expression.

  \item[] \texttt{ SELECT FROM table WHERE ntrue(flags) >= 3}
     \\selects rows where at least 3 elements of array \texttt{flags}
     are set.

  \item[] \texttt{ SELECT FROM book.table WHERE nelements(author) > 1}
     \\selects books with more than 1 author.

  \item[] \texttt{ SELECT FROM my.ms WHERE
         any(ANTENNA1==[0,0,1] \&\& ANTENNA2==[1,3,2])}
     \\selects the antenna pairs (baselines) 0-1, 0-3, and 1-2.
     \\Note that the two comparisons result in a boolean vector. If
       a bool in the and-ed vectors is true, that baseline matches.

  \item[] \texttt{ SELECT FROM mytable WHERE}
     \\\texttt{ cos(0d1m) $<$
         sin(52deg) * sin(DEC) + cos(52deg) * cos(DEC) *
         cos(3h30m - RA) }
     \\selects observations with an equatorial position (in say J2000)
     inside a cone with a radius of 1 arcmin around (3h30m, 52deg).
     To find them the condition DISTANCE$<=$RADIUS must be fulfilled,
     which is equivalent to COS(RADIUS)$<=$COS(DISTANCE).

  \item[] \texttt{ SELECT FROM mytable WHERE}
     \\\texttt{ [RA,DEC] INCONE [3h30m, 52deg, 0d1m] }
     \\does the same as above in an easier (and faster) way.

  \item[] \texttt{ SELECT FROM mytable WHERE object == pattern("3C*") \&\&}
     \\\texttt{ [RA,DEC] INCONE [3h30m, 52deg, 0d1m] }
     \\finds all 3C objects inside that cone.

  \item[] \texttt{ select from MY.MS where DATA\_DESC\_ID in}
      \\\texttt{[select from ::DATA\_DESCRIPTION where}
      \\\texttt{SPECTRAL\_WINDOW\_ID in [0,2,4] giving [ROWID()]]}
      \\finds all rows in a measurement set matching the given
      spectral windows.

  \item[] \texttt{ select from MY.MS where TIME in}
      \\\texttt{[select from ::SOURCE where REST\_FREQUENCY $<$ 180000000.}
      \\\texttt{giving [TIME-INTERVAL/2 =:= TIME+INTERVAL/2]]}
      \\finds all rows in a measurement set observing sources with a
      rest frequency less than 180 Mhz.

  \item[] \texttt{ select from MS,}
      \\\texttt{[select from MS where sumsqr(UVW[1:2]) < 625] as TIMESEL}
      \\\texttt{ where TIME in [select distinct TIME from TIMESEL]}
      \\\texttt{   \&\& any([ANTENNA1,ANTENNA2] in [select from TIMESEL giving}
      \\\texttt{                      [iif(UVW[3] < 0, ANTENNA1, ANTENNA2)]])}
      \\finds all antennas which are shadowed at a given time.
      \\The query in the FROM command finds all rows where an antenna
      is shadowed (i.e. its UV-distance less than 25 meters) and
      creates a temporary table. This selection is done in the FROM
      command, otherwise two 2 equal selections are needed in the main
      WHERE command.
      
  \item[] \texttt{ select from MS}
      \\\texttt{where DATA\_DESC\_ID in [select from ::DATA\_DESCRIPTION}
      \\\texttt{where SPECTRAL\_WINDOW\_ID in [select from ::SPECTRAL\_WINDOW}
      \\\texttt{where NET\_SIDEBAND==1 giving [ROWID()]] giving [ROWID()]]}
      \\finds all rows in the MeasurementSet with the given
      NET\_SIDEBAND.
      \\The MeasurementSet uses a table to map spectral-window-id to
      data-desc-id. Hence two nested subqueries are needed.
\end{description}

\subsubsection{Plain table results}
The following examples result in a plain table, thus in a deep copy of
the query results, because the column-list contains an expression or
a data type.
\begin{description}
  \item[] \texttt{ SELECT column0+column1 FROM mytable }
    \\creates a table of 1 column with name Col\_1. Its data type
      is on the expression data type.

  \item[] \texttt{ SELECT column0+column1 Res I4 FROM mytable }
    \\creates a table of 1 column with name \texttt{Res}.
      Its data type is a 4 byte signed integer.

  \item[] \texttt{ SELECT colx colx R4 FROM mytable }
    \\creates a table of 1 column with name \texttt{colx}.
      The sole purpose of this selection is to convert the data type
      of the column.

  \item[] \texttt{ SELECT means(DATA,2) AS DATA\_MEAN C4 FROM my.ms }
    \\creates a table of 1 column with name \texttt{DATA\_MEAN}.
      Column DATA in a AIPS++ MeasurementSet is a 2-dimensional array
      with axes polarization and frequency. This command calculates
      and stores the mean in each polarization.
      If no data type was given, the means would have been stored
      as double precision complex (which is the expression data type).
      \\Note that this command is valid when using glish style; in
      python style \texttt{MEANS(DATA,0)} should be used.

\end{description}

\subsection{\label{TAQL:MODEXAMPLES}Modification examples}
\begin{description}
  \item[] \texttt{ update MY.MS set VIDEO\_POINT=MEANS(DATA,2)
                   where isdefined(DATA) }
      \\sets the VIDEO\_POINT of each correlation to the mean of the
      DATA for that correlation. Note that the 2 indicates averaging over
      the second axis, thus the frequency axis.

  \item[] \texttt{ update MY.MS set FLAG\_ROW=T where isdefined(FLAG) \&\& all(FLAG)}
      \\sets FLAG\_ROW in the rows where the entire FLAG array is set.

  \item[] \texttt{ delete from MY.MS where FLAG\_ROW}
      \\deletes all flagged rows.

  \item[] \texttt{ insert into MY.MS select from OTHER.MS where !FLAG\_ROW}
      \\copies all unflagged rows from OTHER.MS to MY.MS.

  \item[] \texttt{ insert into MY.MS/DATA\_DESCRIPTION}
          \\\texttt{(SPECTRAL\_WINDOW\_ID,POLARIZATION\_ID,FLAG\_ROW)}
          \\\texttt{values (1,0,F)}
      \\adds a row to the DATA\_DESCRIPTION subtable and initializes it.

\end{description}

\subsubsection{\label{TAQL:RUNEXAMPLES}Applying running median to an image}
The following piece of Python code shows how a running median can 
be applied to an AIPS++ image.
\begin{verbatim}
  t1 = tablecommand ('update my.imgd set map =
                         map - runningmedian(map,25,25)')
\end{verbatim}
First the image is copied and thereafter the running medians are
subtracted from the data in the copy. It uses a half window size 
of 25x25, thus the full window is 51x51.
\\When doing this, one should take care that in case of a spectral
line cube the image is not too large, otherwise it won't fit in
memory. If too large, it should be done in chunks like:
\begin{verbatim}
  t1 = tablecommand ('update my.imgd set map[,,sc:ec,] =
                         map[,,sc:ec,] -
                         runningmedian(map[,,sc:ec,],25,25)')
\end{verbatim}
where \texttt{sc} and \texttt{ec} are the start and end frequency
channel.
In this example it is assumed that the axes of the image are RA, DEC,
freq, Stokes.
\\Note that \texttt{imagecalc} is used to copy the image. It might
also be done with table functions, but \texttt{imagecalc} has the
great advantage that it also works on FITS and Miriad images.

\subsection{\label{TAQL:CREAEXAMPLES}Table creation examples}
\begin{description}
  \item[] \texttt{ create table mytab (col1 I4, col2 I4, col3 R8) }
      \\creates table \texttt{mytab} of 3 scalar columns.

  \item[] \texttt{ create table mytab }
      \\creates an empty table.

  \item[] \texttt{ create table mytab colarr R4 ndim=0 }
      \\creates a table of 1 array column with arbitrary dimensionality.

  \item[] \texttt{ create table mytab colarr R4 [shape=[4,128],}
          \texttt{ dmtype='TiledColumnStMan'] }
      \\creates a table of 1 array column with the given shape.
        The column is stored with the TiledColumnStMan storage manager
        using its default settings.

  \item[] \texttt{ create table mytab colarr R4 shape=[4,128] }
          \\\texttt{   dminfo [TYPE='TiledColumnStMan', NAME='TCSM', }
          \\\texttt{           SPEC=[DEFAULTTILESHAPE=[4,32,64]], }
          \texttt{           COLUMNS=['colarr']]}
      \\creates a table of 1 array column with the given shape.
        The column is stored with the TiledColumnStMan storage manager
        using the given settings.
\end{description}

\subsection{\label{TAQL:CALCEXAMPLES}Calculation examples}
\begin{description}
  \item[] \texttt{ calc 1+2 }
      \\uses TaQL as a desktop calculator.

  \item[] \texttt{ calc 7-Apr-2007 - 20-Nov-1979 }
      \\calculates the number of days between these dates.

  \item[] \texttt{ calc (1-1-2006 - 1-1-1950)\%365 }
      \\calculates the number of leap days in this time span.

  \item[] \texttt{ calc sum([select from MY.MS giving [ntrue(FLAG)]]) }
      \\determines the total number of flags set in the measurement set.

  \item[] \texttt{ calc from [select from MY.MS where ANTENNA1==0] }
          \\\texttt{ calc mean(abs(DATA)) }

        calculates for each row the mean of the data for the selected
        subset of the measurement set.

  \item[] \texttt{ calc mean([select from MY.MS where ANTENNA1==0 }
          \\\texttt{giving [mean(abs(DATA))]]) }

        looks like the previous example. It, however, calculates the
        mean of the mean of the data in each row for the selected
        subset of the measurement set.

  \item[] \texttt{ calc max([select from MY.MS where isdefined(DATA) }
          \\\texttt{ giving [max(abs(VIDEO\_POINT-MEANS(DATA,2)))]]) }

        shows the maximum absolute difference between VIDEO\_POINT of
        each correlation and the mean of the DATA for that correlation.
        Note that the 2 indicates averaging over the second axis,
        thus the frequency axis.

\end{description}


\section{\label{TAQL:GLISHPC}Interface to TaQL}
User and a programmer interfaces to TaQL are available.
The program \texttt{taql} and some Python and Glish functions form the
user interface, while C++ classes and functions
form the programmer interface.

\subsection{Python interface \texttt{pyrap}}
  The main TaQL interface in Python is formed by the
  \htmladdnormallink{\texttt{query}}
  {../../../pyrap/docs/pyrap_tables.html\#pyrap.tables.table.query} function in module
  \htmladdnormallink{\texttt{table}}{../../../pyrap/docs/pyrap_tables.html}.
  The function can be used
  to compose and execute a TaQL command using the various (optional)
  arguments given to the \texttt{query} function. E.g.
\begin{verbatim}
   tab = table('mytable')
   seltab1 = tab.query ('column1 > 0')
   seltab2 = seltab1.query (query='column2>5',
                            sortlist='time',
                            columns='column1,column2',
                            name='result.tab')
\end{verbatim}
  The first command opens the table \texttt{mytable}.
  The second command does a simple query resulting in a temporary
  table. That temporary table is used in the next command resulting in
  a persistent table. The latter function call is transformed to
  the TaQL command:
  \\\texttt{SELECT column1,column2 FROM \$1 WHERE column2>5}
  \\\texttt{ORDERBY time GIVING result.tab}
  \\During execution \$1 is replaced by table \texttt{seltab1}.
  \\Note that the \texttt{name} argument
  generates the \texttt{GIVING} part to make the result persistent.

  The functions \texttt{sort} and \texttt{select} exist as convenience
  functions for a query consisting of a sort or  column selection
  only. Both functions have an optional second \texttt{name} parameter
  to make the result persistent.
\begin{verbatim}
   t1 = tab.sort ('time')
   t1 = tab.select ('column1,column2')
\end{verbatim}

  The \texttt{calc} function can be used to execute a TaQL
  \texttt{calc} command on the current table. The result can be kept
  in a variable. For example, the following returns a vector containing
  the median of the \texttt{DATA} column in each table row:
\begin{verbatim}
  med = t.calc ('median(DATA)')
\end{verbatim}

  It is possible to embed Python variables and expressions in a TaQL
  command using the syntax \texttt{\$variable} and
  \texttt{\$(expression)}. A variable can be a standard numeric or
  string scalar or vector. It can also be a table tool.
  An expression has to result in a numeric or string scalar or vector.
  E.g
\begin{verbatim}
  from pyrap.tables import *
  tab = table('mytable')
  coldata = tab.getcol ('col');
  colmean = sum(coldata) / len(coldata);
  seltab1 = tab.query ('col > $colmean')
  seltab2 = tab.query ('col > $(sum(coldata)/len(coldata))')
  seltab3 = tab.query ('col > mean([SELECT col from $tab])')
\end{verbatim}
  These three queries give the same result.
  \\The substitution mechanism is described in more detail in
  \htmladdnormallink{pyrap.util}{../../../pyrap/docs/pyrap_util.html}.

  The other function that can be used is
  \htmladdnormallink{taql}{../../../pyrap/docs/pyrap_tables.html\#pyrap.tables.taql}
  (or its synonym \texttt{tablecommand}).
  The full TaQL command has to be given to that command. The result is
  a table object. E.g.
\begin{verbatim}
  t = taql('select from GER.MS where ANTENNA1==1');
\end{verbatim}  

  By default, these commands will use the Python style for a TaQL
  statement. The \texttt{style} argument can be used
  to choose another style.

\subsection{Interface to Glish}
  The Glish interface is formed by script \texttt{table.g}.
  By default, it will use the Glish style for a TaQL
  statement.
  For example:
\begin{verbatim}
  include 'table.g'
  tab := table('mytable')
  seltab1 := tab.query ('column1 > 0')
  seltab2 := seltab1.query (query='column2>5',
                            sortlist='time',
                            columns='column1,column2',
                            name='result.tab')
  t := tablecommand('select from GER.MS where ANTENNA1==1',
                    style='');    # use default (glish) style
  med := t.calc ('median(DATA)')
\end{verbatim}

\subsection{Program \texttt{taql}}
  The program \texttt{taql} makes it possible to execute TaQL commands
  from the shell. 
  \\The first way to run it is by giving the TaQL command as a single
  (quoted) argument. It will execute the command and exit.
  \\The other way is to run it interactively by giving no command
  argument. It will run until the user stops via the
  command \texttt{exit}, \texttt{quit}, or \texttt{q} or by giving
  ctrl/D. A few types of commands can be given:
  \begin{itemize}
    \item \texttt{help}, \texttt{h} or \texttt{?} shows brief help information.
    \item A full TaQL command. If no GIVING part is given, the
      resulting table is not kept. It shows the number of matching rows.
    \item A full TaQL command preceeded by \texttt{varname=}, where
      \texttt{varname} is the name under which the resulting table is
      kept in this session. Thus the result is not a persistent table
      (unless GIVING was given), but it is kept temporarily.
      The name can be used in subsequent commands like
      \texttt{SELECT FROM \$varname}.
    \item \texttt{varname=} without a further command removes the
      temporary result.
    \item \texttt{varname} shows the number of rows in the temporary
      result. It can be followed by one or more question marks to show
      the column names and details about them.
      \\Note that if an unknown varname is given, it is treated as a
      TaQL command resulting in a parse error.
  \end{itemize}
  If columns are selected in the TaQL command, their values are
  printed. For arrays, only the data type and shape is printed. Also the result of
  CALC commands is printed. Otherwise only the number of selected (or
  updated or deleted) rows is printed.

\subsection{C++ interface}
The C++ programmer can use TaQL commands and expressions at various levels,
\subsubsection{TaQL query string}
    The function \texttt{tableCommand} in
    \htmladdnormallink{TableParse.h}
    {../html/classcasa_1_1TableParse.html}
    can be used to execute a TaQL command. The result is a
    \htmladdnormallink{Table}{../html/classcasa_1_1Table.html}
    object. E.g.
\begin{verbatim}
  Table seltab1 = tableCommand
         ("select from mytable where column1>0");
  Table seltab2 = tableCommand
         ("select column1,column2 from $1 where column2>5"
          " orderby time giving result.tab", seltab1);
\end{verbatim}
    These examples do the same as the Glish ones shown above.
    \\Note that in the second function call the table name
    \texttt{\$1} is replaced by the object \texttt{seltab1}
    passed to the function.
    \\There is no style argument, so if an explicit style is needed it
    should be the first part of the TaQL statement. Note that no style
    defaults to the Glish style.

\subsubsection{Expression string}
    The function \texttt{parse} in
    \htmladdnormallink{RecordGram.h}
    {../html/classcasa_1_1RecordGram.html}
    can be used to parse a TaQL expression. The result is a
    \htmladdnormallink{TableExprNode}{../html/classcasa_1_1ExprNode.html}
    object that can be evaluated for each row in the table. E.g.
\begin{verbatim}
  Table tab("mytable");
  TableExprNode expr = RecordGram::parse (tab, "column1>0");
  Table seltab1 = tab(expr);
\end{verbatim}
    The example above does the same as the first example in the previous
    section. There are, however, better ways to use this functionality.
\begin{verbatim}
  Table tab("somename");
  TableExprNode expr = RecordGram::parse (tab, "ANTENNA1=1");
  for (uInt row=0; row<tab.nrow(); ++row) {
    if (expr.getBool(row)) {
      // expression is true for this row, so do something ...
    }
  }
\end{verbatim}
    The example above shows a boolean scalar expression, but it can also be
    a numeric expression or an array expression as shown in the example
    below.
    Note that TaQL expression results have data type Bool, Int64, Double,
    DComplex, String, or MVTime.
\begin{verbatim}
  TableExprNode expr = RecordGram::parse (tab, "abs(DATA)");
  Array<Double> data;
  for (uInt row=0; row<tab.nrow(); ++row) {
    expr.get (row, data);
  }
\end{verbatim}

\subsubsection{Expression classes}
    The other expression interface is a true C++ interface having the
    advantage that C++ variables can be used directly. Class
    \htmladdnormallink{Table}{../html/classcasa_1_1Table.html}
    contains functions to sort a table or to select columns or rows.
    When selecting rows class \htmladdnormallink{TableExprNode}
    {../html/classcasa_1_1TableExprNode.html} (in ExprNode.h)
    has to be used to
    build a WHERE expression which can be executed by the overloaded
    function operator in class \texttt{Table}. E.g.
\begin{verbatim}
  Int limit = 0;
  Table tab ("mytable");
  Table seltab = tab(tab.col("column1") > limit);
\end{verbatim}
    does the same as the first example shown above.
    See classes \htmladdnormallink{Table}
    {../html/classcasa_1_1Table.html},
    \htmladdnormallink{TableExprNode}
    {../html/classcasa_1_1TableExprNode.html}, and
    \htmladdnormallink{TableExprNodeSet}
    {../html/classcasa_1_1TableExprNodeSet.html} for more
    information on how to construct a WHERE expression.

\section{\label{TAQL:UDFWRITE}Writing user defined functions}
A user defined function has to be written as a class in C++
derived from the abstract base class
\htmladdnormallink{UDFBase}{../html/classcasa_1_1UDFBase.html}.
The documentation of this base class describes how to write a
UDF. Furthermore one can look at class
\htmladdnormallink{UDFMSCal}{../html/classcasa_1_1UDFBMSCal.html}
that contains the UDFs described in subsection
\htmlref{User defined functions}{TAQL:UDF}.

Note that a class can contain multiple UDFs as done in UDFMSCal.
Also note that a single UDF can operate on multiple data types which
is similar to a function like \texttt{min} that can operate on scalars
and arrays of different data types.

TaQL finds a UDF by looking in a dictionary that maps the UDF name
to a function constructing an  object of the UDF class. If not found,
it tries to load the shared library with the name of the library part
of the UDF (like in \texttt{derivedmscal.pa1}). If the load is successful, it calls an
initialization function in the shared library that should add all UDF
functions in the library to the dictionary. The description of the
\htmladdnormallink{UDFBase}{../html/classcasa_1_1UDFBase.html}
class shows how this should be done.

\section{Possible future developments}
In the near or far future TaQL can be enhanced by adding new
features and by doing optimizations.
\begin{itemize}
  \item Implement the GROUP BY and  HAVING clause, possibly with
    ROLLUP and CUBE.
  \item Add JOIN clause (only equi-joins).
  \item Add UNION, INTERSECTION, and DIFFERENCE.
  \item Add masked arrays.
  \item Optimize by removing an \texttt{IN} node if the righthand
    operand is empty. This cannot be done if the lefthand operand
    is variable shaped.
  \item Handle invalid subexpressions (e.g. exceeding array bounds)
    as undefined values
    which can be tested with the function ISDEFINED.
  \item Maybe functions to convert positions from one equinox or system
    to another (using the Measures system).
  \item Optimize IN if righthand is an integer bounded set by turning
    it into a boolean vector.
\end{itemize}

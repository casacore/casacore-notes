%% libraries.latex
%% $Id$
%%----------------------------------------------------
\documentstyle[11pt]{article}
%%----------------------------------------------------

\newcommand{\aipspp}{{\sc aips++ }}
\newcommand{\file}[1]{{\tt #1}}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\class}[1]{{\tt #1}}

%%----------------------------------------------------

\begin{document}

\title{\bf \aipspp Libraries Overview}
\author{James E. Horstkotte, NRAO}
\date{DRAFT 07 December 1994}
\maketitle


%===========================================================================
\section{Overview}

This section provides an overview of the \aipspp system.
It is extracted, with very minor modifications, from the Overview
chapter of the \aipspp System manual, written by Mark Calabretta,
the author of the \aipspp code management and distribution system.


%--------------------------------------------------
%\subsection{The \aipspp directory hierarchy}

In the following discussion of the \aipspp directory hierarchy we will
assume that \aipspp has been installed in directory \file{/aips++}.  This
is the preferred location, but in practice the \aipspp ``root'' directory
can reside anywhere.  The root directory is generally referred to as
\code{\$AIPSROOT} and many other directories have standard variable names.

The major subdirectories of \file{/aips++} are \file{code}
(\code{\$AIPSCODE}), \\
\file{docs} (\code{\$AIPSDOCS}), and one or more architecture--specific
subdirectories with names such as \file{sun4} and \file{ibmrs} which contain
the \aipspp system -- that is, everything needed to run \aipspp,
including executables and sharable objects.  These architecture--specific
subdirectories are referred to collectively as \code{\$AIPSARCH}.



%\subsubsection{Code directories}

The directory hierarchy beneath \file{/aips++/code}, or \code{\$AIPSCODE},
consists of a collection of packages which are contained in separate
subdirectories.  The principle package is the \file{aips} package,
which contains the source code for a class library required by all other
packages.  It also contains applications common to all areas of astronomical
data processing.  The contents of this library will be discussed in greater
detail in the second part of this paper.

The \file{dish}, \file{synthesis}, and \file{vlbi} packages contain standard
classes and applications common to single dish, aperture synthesis, and VLBI
data processing tasks from all radio telescopes.  Apart from a dependence of
the \file{vlbi} package on the \file{synthesis} package, inclusion of these
standard packages in an end--user installation is optional.

A \file{contrib} package contains source code contributed from the \aipspp
user community for redistribution with \aipspp.  If found to be generally
useful, code from the \file{contrib} package may eventually be merged into one
of the standard packages, but otherwise it is unsupported.

A \file{trial} package contains ``trial'' source code which must be shared by
several developers during its development, but which is not ready for general
release.  When the code is ready, it is moved to another standard package.

Each \aipspp consortium member is also entitled to maintain a package for
data processing applications specific to their telescope(s).  The sources for
these classes and applications reside in the consortium--specific packages:
\file{atnf}, \file{bima}, \file{drao}, \file{nfra}, \file{nral}, \file{nrao},
and \file{tifr}.  These may or may not use the standard \file{dish},
\file{synthesis}, and \file{vlbi} packages, and their installation is also
optional.

The standard \aipspp packages (\file{aips}, \file{dish}, \file{synthesis},
and \file{vlbi}) contain an \file{implement} subdirectory
which contains class header and implementation files, a \file{fortran}
subdirectory which contains {\sc fortran} subroutines, a \file{test}
subdirectory which contains test applications, and \file{scripts} and
\file{data} subdirectories for package--related procedure files and system
data such as standard colour--maps, or source catalogues.
The \file{implement} directory can contain module subdirectories,
which can in turn contain \file{test} directories.  A particular module
subdirectory contains files implementing classes and functions with related
functionality, e.g.\ the \file{Tables} module in the \file{aips} package
contains the files implementing the \aipspp Table system.
The \file{test} subdirectory of a module contains test applications for the
module software.
The applications for
a particular package reside within the package subdirectory itself.

The substructure of the consortium--specific packages is left entirely to
\aipspp consortium members to determine.

There are a number of other subdirectories of \file{/aips++/code} which are
unrelated to packages.  The \file{install} subdirectory contains all of the
utilities required to install and maintain \aipspp.
\file{doc} contains \aipspp documentation sources, including
the \aipspp ``specs'', ``memos'', and ``notes'' series, and reference and
design documentation in the corresponding subdirectories.

Also below \file{/aips++/code} is the \file{include}
subdirectory which contains symbolic links to the
\file{implement} subdirectory for each package.  The purpose of these
symlinks is to allow \aipspp includes to be specified as
``\code{\#include $<$package/Header.h$>$}'' by adding
\file{-I/aips++/code/include} to the include path.

On \aipspp consortium installations an additional \file{admin}
subdirectory of \file{/aips++/code} contains files relating to the
administration of the \aipspp project.


%===========================================================================
\section{Aips infrastructure library.}

This section contains a
more detailed description of the contents of the library for the \code{aips}
package, describing the functionality provided.
This will be organized from the most basic functionality
such as run time type information (RTTI) and exceptions,
through higher level utilities
such as Arrays and Tables, to items of astronomical utility
such as Measurement models, etc.

For the most part, the descriptions themselves have been extracted from the
code and edited slightly.

      \begin{itemize}
      \item Basics
	\begin{itemize}
	\item RTTI
	\item Exceptions
	\end{itemize}

      \item Program Interface
	\begin{itemize}
	\item Program Input
	\item Glish
	\item AipsIO
	\item FITS
	\end{itemize}

      \item OS Interface
	\begin{itemize}
	\item Environment Variables
	\item Files
	\item Dates and Times
	\item Timing
	\item Event Handling
	\item X Wrappers
	\end{itemize}

      \item Utilities
	\begin{itemize}
	\item Compare
	\item Sort
	\item Fallible
	\item PtrHolder
	\item Assert
	\item Counted Pointer
	\item Dynamic Buffer
	\item Sequence
	\item Register
	\item KeyWords
	\end{itemize}

      \item GNU Utilities
	\begin{itemize}
	\item Regular Expressions
	\item Strings
	\end{itemize}

      \item Math. Utilities
	\begin{itemize}
	\item Constants
	\item Hashing
	\item Interpolation
	\item Math. Functions
	\end{itemize}

      \item GNU Math. Utilities
	\begin{itemize}
	\item Random Numbers
	\end{itemize}

      \item ``Simple'' Containers
	\begin{itemize}
	\item Bit Vector
	\item Blocks
	\item General Iterator Support
	\item Linked Lists
	\item Stacks
	\item Maps
	\end{itemize}

      \item High Level ``Containers''
	\begin{itemize}
	\item Arrays
	\item Tables
	\end{itemize}

      \item High  Level Utilities
	\begin{itemize}
	\item Logging
	\item Visualize
	\item Gridding
	\item Fourier Transforms
	\item Deconvolution
	\item Dummy Image
	\end{itemize}

      \item Orphaned Code to be Picked Up

          \begin{itemize}

	  \item ObjectID
	  \item Catalogs

	  \item Measurement Model
	  \item Telescope Model

	  \end{itemize}

      \item New Code Soon to be Released

          \begin{itemize}
	  \item Queue
          \item MaskedArray
	  \item Lattice
	  \item PagedArray
	  \item Image
	  \item Unit
	  \item Linear Least Squares Fitting
	  \item Single Dish
	  \item Graphics
	  \end{itemize}

      \end{itemize}


%=========================================================================
\subsection{Basics}

\subsubsection{RTTI}

\aipspp has implemented a runtime type information (RTTI) system.
This system provides type information which is consistent through
multiple executions of a program. This implementation goes beyond
what will be provided as a standard part of C++ in the future because
the C++ standard only guarantees that the type information will 
remain consistent throughout the current exection of a program.

The RTTI information is used by the exception mechanism.  It is also
used by AipsIO to identify the type of a datum written to or read
from external storage.


\subsubsection{Exceptions.}

\aipspp has its own exception mechanism.  Exceptions can be thrown and
caught.  Objects created on the heap are cleaned up after properly.

\class{AipsError} is the base class for all of the \aipspp error classes.
Because all of the errors have a common base class, any error can be caught
with a single catch statement.

This class has a string which allows error messages to be propagated.



%=========================================================================
\subsection{Program Interface}


\subsubsection{Program Input}

Class \class{Input} is a linked list of parameters (defined by the helper
class \class{Param})
with various user interface attributes.

It is used to provide input to a program through program invocation arguments.



\subsubsection{Glish}

This module contains \aipspp wrapper classes for Glish values and events.

\aipspp is using Glish as a user command line interpreter. Functionality is
bound to the CLI by passing events back and forth between it and server
programs, in this case written in C++. While it would have been possible
to use the native Glish classes,  it is somewhat tedious to do so in the
context of \aipspp; c.f. the documentation for \class{GlishArray}.

The classes in the Glish module are intended to make it easy to construct
values which are sent back and forth (typically via some type of IPC)
between various processes.

The classes in this module are used to create values (array or
record type) which are usually then transmitted to, or received from,
some other process. The major external classes in this module are:

          \begin{description}

          \item[GlishValue:] Base class for all Glish value objects.
          \class{GlishValue}s
          follow copy--on--write semantics, so assignment and passing and
          return by value are cheap.

          \item[GlishArray:] A (possibly n--dimensional) array of
          glish values,
          all of which have the same type. This is also the class which
          is used to hold a single value.

          \item[GlishRecord:] A ``structure'' of values, made up of
          named arrays
          and records (the latter makes it hierarchical).

          \item[GlishSysEvent:] A named value which has been sent from
          an external source.

          \item[GlishSysEventSource:] The object inside the program
          which emits the \class{GlishSysEvent} objects. It is also the object
          to which events from this executable are posted.

          \item[GlishSysEventTarget:] Allows glish event handlers to be
          installed.

          \end{description}

For a general introduction to Glish, see \\
\file{ftp://ee.lbl.gov/glish/USENIX--93.ps.Z}\ .


\subsubsection{AipsIO}

\class{AipsIO} is a class designed to do IO for objects.
It stores the data in canonical format using the routines
\class{ToLocal} and \class{FromLocal}.

The output can be written into / read from a filebuf file. This file
can be opened by \class{AipsIO} (by constructing with a filename) or the
user can open the file himself and pass a file descriptor.
The file can be opened by the constructor and closed by the destructor,
but it can also be done ``manually'' using the open and close routine.

An object is written by writing all its data members. It will be
preceeded by a header containing type and version.
The IO can be done via the overloaded $<<$ and $>>$ operators to write or
read a single item (e.g.\ an int or an object). These operators are
already defined for all built--in data types and for \class{Complex},
\class{DComplex},
\class{Char*}, \class{String} and \class{Bool}.
The write is also defined for \class{SubString}.

There are also functions \class{put}, \class{get}, and \class{getnew}
to write or read an
array of values. These functions are defined for the same data types
as $<<$ and $>>$ (so one can write, for example, an array of \class{Strings}).

    \begin{description}

    \item[AipsIO.put (nr, arr)] writes nr values from the given array.

    \item[AipsIO.get (nr, arr)] reads nr values into the given user--supplied
    array.

    \item[AipsIO.getnew (\&nr, \&arr)] reads the number of values written into
    an array allocated on the heap. It returns the nr of values read
    and a pointer to the array.

    \end{description}

The data must be read back in the same order as it was written.



\subsubsection{FITS}

This module contains classes for reading and writing FITS files.
All of the usual FITS header data units are provided.



%=========================================================================
\subsection{OS Interface}

\subsubsection{Environment Variables}

The \class{EnvironmentVariables} class works with the definitions, names,
and values of environment variables.

\subsubsection{Files}

\aipspp provides classes for working with paths, files, directories, symbolic
links, etc.

\subsubsection{Dates and Times}

The \class{Time} class handles date and times with modified Julian
day number and calendar Time.


\subsubsection{Timing}

The \class{Timer} class provides an interface to system timing.  It
allows a C++ program to record the time between a reference
point  (mark) and  now.  This  class  uses the system \code{times(2)}
interface to provide time resolution at either millisecond or
microsecond granularity,  depending  upon  operating  system
support and features. Since the time duration  is  stored  in
a  32--bit word,  the  maximum  time  period  before rollover
occurs is about 71 minutes.

Due to operating system dependencies, the  accuracy  of  all
member  function results may not be as documented. For example,
some operating  systems  do  not  support  timers  with
microsecond  resolution. In those cases, the values returned
are provided to the nearest millisecond  or  other  unit  of
time  as  appropriate. See the \class{Timer} header file for
system--specific notes.

This \class{Timer} class is based on the TI COOL library
\class{Timer} class.



\subsubsection{Event Handling}

\class{SysEvent} is the base class for all system events. It is
simply a wrapper around the basic types of events which must
be handled in the system, e.g. X events, Glish events, signals,
etc. It provides a common interface to all events.



\subsubsection{X wrappers}

The \class{XSysEvent} class is a wrapper for X events. It provides a standard
(minimal) interface to X events.

Often one needs to mix X events with other types of events.
This class provides a common interface for X events, and
all of the replated classes provide a system for handling
most asynchronous types of events which occur.



%=========================================================================
\subsection{Utilities}

\subsubsection{Compare}

\class{Compare} is a templated function to compare two objects.


\subsubsection{Sort}
\aipspp provides two classes for sorting.

The \class{Sort} class
allows you to sort data on one or more keys in a mix of
ascending and descending order. Optionally duplicates will be skipped.
The data can be in one record or in separate records.
The sort algorithm does not sort the records themselves, but
returns an index to the records.
A variety of sort algorithms are provided including insertion sort,
quicksort, and heapsort.

The static member functions of class \class{GenSort} are highly optimized
sort functions.
They do an in--place sort of an array of values.
The functions are templated, so they can in principle be
used with any data type. However, if used with non-builtin
data types, their class must contain the following functions:
\begin{itemize}
  \item \code{operator=}  (to assign when swapping elements)
  \item \code{operator$<$}, \code{operator$>$} and
        \code{operator==} (to compare elements)
  \item the default constructor  (to allocate a temporary)
\end{itemize}
If it is impossible or too expensive to define these functions,
the \class{Sort} class can be used instead. This sorts indirectly using
an index array. Instead of the functions mentioned above it
requires a comparison routine.

The following can be sorted:
\begin{itemize}
 \item A "C-array" of values
 \item An \class{Array} of values. The array can have any shape and the
        increment can be $>1$.
 \item A \class{Block} of values. There is a special functions to sort
        less elements than the size of the \class{Block}.
\end{itemize}

The options field can be used to choose a sort algorithm.
\begin{itemize}
 \item
 \code{Sort::QuickSort} is the fastest. It is about 4--6 times faster
   than the \code{qsort} function on the SUN. No worst case has been
   found, even not for cases where \code{qsort} is terrible slow.
 \item
 \code{Sort::HeapSort}  is about twice as slow as \code{quicksort}.
   It has the advantage that the worst case is always $o(n*log(n))$,
   while \code{quicksort} can have hypothetical inputs with $o(n*n)$.
 \item
 \code{Sort::InsSort} is $o(n*n)$ for random inputs. It is, however, the
   only stable sort (i.e. equal keys remain in the same order).
\end{itemize}
Furthermore \code{Sort::NoDuplicates} can be given in the options field,
to indicate that duplicate keys should be removed. The return value
is the nr of unique keys.
Default is \code{Sort::QuickSort}.

The order field can be \code{Sort::Ascending} or \code{Sort::Descending}.
Default is \code{Sort::Ascending}.



\subsubsection{Fallible}

The \class{Fallible} class is used to mark a value, in particular a
return value, as valid or invalid.


\subsubsection{PtrHolder}

The \class{PtrHolder} class holds pointers to be deleted when exceptions
are thrown.


\subsubsection{Assert}

There is a set of classes for making assertions about the results
of program execution.  This assertion mechanism can be turned on or off
at compile time with the AIPS\_DEBUG preprocessor macro.

The exception handling mechanism is used to throw the errors when an
assertion fails. An arbitrary exception can be thrown when an
assertion fails with \class{lAssert}, but \class{Assert} always throws
an \class{AbortError}.

The two ways of using the assertions mechanism are:

         \begin{itemize}
         \item \code{Assert(expr)}
         \item \code{lAssert(expr, exception)}
         \end{itemize}

The \code{Assert(expr)} form is intended to be used by ``end users'' because
it causes the program to abort if \code{expr} evaluates to a null value.
This is for the ``end users'' because presumably at their level there
is no way to recover from errors.

The \code{lAssert(expr,exception)} form throws the specified exception
if the \code{expr} is null. This exception can be caught in the regular
way.



\subsubsection{Counted Pointer}

The \class{Counted Pointer} classes implement a simple reference counting
mechanism. They
allow \class{Counted Pointer}s to be passed around freely, incrementing
or decrementing the reference count as needed when one \class{Counted Pointer}
is assigned to another. When the reference count reaches zero the
internal storage is deleted by default, but this behavior can be
overridden.

There are several different types of \class{Counted Pointer}s:
\begin{itemize}
\item SimpleCountedPtr
\item SimpleCountedConstPtr
\item CountedPtr
\item CountedConstPtr
\end{itemize}

The {\em Simple} classes do not have the \code{operator->()} operator.
This means that it puts less demands on the underlying type.

The {\em Const} classes do not allow the underlying value to be modified.


\subsubsection{Dynamic Buffer.}

\class{DynBuffer} allows one to store data in dynamically allocated buffers.
If a buffer is full, another one is allocated.
This means the data is not consecutive in memory.
After having stored the data, one can get the buffer addresses and
sizes to write the data for instance.

This class is developed for \class{AipsIO} as an intermediate buffer, but it
may serve other purposes as well.


\subsubsection{Sequence}

The \class{Sequence} class is the virtual base class for sequences in the
library.
It is templated to allow users to base derived sequences on any type,
e.g. \code{libg++}'s \class{Integers}.


\subsubsection{Register (simple type identification)}

The \class{Register} function provides a templated function to provide simple
type identification.
This function provides a ``simple'' type identification mechanism
which will provide ``typeid''s for classes which:

    \begin{itemize}

    \item Only involve single inheritance.

    \item Only need ids which are unique for a given execution.

    \end{itemize}


\subsubsection{KeyWords}

\class{KeywordSet} is the abstract base class for keyword classes like
\class{ScalarKeywordSet}.
It defines the common keyword name pool to be used by the
\code{TypedKeywords$<$T$>$} members of the \class{XKeywordSet} classes.
All these
members share the same name pool to prevent them from using
the same names.
Furthermore \class{KeywordSet} defines the basic data members and functions
for the derived classes. Useful functionalities are:

       \begin{itemize}

       \item It is possible link to another keyword set to enforce
       that the keywords in the 2 sets have different names.

       \item It is possible to exclude keyword names and data types.

       \item A comment string can be defined for each keyword.

       \item A map iterator can be constructed to iterate through
       all the keywords in the set.

       \item Testing if one set is a subset or superset of another.

       \end{itemize}


%=========================================================================
\subsection{GNU Utilities}

\subsubsection{Regular Expressions}

\aipspp provides a regular expression class.


\subsubsection{Strings}

\aipspp \class{String}s are the gnu string implementation,
modified by \aipspp to use \aipspp style exceptions, move some things out
of line, etc.


%=========================================================================
\subsection{Math. Utilities}

\subsubsection{Constants}

Constants class for mathematical and physical constants.

Implementation--defined limits usually defined in \code{$<$limits.h$>$},
\code{$<$float.h$>$},
and \code{$<$values.h$>$} as preprocessor defines.
Inclusion of \code{aips/Constants.h} is
sufficient to ensure that they are defined for any particular
implementation, and the correct functioning of the \code{tConstants} test
program guarantees this.

Refer to:

    \begin{verbatim}
    Section 3.2c, pp28-30 of
    "The Annotated C++ Reference Manual",
    Ellis, M.A., and Stroustrup, B.,
    Addison-Wesley Publishing Company, 1990.
    IBSN 0-201-51459-1.
    \end{verbatim}

and

    \begin{verbatim}
    Appendix B11, pp257-8 of
    "C Programming Language", 2nd ed.,
    Kernighan, B.W., and Ritchie, D.M.,
    Prentice Hall Software Series, 1988.
    IBSN 0-13-110362-8.
    \end{verbatim}

All constants and conversion factors are here defined as double precision
values.  Where single precision calculations are done in a situation where
processing speed is of concern, for example within the inner loop of an
expensive algorithm, a separate single precision variable should be defined
for use within the loop.



\subsubsection{Primes}

The \class{Primes} class provides some prime number operations.



\subsubsection{Hashing}

\class{ExtendHash$<$T$>$} is a templated hash class. It uses extendible hashing
for storing objects of type \code{T}.

\class{Bucket} is a fixed size array of \code{T}.
The size of the bucket is user definable; default is 4.

\class{ExtendHash} contains a number of buckets which grows as objects are added.
The user provides the hash function which  is tuned for the particular
application and \code{T}. The hash function should return uInt.

The user must provide the operators \code{==} and \code{!=} for the type
\code{T}.



\subsubsection{Interpolation}

Set of templated letter/envelope classes for interpolation.



\subsubsection{Math. Functions}

\aipspp provides a templated letter/envelope set of classes for packaging
of specific single dependent variable functions.

The \class{MathFunc} class is the abstract base class for 1--dimensional
math functions.

Actual math functions are then an inherited class from the base
class. This approach allows one to define actual function values
for each derived class. Then, one can pass a generic \class{MathFunc}
pointer to other objects, but the other objects will still get
function values from the actual inherited function.

By defining each math function as an object, we can place
parameters which will not change from one call to the function value
to another in the class definition and they only have to be
initialized once.


%=========================================================================
\subsection{GNU Math. Utilities}


\subsubsection{Random Numbers}

\aipspp provides a set of random number classes.

They are essentially just a concatenation of:

    \begin{verbatim}
    ACG.h           Geom.h          NegExp.h        Random.h
    Binomial.h      HypGeom.h       Normal.h        RndInt.h
    DiscUnif.h      LogNorm.h       Poisson.h       Uniform.h
    Erlang.h        MLCG.h          RNG.h           Weibull.h
    \end{verbatim}

from \code{libg++--2.2}. Random number classes written by Dirk Grunwald
(\code{grunwald@cs.uiuc.edu}) and modified for use in \aipspp.





%=========================================================================
\subsection{``Simple'' Containers}

\subsubsection{Bit Vector}

\class{BitVector} is a class of bit vectors with variable size.

A variable utilized as a discrete collection of bits is referred
to as a bit vector. Bit Vectors are an efficent method of keeping
True/False information on set of items or conditions.


\subsubsection{Block}

\class{Block$<$T$>$} is a simple templated 1--D array class. Indices are always
0--based. For efficiency reasons, no index checking is done unless the
preprocessor symbol \code{AIPS\_ARRAY\_INDEX\_CHECK} is defined.
\code{Block$<$T$>$}'s may be
assigned to and constructed from other \code{Block$<$T$>$}'s.
As no reference counting
is done this can be an expensive operation, however.

The net effect of this class is meant to be unsurprising to users who think
of 1--D arrays as first class objects. The name ``Block'' is  intended to convey
the concept of a solid ``chunk'' of things without any intervening ``fancy''
memory management, etc. This class was written to be
used in the implementations of more functional \class{Vector}, \class{Matrix},
etc. classes,
although it is expected \code{Block$<$T$>$} will be useful on its own.

The \class{Block} class should be efficient. You should normally use
\class{Block}
in preference to C--style arrays, particularly those obtained from \code{new}.
\code{Block$<$T$>$} is not derived from \class{Cleanup}
so if an exception is thrown the storage won't be reclaimed: \class{Block}'s
should
be used to build other classes which are themselves reclaimed.


\subsubsection{General Iterator support}

The \class{NoticeSource} class provides a mechanism for keeping all of
the observers
of an object up to date. Each time a change is made to the observed
object, the observers are notified of the change. When the observers
are updated, they can choose whether to update themselves or not.

Classes which have many other dependent objects which need to be updated
should derive from this class, e.g.\ doubly linked lists which have
dependent iterators.



\subsubsection{Linked Lists}

The \class{Link} class provides a minimal singly linked list implementation,
while the \class{Dlink} class, derived from \class{Link}, provides a minimal
doubly linked list implementation.
In these classes, all of
the work is performed by the constructor. The classes do not keep
track of the head of the list; this is left to the user of the class.
These classes can be thought of as the ``nodes'' of a linked list, but
conceptually each of the nodes is a list itself.

Although they are functional linked list implementations,
these classes will typically not be used by the average user.
Instead, various kinds of linked
list classes have been built using these classes.

In particular, the following user--level classes have been built:
\begin{itemize}
\item \class{List}: a singly linked list.
\item \class{Dlist}: a doubly linked list.
\end{itemize}

One uses the associated iterator classes to traverse the lists:
\begin{itemize}
\item \class{ListIter}
\item \class{ConstListIter}
\item \class{DlistIter}
\item \class{ConstDlistIter}
\end{itemize}

The {\em ListIter} classes traverse \class{List}s, while the
{\em DlistIter} classes traverse \class{Dlist}s.

The {\em Const} classes do not allow the underlying value in the list
to be modified.

\subsubsection{Stacks}

This class, \class{Stack$<$t$>$}, defines an implementation of a stack using
the singly linked list primitive, \class{Link$<$t$>$}. It has the standard
push and pop operations.


\subsubsection{Maps}

The \class{Map} class is the abstract base class for several ``Map'' classes
which implement associative arrays.
The classes derived from \class{Map} are:
\begin{itemize}
\item \class{ListMap}: a \class{Map} with list ordering / operations.
\item \class{OrderedMap}: a \class{Map} with ordered keys.
\end {itemize}

There is also a \class{SimpleOrderedMap} class, which is not derived
from \class{Map}..
\class{SimpleOrderedMap$<$key,value$>$} is a templated class.
It is similar to \class{OrderedMap$<$key,value$>$}, but lacks its
sophisticated iterator capability. Instead, iteration can be
done using the \class{getKey} and \class{getVal} functions with
a simple index.






%=========================================================================
\subsection{High Level ``Containers''}

\subsubsection{Arrays}

\class{Array$<$T$>$} is a templated, N--dimensional, Array class.
The origin is variable,
but by default indices are zero--based. This Array class is the
base class for specialized \class{Vector$<$T$>$}, \class{Matrix$<$T$>$},
and \class{Cube$<$T$>$} classes.

Indexing into the array, and positions in general, are given with
\class{IPosition}
(essentially a vector of integers) objects. That is, an N--dimensional
array requires a length--N \class{IPosition} to define a position within
the array.
Unlike C, indexing is done with (), not []. Also, the storage order
is the same as in {\sc fortran}, i.e.\ memory varies most rapidly with the first
index.

Aside from the explicit \code{reference()} member function, a user will
most commonly encounter an array which references another array
when he takes an array slice (or section). A slice is a sub--region of
an array (which might also have a stride: every nth row, every mth column,
\ldots).

The \class{Array} classes are intended to operate on relatively large
amounts of data. While they haven't been extensively tuned yet,
they are relatively efficient in terms of speed. Presently they
are not space efficient -- the overhead is about 15 words. While
this will be improved (probably to about 1/2 that), these array
classes are not appropriate for very large numbers of very small
arrays. The \class{Block$<$T$>$} class may be what you want in this
circumstance.

Element by element mathematical and logical operations are available
for arrays (defined in \code{aips/ArrayMath.h} and \code{aips/ArrayLogical.h}).
Because arithmetic and logical functions are split out, it is possible
to create an \class{Array$<$T$>$} (and hence \class{Vector$<$T$>$} etc) for
any type \code{T} that has
a default constructor, assignment operator, and copy constructor. In
particular, \code{Array$<$String$>$} works.

A tutorial for the Array classes is available.



\subsubsection{Tables}

The \aipspp table system is designed to be the main data system
used in the \aipspp software. It is based on the ideas of Allen
Farris.

A table consists of a number of keywords and columns.
A column can be a filled one (i.e. actually stored in a file)
or it can be a virtual one (i.e. calculated on the fly).
Filled columns are stored using a storage manager. A table
can have more than one storage manager; in fact, each column can
have its own storage manager. A table can therefore consist of
multiple files. The table name is the name of the main file.

Virtual columns are handled by so--called virtual column engines.
These engine classes have to be written by the application
programmer, since each virtual column will be calculated in
a dedicated way.

A column can contain scalar values of any data type, arrays of any
shape and any data type, or tables. The latter allows for a
hierarchy of tables.

Only standard data types can be used in filled columns. These are:
\code{Bool}, \code{uChar}, \code{Int}, \code{uInt}, \code{float},
\code{double}, \code{Complex}, \code{DComplex}, and \code{String}.
Arrays can be direct or indirect. Direct arrays have to have
the same shape in all cells of a column and are stored in the
main storage manager data file. Indirect arrays can have varying
shapes in the column cells and are stored in a separate file.
Direct columns are meant for small, fixed sized arrays.

The table keywords make use of the keyword module (i.e. class
\class{KeywordSet} and related classes).



%=========================================================================
\subsection{High  Level Utilities}

\subsubsection{Logging}

This module contains the \aipspp logging/history mechanism classes.

The \class{LogMessage} class is the means to providing a logging system that
will allow selective messages to be stored or possibly replayed as
GLISH scripts.

The \class{LogMessage} class is the class author's interface into the Log
system.  By ``throwing'' \class{LogMessage}s at regular intervals or important
times, the programmer assures no gaps will exist in the run--time
history.  The coder simply creates a robust \class{LogOrigin}
(if wished --- the
default \class{LogMessage} constructor fills in most of the important stuff.)
This \class{LogOrigin} instance is then passed as an argument to the
\class{LogMessage}
constructor along with the pertinent \class{String} message.  The global
\code{Log(LogMessage)} function will then pass the message through to the
external log containers.

The \class{LogtoTable} class creates a table of logs to be used later.
The method is to create the \class{LogFilters} you want and add them
to the \class{LogtoTable} via the inherited functions of \class{LogSink}.

The \code{Tables} module allows robust sorting and selection.  These
techniques can be used to select/scan/re--run any logged information
from the \class{LogtoTable}'s \class{Table}.  Additionally, the
\class{Table}'s persistance
is assured at destructor time.  No log will be lost.


\subsubsection{Visualize}

The \class{Visualize} class is a class to do line plotting, histogram and
contouring using PGPLOT.


\subsubsection{Gridding}

The \class{GridTool} class contains methods for gridding, or interpolating,
an n--dimensional data point onto an n--dimensional grid.
Reverse methods for de--gridding data are also supplied.

For a complete description of the methods associated with this class
see note 158 ``The \aipspp GridTool Class''



\subsubsection{Fourier Transforms}

The \class{DFTServer} class contains methods for doing n--dimensional
Slow Fourier Transforms. (In practice, the maximum dimension is 3)


The \class{FFTServer} class contains methods for doing n--dimensional
Fast Fourier Transforms. (In practice, the maximum dimension is 3).

At present the actual FFTs are done by {\sc fortran} functions which call
the \code{FFTpack} FFT functions available from \file{netlib}.


The \class{FourierTool} class provides pack and unpack operations that
manipulate Nyquist data.  These tools may handle either real or complex
numbers, and
pack/unpack operations are provided for each.

Note: This class is defined as

      \begin{verbatim}
      template<class T, class S> class FourierTool
      \end{verbatim}

but the only legal instantiations are:

      \begin{verbatim}
      FourierTool<float, Complex>
      FourierTool<double, DComplex>
      \end{verbatim}

For a complete description of the methods associated with these classes
see note 157 ``The \aipspp FFTServer Class''





\subsubsection{Deconvolution}

This module contains classes for deconvolvers using some form
of the CLEAN algorithm (Hogbom, Clark, Steer--Dewdney--Ito, \ldots).


\subsubsection{Dummy Image}

The \class{DummyImage} class is a very simple image for experimentation.
It is deprecated in favor of the soon--to--be--released \class{Image}
class.



%=========================================================================
\subsection{Orphaned Code to be Picked Up}

The code in this section is currently orphaned, i.e.\ its author no longer
works on \aipspp.  It will be revived in the near future.
While it does work, it is somewhat out--of--date with respect to the current
thinking / state--of--the--art of \aipspp.  It will all be reviewed, and
will be redesigned and rewritten where necessary.


\subsubsection{ObjectID}

The \class{ObjectID} class provides a unique identifier for each high level
object.


\subsubsection{Catalogs}

\class{CatalogHook} is the class which encapsulates the interaction of high
level objects with the catalog system.

Catalog behavior:

There are two catalogs, the \code{Active} catalog and the \code{File} catalog.
An item may be in one only or in both.  \class{CatalogHook} provides
two methods,
\code{update} and \code{downdate} for updating these catalogs.
\code{update} is called when the actual \class{Table} is initialized
and adds the current \class{CatalogHook} to the \code{Active} list.
\code{downdate} is called by the destructor, removes the \class{CatalogHook}
from the \code{Active} catalog, and adds the \class{CatalogHook} to the
\code{File} catalog
if a filename is present in the \class{Table} header.
(If the \class{Table} is constructed with a \class{FileName},
that \class{Filename} is also
placed in the \class{Table}'s header; if the \class{Table} is constructed
with a \class{Filename},
the \class{Table} destructor writes the \class{Table} to disk before
destruction.)

A third catalog, the \code{Handle} catalog, maps a \code{Handle}
(an object's name as known to the user) into an \class{ObjectID}.

\subsubsection{Measurement Model}

The \class{MeasurementModel} class is the telescope measurement equation
virtual base class.

It is the base class for all {\em mapping} objects for
\aipspp.  At the moment it is very light weight, and literally does
nothing.  As the system evolves, all functionality which will be
common for the mapping sub--system will go in here.  Currently one can
think of Cataloging, association and contact with UI/GUI happening
in this class.


Built on top of \class{MeasurementModel} is the \class{IntMeasurementModel}
class, which is
the telescope measurement equation for Synthesis telescopes.

The purpose of this class is to
pass the Telescope data through a measurement equation
appropriate for an Interferometer in the continum mode.
It makes one image (or image + dirtybeam) from the data
given to it.  The dimensionality for which it will work
is determined by the dimentions of the Image (works as a
3D invertor/predictor if the supplied image is a cube).
This, of course depends on \class{FFTServer} and \class{GridTool} being able
to handle the case of various dimentions (``existential'' design?).

Any selection of Freq/Poln etc. must be done outside this.
It is hoped that wherever it is used, the over all design
would be existential and \\
\code{IntImgModel:Invert(\ldots)} and
\code{IntImgModel:Pridect(\ldots)} would get called polymorphically.
All specializations of \class{MeasurementModel} would be inherited from
\class{MeasurementModel} class, which is the base class for the mapping
tree of \aipspp.

All selections on the UVData given to this will be done by
a wrapper around this level (i.e. at the UVMAP level ) --- this
level worries about the forward/revers transforms that
represent the telescope --- and worries about that alone!



\subsubsection{Telescope Model}

The Telescope Model describes (or models) the state of the physical
telescope at a given point during the data calibration process.
It is responsible for determining calibration parameters, via the
\code{solve} method, and applying corrections to raw data in the
Measurement Set (MS), via the \code{apply} method.

The process of calibration involves successive iterations of
\code{solve} and \code{apply}, until the Telescope Model is judged to
accurately describe the state of the telescope during the
observation.

The Telescope Model is composed of a number of Telescope
Components (TCs) which model platform characteristics,
environmental parameters, receptor characteristics, etc.
A common representation of a Telescope Component is a
calibration parameter solution table; but the representation
is not limited to calibration parameter solutions.

Calibration involves the addition, deletion, and modification
of the Telescope Components until a desired model is found.
The role of the Telescope Model is to

    \begin{itemize}

    \item Represent a related set of Telescope Components (TCSet),

    \item Allow the specification of Components to ``solve for''
      (via the \class{SolveSet}), and

    \item Allow the specification of order in which to ``apply''
      the Telescope Components to the MS (via the \class{ApplySequence}).

    \end{itemize}

A \code{solve} operation involves the invocation of the \code{solve} method
for the chosen set of Telescope Components.  Likewise, an \code{apply}
involves the invocation of the \code{apply} method for the chosen
set of Telescope Components in the given order.

A \code{solve} operation requires that a ``skeleton'' Telescope Component
exist, be attached to the Telescope Model, and be selected in the
SolveSet before \code{TM.solve} is invoked.



%=========================================================================
\subsection{New Code Soon to be Released}

There is quite alot of code which is currently under development and which
will be released in the near future.  The following sections provide brief
descriptions.


\subsubsection{Queue}

A \class{Queue} class.


\subsubsection{MaskedArray}

\class{MaskedArray} is a class for masking elements of an \class{Array}
while performing operations on that \class{Array}.

A \class{MaskedArray} is an association between an \class{Array} and a mask.
The mask
selects elements of the \class{Array}.  Only elements of the \class{Array}
where the
corresponding element of the mask is True are defined.  Thus, operations
on a \class{MaskedArray} only operate on those elements of the \class{Array}
where the
corresponding element of the mask is True.

A \class{MaskedArray} should be thought of as a manipulator for an
\class{Array}, analogous
to an iterator.  It allows one to perform whole \class{Array} operations on
selected elements of the \class{Array}.


\subsubsection{Lattice}

A \class{Lattice} base class which encapsulates finite linear, rectangular, or
hyper-rectangular data structures, plus associated \class{LatticeIterator}
classes for iterating through a \class{Lattice} conveniently.


\subsubsection{PagedArray}

A \class{PagedArray} class, which is derived from \class{Lattice},
for holding arrays larger than memory.


\subsubsection{Image}

An \class{Image} which is a \class{PagedArray} with associated coordinates.


\subsubsection{Unit}

\class{Unit} classes for physical measurements.


\subsubsection{Linear Least Squares Fitting}

Classes for general linear least squares fitting.


\subsubsection{Single Dish}

Classes for position-switched calibration and on-the-fly mapping of
single dish data.



\subsubsection{Graphics}

Graphics classes (based on Karma graphics) for the manipulation of
images and other graphical items.





\end{document}

\externallabels{../../user/Refman}{../../user/Refman/labels.pl}

\section{Introduction}

The Lattice Expression Language (LEL) makes it possible to do arithmetic
on lattices (in particular on images [which are just lattices plus
coordinates]) in AIPS++.  An expression can be seen as a lattice (or
image) in itself.  It can be used in any operation where a normal image
is used. 

To summarize, the following functionality is supported:
\begin{itemize}
\item The common mathematical, comparison, and relational
      \htmlref{operators}{LEL:OPERATORS}.
\item An extensive list of mathematical and logical
      \htmlref{functions}{LEL:FUNCTIONS}.
\item Mixed \htmlref{data type}{LEL:DATATYPES} arithmetic
      and automatic data type promotion.
\item Support of image \htmlref{masks}{LEL:MASKS}.
\item \htmlref{Masking}{LEL:CONDITIONS} using boolean expressions.
\item Handling of \htmlref{masks}{LEL:HANDMASKS} in an expression.
\item Support of image \htmlref{regions}{LEL:REGIONS}.
\item Interface from both Glish and C++.
\end{itemize}

The first section explains the syntax.  The last sections show the
interface to LEL using Glish or C++.  The Glish interface makes it
possible to embed Glish variables and expressions in a LEL command. 
At the end some \htmlref{examples}{LEL:EXAMPLES} are given.  If 
you like, you can go straight to the examples and hopefully immediately
be able to do some basic things.

\medskip\noindent LEL operates on lattices, which are a generalization
of arrays.  As said above a particular type of lattice is an image; they
will be used most often.  Because lattices can be very large and
usually reside on disk, an
expression is only evaluated when a chunk of its data is requested. 
This is similar to reading only the requested chunk of data from a disk
file. 

\medskip\noindent LEL is quite efficient and can therefore be used well
in C++ and glish code.  Note however, that it can never be as efficient as
carefully constructed C++ code. 

\medskip\noindent \htmladdnormallink{Note 216}{../216/216.html} gives a
detailed description how LEL is implemented using various C++ classes. 


\section{\label{LEL:EXPRESSIONS}Expressions}

A LEL expression can be as simple or as complex as one likes
using the standard
\htmlref{arithmetic, comparison, and logical operators}{LEL:OPERATORS}.
Parentheses can be used to group subexpressions.
\\The operands in an expression can be
\htmlref{lattices}{LEL:LATTICES},
\htmlref{constants}{LEL:CONSTANTS},
\htmlref{functions}{LEL:FUNCTIONS}, and
\htmlref{condition masks}{LEL:CONDITIONS}.
\htmlref{lattice regions and masks}{LEL:REGIONS}.
E.g.
\begin{verbatim}
  lat1 + 10
  lat1 + 2 * max(lat2,1)
  amp(lat1, lat2)
  lat1 + mean(img[region1])
  lat1 + mean(lat2[lat2>5 && lat2<10])
\end{verbatim}

The last example shows how a boolean expression can be used to form a
mask on a lattice.  Only the pixels fulfilling the boolean condition
will be used when calculating the mean. 

\medskip\noindent In general the result of a LEL expression is a lattice,
but it can be a scalar too. If is is a scalar, it will be handled correctly
by C++ and glish functions using it as the source in, say, an
assignment to another lattice.

\medskip\noindent LEL fully supports masks. In most cases the mask of a
subexpression is formed by and-ing the masks of its operands.
It is fully explained in a \htmlref{later section}{LEL:HANDMASKS}.


\label{LEL:DATATYPES}
LEL supports the following data types:
\begin{description}
  \item[ \textbf{Bool}]
  \item[ \textbf{Float}] single precision real (which includes integers)
  \item[ \textbf{Double}] double precision real
  \item[ \textbf{Complex} ] single precision complex
  \item[ \textbf{DComplex} ] double precision complex
\end{description}
All these data types can be used for scalars and lattices.
\\LEL will do automatic data type promotion when needed. E.g. when
a Double and a Complex are used in an operation, they will be promoted
to DComplex. It is also possible to promote explicitly using the
conversion functions (FLOAT, DOUBLE, COMPLEX and DCOMPLEX).
These functions can also be used to demote a data type
(e.g. convert from Double to Float), which can sometimes
be useful for better performance.

\textbf{Region} is a specific data type. It indicates a region of any type
(in pixel or world coordinates, relative, fractional).
A region can only be applied to a lattice subexpression using
operator \texttt{[]}.


\subsection{\label{LEL:CONSTANTS}Constants}
Scalar constants of the various data types can be formed as follows
(which is similar to Glish):
\begin{itemize}
  \item A Bool constant can be given as T or F
        (meaning true and false respectively).
  \item A Float constant can be any integer or floating-point number. E.g.
    \begin{verbatim}
    3
    3.14
    3.14e-2
    \end{verbatim}
  \item A Double constant is a floating-point number using a D for the
    exponent. One can also use the \texttt{DOUBLE} function. E.g.
    \begin{verbatim}
    1d2
    3.14d-2
    double(2)
    \end{verbatim}
  \item The imaginary part of a Complex or DComplex constant is formed
    by a Float or Double constant immediately followed by a lowercase
    \textbf{i}. A full complex
    constant is formed by adding another constant as the
    real part. E.g.
    \begin{verbatim}
    1.5 + 2i
    2i+1.5            is identical
    \end{verbatim}
    Note that a full complex constant has to be enclosed
    in parentheses when, say, a multiplication is performed on it. E.g.
    \begin{verbatim}
    2 * (1.5+2i)
    \end{verbatim}
\end{itemize}
The functions \texttt{pi()} and \texttt{e()} should be
used to specify the constants pi and e. Note that they form a Double constant,
so when using e.g. pi with a Float lattice, it could make a lot of sense
to convert pi to a Float. Otherwise the lattice is converted to a
Double, which is time-consuming. However, one may have very valid
reasons to convert to Double, e.g. to ensure that the calculations are
accurate enough.

\subsection{\label{LEL:OPERATORS}Operators}
The following operators can be used (with their normal meaning and
precedence):
\begin{description}
  \item[] Unary \textbf{+} and \textbf{-}
       \\Can not be used with Bool operands.
  \item[] Unary \textbf{!}
       \\Logical NOT operator.
       Can only be used with Bool operands.
       \\For a region it forms the complement.
  \item[] Binary \textbf{$\wedge$, *, /, \%, +}, and \textbf{-}
       \\\% is the modulo operator.
       E.g. \texttt{3\%1.4} results in \texttt{0.2} and
       \texttt{-10\%3} results in \texttt{-1}.
       \\\verb+^+ is the power operator.
       \\All operators are left-associative, except \verb+^+ which is
       right-associative; thus
       \texttt{2}\verb+^+\texttt{1}\verb+^+\texttt{2} results in \texttt{2}.
       \\Operator \% can only be used for real operands, while the others
       can be used for real and complex operands.
        \\Operator \textbf{-} can also be used for regions. It forms
        the difference of the left and right operand.
  \item[] \textbf{==, $!=$, $>$, $>=$, $<$}, and \textbf{$<=$}
       \\For Bool operands only $==$ and $!=$ can be used.
       \\A Bool operand cannot be compared with a numeric operand.
       \\The comparison operators use the norm for complex values.
  \item[] \textbf{\&\&} and \textbf{$\mid\mid$}
       \\Logical AND and OR operator. 
       \\These operators can only be used with Bool operands.
       \\When used on a region \textbf{\&\&} forms the intersection,
       while \textbf{$\mid\mid$} forms the union.
\end{description}
\begin{description}
  \item The precedence order is:
       \\\verb+^+
       \\unary \texttt{+, -, !}
       \\\texttt{*, /, \%}
       \\\texttt{+, -}
       \\\texttt{$==, !=, >, >=, <, <=$}
       \\\texttt{\&\&}
       \\\texttt{$\mid\mid$}
\end{description}
Note that \verb+^+ has a higher precedence than the unary operators.
\\E.g. \texttt{-3}\verb+^+\texttt{2} results in \texttt{-9}.

The operands of these operators can be 2 scalars, 2 lattices, or a
lattice and a scalar. When 2 lattices are used, they should in
principle conform; i.e. they should have the same shape and
coordinates. However, LEL will try if it can extend
one lattice to make it conformant with the other. It can do that
if both lattices have coordinates and if one lattice is a true
subset of the other (thus if one lattice has all the coordinate
axes of the other lattice and if those axes have the same length or
have length 1). If so, LEL will add missing axes and/or
stretch axes with length 1

\subsection{\label{LEL:FUNCTIONS}Functions}
In the following tables the function names are shown in uppercase,
while the result and argument types are shown in lowercase.
Note, however, that function names are case-insensitive.
All functions can have scalar and/or lattice arguments.
\\When a function can have multiple arguments (e.g. atan2), the
operands are automatically promoted where needed.

\subsubsection{Mathematical functions}
Several functions can operate on real or complex arguments.
The data types of such arguments are given as 'numeric'.
\begin{description}
  \item[ \texttt{Double PI()}] Returns the value of \textbf{pi}.
  \item[ \texttt{Double E()}] Returns the value of \textbf{e}.
  \item[ \texttt{numeric SIN(numeric)}]
  \item[ \texttt{numeric SINH(numeric)}]
  \item[ \texttt{real ASIN(real)}]
  \item[ \texttt{numeric COS(numeric)}]
  \item[ \texttt{numeric COSH(numeric)}]
  \item[ \texttt{real ACOS(real)}]
  \item[ \texttt{real TAN(real)}]
  \item[ \texttt{real TANH(real)}]
  \item[ \texttt{real ATAN(real)}]
  \item[ \texttt{real ATAN2(real y, real x)}]
       Returns \texttt{ATAN(y/x)} in correct quadrant.
  \item[ \texttt{numeric EXP(numeric)}]
  \item[ \texttt{numeric LOG(numeric)}] Natural logarithm.
  \item[ \texttt{numeric LOG10(numeric)}]
  \item[ \texttt{numeric POW(numeric, numeric)}] The same as operator \verb+^+.
  \item[ \texttt{numeric SQRT(numeric)}]
  \item[ \texttt{complex COMPLEX(real, real)}]
       Create a complex number from two reals.
  \item[ \texttt{complex CONJ(complex)}]
  \item[ \texttt{real REAL(numeric)}] Real value itself or
    real part of a complex number.
  \item[ \texttt{real IMAG(complex)}] Imaginary part of a complex number.
  \item[ \texttt{real NORM(numeric)}]
  \item[ \texttt{real ABS(numeric),  real AMPLITUDE(numeric)}]
     both find the amplitude of a complex number.
     If the  numeric argument is real, imaginary part zero is assumed.
  \item[ \texttt{real ARG(complex),  real PHASE(complex)}]
     both find the phase of a complex number.
  \item[ \texttt{numeric MIN(numeric, numeric)}]
  \item[ \texttt{numeric MAX(numeric, numeric)}]
  \item[ \texttt{Float SIGN(real)}]
       Returns -1 for a negative value, 0 for zero, 1 for a positive value.
  \item[ \texttt{real ROUND(real)}]
       Rounds the absolute value of the number.
       \\E.g. \texttt{ROUND(-1.6) = -2}.
  \item[ \texttt{real FLOOR(real)}]
       Works towards negative infinity.
       \\E.g. \texttt{FLOOR(-1.2) = -2}
  \item[ \texttt{real CEIL(real)}] Works towards positive infinity.
  \item[ \texttt{real FMOD(real, real)}] The same as operator \%.
\end{description}
Note that the trigonometric functions need their arguments in radians.

\subsubsection{Scalar result functions}
The result of these functions is a scalar.
\begin{description}
  \item[ \texttt{double NELEMENTS(anytype)}]
    Return number of elements in a lattice (1 for a scalar).
  \item[ \texttt{double NDIM(anytype)}]
    Return dimensionality of a lattice (0 for a scalar).
  \item[ \texttt{double LENGTH(anytype, real axis)}]
    Return length of a lattice axis (returns 1 for a scalar or if axis
    exceeds number of axes). Axis number is 1-relative.
  \item[ \texttt{Bool ANY(Bool)}] Is any element true?
  \item[ \texttt{Bool ALL(Bool)}] Are all elements true?
  \item[ \texttt{Double NTRUE(Bool)}] Number of true elements.
  \item[ \texttt{Double NFALSE(Bool)}] Number of false elements.
  \item[ \texttt{numeric SUM(numeric)}] Return sum of all elements.
  \item[ \texttt{numeric MIN(numeric)}] Return minimum
    of all elements.
  \item[ \texttt{numeric MAX(numeric)}] Return maximum
    of all elements.
  \item[ \texttt{real MEDIAN(real)}]
    Return median of a lattice. For smallish lattices
    (max. 512*512 elements) the median can be found in 1 pass.
    Other lattices usually require 2 passes.
  \item[ \texttt{real FRACTILE(real,float)}]
    Return the fractile of a lattice at the fraction given by the second
    argument. A fraction of 0.5 is the same as the median.
    The fraction has to be between 0 and 1.
    For smallish lattices (max. 512*512 elements) the fractile can be
    found in 1 pass. Other lattices usually require 2 passes.
  \item[ \texttt{real FRACTILERANGE(real,float,float)}]
    Return the range between the fractiles at the fraction given by
    the second and third argument.
    The fractions have to be between 0 and 1 and the second fraction
    has to be greater than the first one.
    The second fraction is optional and defaults to \texttt{1-fraction1}.
    Thus
    \\\texttt{FRACTILERANGE(lat, 0.1)}
    \\\texttt{FRACTILERANGE(lat, 0.1, 0.9)}
    \\\texttt{FRACTILE(lat,0.9) - FRACTILE(lat,0.1)}
    \\are equal, be it that the last one is about twice as slow.
    \\For smallish lattices (max. 512*512 elements) the fractile range
    can be found in 1 pass. Other lattices usually require 2 passes.
  \item[ \texttt{numeric MEAN(numeric)}]
    Return mean of all elements.
  \item[ \texttt{numeric VARIANCE(numeric)}]
    Return variance
    \\(\texttt{sum((a(i) - mean(a))**2) / (nelements(a) - 1)}).
    \\All calculations are done in double precision.
  \item[ \texttt{numeric STDDEV(numeric)}]
    Return standard deviation (the square root of the variance).
  \item[ \texttt{real AVDEV(numeric)}]
    Return average deviation.
    \\(\texttt{sum(abs(a(i) - mean(a))) / nelements(a)}).
    \\All calculations are done in double precision.
\end{description}

\subsubsection{\label{LEL:MISCFUNCTIONS}Miscellaneous functions}
\begin{description}
  \item[ \texttt{numeric REBIN(numeric,[f1,f2,...])}]
    rebins the image using the given (integer) factors.
    It averages the pixels in each bin with shape [f1,f2,...].
    Masked-off pixels are not taken into account. If all pixels in a
    bin are masked off, the resulting pixel will be masked off.
    The length of the factor list [f1,f2,...] has to match the
    dimensionality of the image. The factors do not need to divide
    the axes lengths evenly.
    Each factor can be a literal value, but it can also be any
    expression resulting in a real scalar value.
    \\For instance, for a 3-dimensional image:
    \begin{verbatim}
       rebin(lat,[2,2,1])
    \end{verbatim}
    will halve the size of axis 1 and 2.
  \item[ \texttt{real AMP(real,real)}]
    It returns the square root of the quadrature sum of the two
    arguments.  Thus
    \begin{verbatim}
       amp(lat1,lat2)
    \end{verbatim}
    gives $\sqrt{(lat1^2+lat2^2)}$.  This can be used to form, for
    example, (biased) polarized intensity images when lat1 and lat2
    are Stokes Q and U images.
  \item[ \texttt{real PA(real,real)}]
    It returns a ``position angle'' (in degrees) from the two lattices.
    That is,
    \begin{verbatim}
       pa(lat1,lat2)
    \end{verbatim}
    gives $180/\pi*atan2(lat1,lat2)/2$.  This can be used to form, for
    example, linear polarization position angle images when
    lat1 and lat2  are Stokes Q and U images, {\it respectively}.
  \item[ \texttt{real SPECTRALINDEX(real,real)}]
    It returns a the spectral index made from the two lattices.  That is,
    \begin{verbatim}
       log(s1/s2) / log(f1/f2)
    \end{verbatim}
    where s1 and s2 are the source fluxes in the lattices and f1 and f2
    are the frequencies of the spectral axes of both lattices.
    Similar to e.g. operator + the lattices do not need to have the
    same shape. One can be extended/stretched as needed.
  \item[ \texttt{anytype VALUE(anytype)}]
    It returns the argument without its possible mask, thus it removes
    the mask from the argument.
    The section about \htmlref{mask handling}{LEL:HANDMASKS}
    discusses it in more detail.
  \item[ \texttt{Bool MASK(anytype)}]
    It returns the mask of the argument.
    The section about \htmlref{mask handling}{LEL:HANDMASKS}
    discusses it in more detail.
  \item[ \texttt{Bool ISNAN(anytype)}]
    It tests lattice elements on a NaN value and sets the corresponding
    output element to T if so; otherwise to F.
  \item[ \texttt{anytype REPLACE(anytype, anytype)}]
    The first argument has to be a lattice (expression).
    The optional second argument can be a scalar or a lattice
    (expression). It defaults to 0.
    \\The result of the function is a copy of the first argument,
    where each masked-off element in the first argument is replaced by the
    corresponding element in the second argument. The result's mask is
    a copy of the mask of the first argument.
    \begin{verbatim}
    replace (lat1, 0)
    replace (lat1, lat2)
    \end{verbatim}
    The first example replaces each masked-off element in
    \texttt{lat1} by 0.
    \\The second example replaces it by the corresponding element in
    \texttt{lat2}. A possible mask of \texttt{lat2} is not used.
  \item[ \texttt{anytype IIF(Bool, anytype, anytype)}]
    The first argument is a boolean expression. If an element in
    it is true, the corresponding element from the second argument is
    taken, otherwise from the third argument. It is similar to the
    ternary \texttt{?:} construct in C++. E.g.
    \begin{verbatim}
    iif (lat1>0, lat1, 0)      same as max(lat1,0)
    iif (sum(lat1)>0, lat1, lat2)
    \end{verbatim}
    The examples shows that scalars and lattices can be freely mixed.
    When all arguments are scalars, the result is a scalar. Otherwise
    the result is a lattice.
    \\ Note that the mask of the result is formed by combining the
    mask of the arguments in an appropriate way as explained in the
    section about \htmlref{mask handling}{LEL:HANDMASKS}.
  \item[ \texttt{Bool INDEXIN(real axis, set indices)}]
    The first argument is a 1-relative axis number. The second
    argument is a set of indices. It returns a Bool array telling for
    each lattice element if the index of the given axis is contained
    in the set of indices.
    \\The 1-relative indices have to be given as elements with integer
    values enclosed in square
    brackets and separated by commas. Each element can be a single
    index, an index range as \texttt{start:end}, or a strided index
    range as \texttt{start:end:stride}. The elements do not need to be
    ordered, but in a range start must be $<=$ end. For example:
    \begin{verbatim}
    image[indexin(2, [3,4:8,10:20:2])]
    \end{verbatim}
    masks \texttt{image} such that only the pixels with an index
    3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 18, or 20 on the second axis
    are set to True.

    The following special syntax exists for this function.
    \begin{verbatim}
    INDEXi IN set
    \end{verbatim}
    where \texttt{i} is the axis number. So the example above can also
    be written as:
    \begin{verbatim}
    image[index2 in [3,4:8,10:20:2]]
    \end{verbatim}
    Negated versions of this function exist as:
    \begin{verbatim}
    INDEXNOTIN(axis, set)
    INDEXi NOT IN set
    \end{verbatim}
\end{description}

\subsubsection{Conversion functions}
\begin{description}
  \item[ \texttt{Float FLOAT(real)}]
    Convert to single precision.
  \item[ \texttt{Double DOUBLE(real)}]
    Convert to double precision.
  \item[ \texttt{Complex COMPLEX(numeric)}]
    Convert to single precision complex.
    If the argument is real, the imaginary part is set to 0.
  \item[ \texttt{DComplex DCOMPLEX(numeric)}]
    Convert to double precision complex.
    If the argument is real, the imaginary part is set to 0.
  \item[ \texttt{Bool BOOLEAN(region)}]
    Convert to boolean.
    This can be useful to convert a region to a boolean lattice.
    Only a region in pixel coordinates can be converted, so in
    practice only an image mask can be converted.
\end{description}
Note that, where necessary, up-conversions are done automatically.
Usually it may only be needed to do a down-conversion (e.g. Double to Float).

\subsection{\label{LEL:LATTICES}Lattice names}

When a lattice (e.g.  an image) is used in an expression, its name has
to be given.  The name can be given directly if it consists of the
characters \texttt{-}\texttt{.}\texttt{\$}\texttt{\~\ } and alphanumeric
characters. 

\medskip\noindent If the name contains other characters or if it is a reserved word
(currently only T and F are reserved), it has to be escaped.  Escaping
can be done by preceeding the special characters with a backslash or by
enclosing the string in single or double quotes.  E.g. 

\begin{verbatim}
  ~/myimage.data
  ~/myimage.data\-old
  '~/myimage.data-old'
\end{verbatim}

\medskip\noindent Note that when LEL is used from Glish, it is also possible to use
a Glish image variable as a lattice operand (e.g. \texttt{\$im}).
This is explained in the section describing the
\htmlref{Glish binding}{LEL:GLISHC}. It means that in Glish a
name starting with a \texttt{\$} should be escaped too.


\section{\label{LEL:MASKS}Masks}

\subsection{Access to Image Masks}

A boolean mask associated with an image indicates whether a pixel is
good (mask value True) or bad (mask value False).  If the mask value is
bad, then the image pixel is not used for computation (e.g.  when
finding the mean of the image). 

\medskip\noindent An image can have zero (all pixels are good) or more masks.  One mask
can be designated as the default mask.  By default it will be applied to
the image (from Glish, designation of the default mask is handled by the
\htmlref{maskhandler}{images:image.maskhandler.function} function
of the \htmlref{Image}{images:image} tool).

\medskip\noindent When using LEL, the basic behaviour is that the default mask is used. 
However, by qualifying the image name with a suffix string, it is
possible to specify that no mask or another mask should be used.  The suffix
is a colon followed by the word \texttt{nomask} or the name of the
alternative mask.

\begin{verbatim}
  myimage.data
  myimage.data:nomask
  'myimage.data:othermask'
\end{verbatim}

\medskip\noindent
The first example uses the default mask (if the image has one).
The second example uses no mask (thus all pixels are designated good)
and the third example uses mask \texttt{othermask}.

\medskip\noindent
Note that if the image name is enclosed in quotes, the mask name
should be enclosed too. It means that a colon cannot be part of
an image name.

\medskip\noindent
It is also possible to use a mask from another image like
\begin{verbatim}
  myimage.data:nomask[myotherimage::othermask]
\end{verbatim}
This syntax is explained in the section describing
\htmlref{regions}{LEL:REGIONS}


\subsection{\label{LEL:CONDITIONS}Lattice Condition Mask}

We have seen in the previous section that lattices (in this case images)
can have an associated mask.  These masks are stored with the image --
they are persistent.  

\medskip\noindent It is also possible to create transient masks when a LEL expression is
executed (dawn, usually).  This is done with the operator \texttt{[]}
and a boolean expression.  For example,

\begin{verbatim}
  sum( lat1[lat1<5 && lat1>10] )
\end{verbatim}
creates a mask for {\tt lat1} indicating that only its elements fulfilling
the boolean condition should be taken into account in the \texttt{sum}
function.  Note that the mask is local to that part of the expression. So in
the expression

\begin{verbatim}
  sum( lat1[lat1<5 && lat1>10] ) + sum(lat1)
\end{verbatim}
the second \texttt{sum} function takes all elements into account.
Masking can also be applied to more complex expressions and it is recursive.

\begin{verbatim}
  (lat1+lat2)[lat3<lat4]
  sum( lat1[lat1<5][lat1>10] )
  (lat1 + lat2[lat3<lat4]) [lat1<5]
\end{verbatim}
The first example applies the mask generated by the \texttt{[]}
operator to the expression \texttt{lat1+lat2}.  The second example shows
the recursion (which ANDs the masks).  It is effectively a (slower)
implementation of the first example in this subsection.  In the last
example, the expression inside the parentheses is only evaluated
where the condition {\tt [lat1<5]} is true and the resulting expression
has a mask associated with it.  

Please note that it is possible to select pixels on an axis by means
of the function \texttt{INDEXIN} (or by the \texttt{INDEXi IN}
expression) as shown in the previous section about
\htmlref{miscellaneous functions}{LEL:MISCFUNCTIONS}.


\subsection{\label{LEL:HANDMASKS}Mask Handling}

As explained in the previous subsections, lattices can have a mask. 
Examples are a \htmlref{mask}{LEL:MASKS} of good pixels in an image,
a mask created using a \htmlref{boolean condition}{LEL:CONDITIONS}
and the operator \texttt{[]},
or a mask defining a \htmlref{region}{LEL:REGIONS} within its bounding
box.
\\A pixel is bad when the image has a mask and when the
mask value for that pixel is False. Functions like
\texttt{max} ignore the bad pixels.
\\ Note that in a MeasurementSet a False mask value indicates a good
visibility. Alas this is a historically grown distinction in
radio-astronomy.

\medskip\noindent Image masks are combined and propagated throughout an
expression.  E.g.  when
two lattices are added, the mask of the result is formed by and-ing the
masks of the two lattices.   That is, the resultant mask is True where the
mask of lattice one is true AND the mask of lattice 2 is True. Otherwise,
the resultant mask is False.

\medskip\noindent In general the mask of a subexpression is formed by and-ing the masks
of the operands.  This is true for e.g.  +, *, \texttt{atan2}, etc.. 
However, there are a few special cases:


\begin{itemize}
\item
The mask created by \texttt{operator[condition]} is formed by and-ing the
condition result, the mask of the result, and the mask of the subexpression
where the condition is applied to.   For example, suppose \texttt{lat1} and
\texttt{lat2} each  have a mask. Then in
\begin{verbatim}
  sum( lat1[lat2<5] )
\end{verbatim}
the \texttt{sum} function will only sum those elements for which
the mask of \texttt{lat1} and \texttt{lat2} is valid and for which
the condition is true.

\item
The logical AND operator forms the resultant mask by looking at the
result and the masks of the operands.  

\begin{verbatim}
  lat1[lat1<0 && lat2>0]
\end{verbatim}
Let us say both {\tt lat1} and {\tt lat2} have masks.  The operand
{\tt lat1<0} is true if the mask of {\tt lat1} is true and the
operand evaluates to true, otherwise it is false.  Apply the same
rule to the operand {\tt lat2 > 0}.  The AND operator gives true if
the left and right operands are both true.  If the left operand
is false, the right operand is no longer relevant.  It is, in
fact, 3-valued logic with the values true, false, and undefined. 

\medskip\noindent Thus, the full expression generates a lattice with a mask.
The mask is true when the condition in the {\tt []} operator
is true, and false otherwise.  The values of the output lattice are only
defined where its mask is true.

\item
The logical OR operator works the same as the AND operator.  If
an operand has a true value the other operand can be ignored.

\item
The mask of the result of the \texttt{replace} function is a copy
of the mask of its first operand. The mask of the second operand is
not used at all.

\item
The \texttt{iif} function has three operands. Depending on the
condition, an element from the second or third operand has to be taken.
The resultant mask is formed by the mask of the condition and-ed
with the appropriate elements from the masks of the second or third
operand.

\item
The \texttt{value} function returns the value without a mask, thus
it removes the mask from a value.
It has the same effect as the \texttt{image:nomask} construction
discussed \htmlref{above}{LEL:MASKS}. However, the \texttt{value}
function is more general, because it can also be applied to a
subexpression.

\item
The \texttt{mask} function returns the mask of a value.
The returned value is a boolean lattice and has no mask itself.
When the value has no mask, it returns a mask consisting of all True values.
When applied to an image, it returns its default mask.
\end{itemize}

Consider the following more or less equivalent examples:
\begin{verbatim}
   value(image1)[mask(image2)]
   image1:nomask[mask(image2)]
   image1:nomask[image2::mask0]
\end{verbatim}
The first two use the default mask of \texttt{image2} as the mask for
\texttt{image1}.
\\The latter uses \texttt{mask0} of \texttt{image2} as the mask for
\texttt{image1}. It is equivalent to the first two examples if
\texttt{mask0} is the default mask of \texttt{image2}.


\medskip\noindent It is possible that the entire mask of a subexpression is false.  For example,
if the mean of such a subexpression is taken, the result is
undefined.  This is fully supported by LEL, because a scalar value also
has a mask associated with it.  One can see a masked-off scalar as a
lattice with an all false mask.  Hence an operation involving an
undefined scalar results in an undefined scalar.  The following
functions act as described below on fully masked-off lattices:

\begin{itemize}
\item MEDIAN, MEAN, VARIANCE, STDDEV, AVDEV, MIN, MAX
\\result in an undefined scalar:
\item NELEMENTS, NTRUE, NFALSE, SUM
\\result in a scalar with value 0.
\item ANY
\\results in a scalar with value F.
\item ALL
\\results in a scalar with value T.
\item LENGTH, NDIM
\\ignore the mask because only the shape of the lattice matters.
\end{itemize}

\medskip\noindent You should also be aware that if you remove a mask from an image,
the values of the image that were previously masked bad 
may have values that are meaningless.


\section{\label{LEL:REGIONS}Regions}

A region-of-interest generally specifies a portion of a lattice which you
are interested in for some astronomical purpose (e.g.  what is the flux
density of this source).  Quite a rich variety of regions are supported
in AIPS++.  There are simple regions like a box or a polygon, and
compound regions like unions and intersections.  Regions may contain
their own ``region masks''.  For example, with a 2-d polygon, the region is defined
by the vertices, the bounding box and a mask which says whether a pixel
inside the bounding box is inside of the polygon or outside of the
polygon. 

\medskip\noindent In addition, although masks and regions are used somewhat differently by
the user, a mask is really a special kind of region; they are implemented
with the same underlying code.

\medskip\noindent Like masks, regions can be persistently stored in image.  From Glish,
regions are generated, manipulated and stored with the
\htmlref{Regionmanager}{images:regionmanager} tool.

\medskip\noindent We saw in the previous section how the condition operator {\tt []} could
be used to generate masks with logical expressions.  This operator has a
further talent.  A region of any type can be applied to a lattice with
the {\tt []} operator.  You can think of the region as also effectively
being a logical expression.  The only difference with what we have seen
before is that it results in a lattice with the shape of the region's
bounding box.  If the lattice or the region (as in the polygon above)
has a mask, they are and-ed to form the result's mask. 

\medskip\noindent All types of regions supported in AIPS++ can be used, thus:

\begin{itemize}
\item regions in pixel or world coordinates
\item in absolute, relative and/or fractional units
\item basic regions box, ellipsoid, and polygon
\item compound regions union, intersection, difference, and complement.
\item extension of a region or group of regions to higher dimensions
\item masks
\end{itemize}
The documentation in the classes
 \htmladdnormallink{LCRegion}{../../lattices/implement/Lattices/LCRegion.html},
 \htmladdnormallink{LCSlicer}{../../lattices/implement/Lattices/LCSlicer.html}, and
 \htmladdnormallink{WCRegion}{../../images/implement/Images/WCRegion.html})
gives you more information about the various regions.

\medskip\noindent At this moment a region can not be defined in LEL itself. It is
only possible to use regions predefined in an image or another table.

\medskip\noindent When using Glish (as will normally be done), it is also possible to use
a region defined in Glish using the \$-notation.  This is explained in
more detail in the section discussing the \htmlref{interface to
LEL}{LEL:GLISHC}. 

\medskip\noindent A predefined region can be used by specifying its name.
There are three ways to specify a region name:

\begin{enumerate}
\item \texttt{tablename::regionname}  
\\The region is looked up in the given table (which will
usually be an image) in which it is stored.

\item \texttt{::regionname}
\\The region is looked up in the last table used in the expression.

\item \texttt{regionname}
\\Is usually equivalent to above. However, there is no syntactical
difference between the name of a region and a lattice/image.
Therefore LEL will first try if the name represents a lattice or
image. If not, the name is supposed to be a region name.
The prefix \texttt{::} in the previous way tells that the name
should only be looked up as a region.

\end{enumerate}

Examples are

\begin{verbatim}
  myimage.data[reg1]
  (myimage.data - otherimage)[::reg1]
  (myimage.data - otherimage)[myimage.data::reg1]
  myimage.data:nomask[myotherimage::othermask]
\end{verbatim}
In the first example region \texttt{reg1} is looked up in image
\texttt{myimage.data}. It is assumed that \texttt{reg1} is not the
name of an image or lattice.  It results in a lattice whose
shape is the shape of the bounding box of the region.  The
mask of the result is the and of the region mask and the lattice
mask.

\medskip\noindent In the second example it is stated explicitly that \texttt{reg1} is a
region by using the :: syntax.  The region is looked up in
\texttt{otherimage}, because that is the last table used in the
expression. The result is a lattice with the shape of the bounding box 
of the region.

\medskip\noindent In the third example the region is looked up in \texttt{myimage.data}.
Note that the this and the previous example also show that a region can be applied
to a subexpression.

\medskip\noindent In the fourth example we have been very cunning.  We have taken
advantage of the fact that masks are special sorts of regions.  We have
told the image {\tt myimage.data} not to apply any of its own masks.  We
have then used the {\tt []} operator to generate a mask from the mask
stored in a different image, {\tt myotherimage}.  This effectively
applies the mask from one image to another.  Apart from copying the
mask, this is the only way to do this. 

\medskip\noindent Unions, intersections, differences and complements of regions can be
generated and stored (in C++ and Glish).  However, it is also possible
to form a union, etc.  in LEL itself.  However, that can only be done if
the regions have the same type (i.e.  both in world or in pixel
coordinates). 
\\The following operators can be used:

\begin{itemize}
\item {\tt reg1 || reg2} to form the union.
\item {\tt reg1 \&\& reg2} to form the intersection.
\item {\tt reg1 - reg2} to form the difference.
\item {\tt !reg1} to form the complement.
\end{itemize}

The normal AIPS++ rules are used when a region is applied:

\begin{itemize}
\item A region in world or relative coordinates can only be applied
to an image (or a subexpression resulting in an image). Otherwise
there is no way to convert it to absolute pixel coordinates.
\item The axes of a region in world coordinates have to be axes in
the image (subexpression). However, the region can have fewer axes.
\item If a region has fewer axes than the image or lattice
the region is automatically extended to the full image
by taking the full length of the missing axes.
\end{itemize}


\section{Some further remarks}

\subsection{Optimization}
When giving a LEL expression, it is important to keep an eye
on performance issues.

LEL itself will do some optimization:
\begin{itemize}
\item As said in the introduction a LEL expression is evaluated
in chunks. However, a scalar subexpression is executed only once
when getting the first chunk.
E.g. in
  \begin{verbatim}
  lat1 + mean(lat2)
  \end{verbatim}
the subexpression \texttt{mean(lat2)} is executed only once
and not over and over again when the user gets chunks.

\item Often the exponent 2 is used in the \texttt{pow} function
(or operator \verb+^+). This is optimized by using multiplication
instead of using the system pow function.

\item When LEL finds a \htmlref{masked-off scalar}{LEL:MASKS}
in a subexpression, it does not evaluate the other operand.
Instead it sets the result immediately to a masked-off scalar.
Exceptions are the operators AND and OR and function \texttt{iif},
because their masks depend on the operand values.
\end{itemize}

The user can optimize by specifying the expression carefully.
\begin{itemize}
\item
It is strongly recommended to combine scalars into a subexpression to
avoid unnecessary scalar-lattice operations. E.g.
\begin{verbatim}
  2 * lat1 * pi()
\end{verbatim}
should be written as
\begin{verbatim}
  lat1 * (2 * pi())
or
  2 * pi() * lat1
\end{verbatim}
because in that way the scalars form a scalar subexpression
which is calculated only once. Note that the subexpression parentheses
are needed in the first case, because multiplications are done from
left to right.
\\In the future LEL will be optimized to shuffle the operands when
possible and needed.

\item
It is important to be careful with the automatic data type promotion
of single precision lattices. Several scalar functions (e.g. pi)
produce a double precision value, so using \texttt{pi} with a
single precision lattice causes the lattice to be promoted to double
precision. If accuracy allows it, it is much better to convert
\texttt{pi} to single precision.
E.g. assume \texttt{lat1} and \texttt{lat2} are single precision lattices.
\begin{verbatim}
  atan2(lat1,lat2) + pi()/2
\end{verbatim}
The result of \texttt{atan2} is single precision, because both
operands are single precision. However, \texttt{pi} is double
precision, so the result of \texttt{atan2} is promoted to double
precision to make the addition possible. Specifying the expression as:
\begin{verbatim}
  atan2(lat1,lat2) + float(pi())/2
\end{verbatim}
avoids that (expensive) data type promotion.

\item
\texttt{POW(LAT,2)} or \texttt{LAT}\verb+^+\texttt{2}
is faster than \texttt{LAT*LAT}, because it accesses lattice
\texttt{LAT} only once.

\item
\texttt{SQRT(LAT)} is faster than \texttt{LAT}\verb+^+\texttt{0.5}
or \texttt{POW(LAT,0.5)}

\item
\texttt{POW(U,2) + POW(V,2) $<$ 1000}\verb+^+\texttt{2} is considerably faster
than
\\\texttt{SQRT(SQUARE(U) + SQUARE(V)) $<$ 1000}, because it avoids the
\texttt{SQRT} function.

\item
LEL can be used with disk-based lattices and/or memory-based lattices.
When used with memory-based lattices it is better to make
subexpressions the first operand in another subexpression or a
function. E.g.
\\\texttt{lat1*lat2 + lat3}
\\is better than
\\\texttt{lat3 + lat1*lat2}
\\The reason is that in the first case no copy needs to be made of the
lattice data which already reside in memory. All LEL operators and
functions try to reference the data of their latter operands instead
of making a copy.
\\In general this optimization does not apply to LEL expression.
However, when using the true \htmlref{C++ interface}{LEL:GLISHC}
to classes like \texttt{LatticeExprNode}, one can easily use
memory-based lattices. In that case it can be advantageous to pay
attention to this optimization.

\end{itemize}

\subsection{Mask Storage}

In many of the expressions we have looked at in the examples, a mask has
been generated.  What happens to this mask and indeed the values of the
expression depends upon the implementation.  If for example, the
function you are invoking with LEL writes out the result, then both the
mask and result will be stored.  On the other hand, it is possible to
just use LEL expressions but never write out the results to disk.  In
this case, no data or mask is written to disk.   You can read
more about this in the \htmlref{interface}{LEL:GLISHC} section.


\section{\label{LEL:GLISHC}Interface to LEL}

There are two interfaces to LEL.  One is from Glish and the
other from C++.   It depends upon your needs which one
you access.  Most high level users of AIPS++ will access
LEL only via the Glish interface.

\subsection {Glish Interface}

The LEL interface in Glish is provided by the
\htmlref{Image}{images:image} tool (loaded with the script
\texttt{image.g}) \htmlref{imagecalc}{images:image.imagecalc.constructor} 
constructor, and through
the \htmlref{calc}{images:image.calc.function} tool function. 
These can be used to compose and/or execute a LEL expression.

\subsubsection {Simple String Expressions}

\medskip\noindent The \texttt{imagecalc} constructor evaluates the
expression and stores the result and mask in an output image.  If you
specify the output image name, it is written to a disk file of that
name.  If you don't give it, the output image is never written out; it
is evaluated every time an action (like
\htmlref{statistics}{images:image.statistics}) is requested. 

\begin{verbatim}
  im := imagecalc(outfile='outimage', pixels='inimage1+inimage2');
  im.statistics();
\end{verbatim}

\medskip\noindent The first command creates an image file \texttt{outimage} filling
it with the sum of the input images. The second command does
statistics on that new image.

\medskip\noindent Writing it as
\begin{verbatim}
    im := imagecalc(pixels='inimage1+inimage2');
    im.statistics();
\end{verbatim}
would do the same with the exception of creating the output image.
Instead the created image is transient; it only lives as an
expression and each time it is used the expression is evaluated.

\medskip\noindent We can use the function {\tt calc} on an already existing image.  Thus
\begin{verbatim}
  im := image('ngc1213');
  im.calc('ngc1213^2');
\end{verbatim}
would replace the pixels by the square of their value.


\medskip Sometimes you need to double quote the file names in your expression.
For example, if the images reside in a different directory as in
this example.

\begin{verbatim}
  im := imagecalc ('"dir1/im1" + "/nfs/data/im2"');
\end{verbatim}

\subsubsection {Symbol (or tool) substitution}

\medskip\noindent Images created/opened in Glish can be used with their Glish name
in a LEL expression. Similarly a region created in Glish with the
Regionmanager can be used with its Glish name.

\medskip\noindent It is also possible to embed other Glish variables and expressions in
a LEL command using the syntax \texttt{\$variable} and
\texttt{\$(expression)}. A variable can be a standard numeric scalar.
An expression has to result in a numeric scalar.

\medskip
E.g. one can make a Glish function like

\begin{verbatim}
    img1 := image('"/data/inimage'");
    img2 := imagecalc(pixels='min($img[$someregion], $clipvalue)');
\end{verbatim}
to return a transient image formed by a region in an image clipped at the
given clipvalue.

\medskip\noindent The substitution mechanism is described in more detail in the
\htmlref{substitute}{misc:substitute}
functions of module
\htmlref{misc}{misc} of the
\htmladdnormallink{User Reference
Manual}{../../user/Refman/Refman.html}.

\medskip\noindent The substitution mechanism uses the eval function in Glish.  As of
15-Jan-1999 eval only looks at global variables.  This means that in a
function one needs to create a global variable (with a unique name) if
the variable is to be used in a LEL command.  The global variable should
be deleted at the end of the function (with {\tt symbol\_delete}).  The
name can be made unique by using the function name as a suffix. 

\medskip\noindent In Glish applying a region to an image can also be done using the
\htmlref{subim}{images:image.subimage.function} function of an Image tool.
It forms an image from the given region in the input image.
This new image can be used in a LEL expression.
E.g.
\begin{verbatim}
  img := image('inimage');
  subimg := img.subimage(region=someregion);             # Virtual Image tool (a reference)
  img2 := imagecalc(pixels='min($subimg, $clipvalue)');  
\end{verbatim}
has the same result as the earlier example.  Both {\bf subimg} and {\bf im2}
are virtual images (not written to disk). 


\subsection {C++ interface}
This consists of 2 parts.  

\begin{enumerate}
  \item
    The function \texttt{command} in
    \htmladdnormallink{Images/ImageExprParse.h}
    {../../images/implement/Images/ImageExprParse.html}
    can be used to execute a LEL command. The result is a
    \htmladdnormallink{LatticeExprNode}
    {../../lattices/implement/Lattices/LatticeExprNode.html}
    object. E.g.
\begin{verbatim}
  LatticeExprNode seltab1 = ImageExprParse::command
         ("imagein1 + imagein2");
\end{verbatim}
    This example does the same as the Glish one shown above.

  \item
    The other interface is a true C++ interface having the
    advantage that C++ variables can be used. Class
    \htmladdnormallink{LatticeExprNode}
    {../../lattices/implement/Lattices/LatticeExprNode.html}
    contains functions to form an expression. The same operators
    and functions as in the command interface are available.
    E.g.
\begin{verbatim}
  Float clipValue = 10;
  PagedImage<Float> image("imagein");
  LatticeExpr<Float> expr(min(image,clipValue));
\end{verbatim}
    forms an expression to clip the image. Note that the expression is
    written as a normal C++ expression. The overloaded operators and
    functions in class 
    \htmladdnormallink{LatticeExprNode}
    {../../lattices/implement/Lattices/LatticeExprNode.html}
    ensure that the expression is formed in the correct way.
    \\ Note that a \texttt{LatticeExprNode} object is usually
    automatically converted to a templated \texttt{LatticeExpr} object,
    which makes it possible to use it as a normal \texttt{Lattice}.
    \\So far the expression is only formed, but not evaluated.
    Evaluation is only done when the expression is used in an
    operation, e.g. as the source of the copy operation shown below.
\begin{verbatim}
  PagedImage<Float> imout("imageout");
  imout.copyData (expr);
\end{verbatim}

  \end{enumerate}


\section{\label{LEL:EXAMPLES}{Examples}}
The following examples show some LEL expressions (equally valid 
in C++ or Glish).

Note that LEL is readonly; i.e. it does not change any value in
the images given. A function in the \texttt{image} client has to
be used to do something with the result (e.g. storing in another image).
\begin{description}
  \item[] \texttt{lat1+lat2}
    \\adds 2 lattices
  \item[] \texttt{mean(myimage:nomask)}
    \\results in a scalar value giving the mean of the image.
    No mask is used for the image, thus all pixels are used.
    The scalar value can be used as a lattice. E.g. it can be used as
    the source in the \texttt{image} function
    \texttt{replacemaskedpixels} to set all masked-off elements of a
    lattice to the mean.
  \item[] \texttt{complex(lat1,lat2)}
    \\results in a complex lattice formed by \texttt{lat1} as the
    real part and \texttt{lat2} as the imaginary part.
  \item[] \texttt{min(lat1, 2*mean(lat1))}
    \\results in a lattice where \texttt{lat1} is clipped at twice
    its mean value.
  \item[] \texttt{min(myimage, 2*mean(mymage[myregion]))}
    \\results in an image where \texttt{myimage} is clipped at twice
    the mean value of region \texttt{myregion} in the image..
  \item[] \texttt{lat1[lat1$>$2*min(lat1)]}
    \\results in a lattice with a mask. Only the pixels
    greater than twice the minimum are valid.
  \item[] \texttt{replace(lat1)}
    \\results in a lattice where each masked-off element in
    \texttt{lat1} is replaced by 0.
  \item[] \texttt{iif(lat1$<$mean(lat1),lat1*2,lat1/2)}
    \\results in a lattice where the elements less than the mean
    are doubled and the elements greater or equal to the mean are
    divided by 2.
\end{description}

Here follows a sample Glish session showing some of the LEL
capabilities and how Glish variables can be used in LEL.
\begin{verbatim}
duw01> glish -l image.g
- a := array(1:50,5,10)              # make some data
- global im1 := imagefromarray('im1', a);   # fill an image with it
- im1.shape()
[5 10]
- local pixels, mask
- im1.getregion(pixels, mask);       # get pixels and mask
- mask[1,1] := F                     # set some mask elements to False
- mask[3,4] := F
- im1.putregion(mask=mask);          # put new mask back
- global reg:=drm.box([1,1],[4,4]);  # a box region
- im2 := imagecalc(pixels='$im1[$reg]')     # read-only image applying region
- local pixels2, mask2
- im2.getregion(pixels2, mask2);     # get the pixels and mask
- print pixels2
[[1:4,]
    1 6 11 16
    2 7 12 17
    3 8 13 18
    4 9 14 19] 
- print mask2
[[1:4,]
    F T T T
    T T T T
    T T T F
    T T T T] 
- im1.replacemaskedpixels ('mean(im2)'); # replace masked-off values
- im1.getregion (pixels2, mask2);        # by mean of masked-on in im2
- print pixels2
[[1:5,]
    10.0714283 6  11 16         21 26 31 36 41 46
    2          7  12 17         22 27 32 37 42 47
    3          8  13 10.0714283 23 28 33 38 43 48
    4          9  14 19         24 29 34 39 44 49
    5          10 15 20         25 30 35 40 45 50]
\end{verbatim}

\section{Future developments}
In the near or more distant future LEL will be enhanced by adding new
features and by doing optimizations.
\begin{itemize}
  \item Handle slices like \texttt{image[1:10:2, 5:]}
        \\which defines the section directly in pixel coordinates (with
        stride 2 for the first axis).
  \item Do optimization by reordering the expression.
  \item Do optimization by recognizing common subexpressions.
\end{itemize}

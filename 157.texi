\input epsf.tex        % For including postscript figures         @c -*-texinfo-*-
\input texinfo 

@c %**start of header
@setfilename 157.info
@settitle FFTServer Class
@c %**end of header

@ifinfo
This file shows how to use the @sc{aips++} @code{FFTServer} class
to do Fast Fourier Transforms
Copyright @copyright{} 1993 AIPS++
@end ifinfo

@setchapternewpage off
@titlepage
@title Note 157: The AIPS++ FFTServer Class
@subtitle How to use the FFTServer class - definitions and tutorial
@author Anthony G. Willis and Philippe McLean
@vskip 0pt plus 1fill
Copyright @copyright{} 1993, 1994, 1995 AIPS++
@end titlepage


@node Top, Intro, (dir), (dir)
@comment  node-name,  next,  previous,  up
@c ======================================================================

@menu
* Intro::                       Introduction
* Frequency Domain Data Structures:: Structures used to represent
                frequency grids
* The FourierTool Base Class::
* General Methods::             General Purpose Methods
* Special Methods::             Some Special Methods
@end menu

@c ======================================================================

@node Intro, Frequency Domain Data Structures, Top, Top
@chapter Introduction

@strong{Most of the details in this document have been made obsolete by
the overhaul of the FFTServer class made in October 1997. It is now
recommended you read the class documentation for a description of how to
use the FFTServer class.}

The @sc{aips++} @code{FFTServer} class provides application programmers
with a flexible and efficient tool for doing multi-dimensional Fast
Fourier Transforms on @sc{aips++} Array objects.  This document describes the
public methods for this class and how to use them.  The @code{FFTServer}
class provides methods for in-place and non-destructive @sc{fft}s. An
in-place @sc{fft} modifies its argument in place; a non-destructive @sc{fft}
returns the transform as a new array, and leaves its argument
unchanged. The packing format used to represent Hermetian objects is
described, and a description of the implementations of the @sc{fft}, packing,
and unpacking methods in the @code{FFTServer} and @code{FourierTool}
classes is provided.

The low-level @sc{fft} routines used by the @code{FFTServer} tool are written
in @sc{fortran} and use the widely available public domain @sc{ncar} @sc{fftpack} code
available from Netlib. A multi-dimensional @sc{fortran} @sc{fft} routine
originally written by R.C. Singleton is also used. Modifications were
made to remove static size limits, and a double precision version was
written.

This document is intended for readers familiar with discrete and
continuous Fourier tranforms, and the use of other @sc{FFT}
implementations.

@ifinfo
This texinfo file has been compiled on @today{}.
@end ifinfo


@node Frequency Domain Data Structures, The FourierTool Base Class, Intro, Top
@comment  node-name,  next,  previous,  up
@chapter Frequency Domain Data Structures

One of the final goals of the radio astronomer is to obtain an image of
a piece of the sky. When we apply a Fourier transform to an image
composed entirely of real numbers (an example would be an image of the
Stokes parameter @var{I}) to the frequency, or @var{UV} domain, we find
that the @var{UV} grid is Hermetian: i.e. a complex data value at the
point @var{(-u, -v)} is the complex conjugate of the data point at
@var{(u, v)}. Consequently we need only sample half the @var{UV} grid in
order to obtain information about the entire @var{UV} domain. In
general, the Fourier transform of a real valued function is an
Hermetian function.
@iftex
@tex
If $f(x_1, x_2, x_3, ..., x_n)$ is a real-valued function of $n$ real
variables, then its Fourier transform $F(u_1, u_2, u_3, ..., u_n)$ will
be an Hermitian function of $n$ real variables. That is, $F(a, b, c,
..., n) = F^{*}(-a, -b, -c, ..., -n)$, where $F^{*}(a, b, c, ..., n)$ is
the complex conjugate of $F(a, b, c, ..., n)$. @cite{Bracewell [1]}.
@end tex
@end iftex

The Fourier transform of a complex image (e.g. the Stokes combination
@var{Q + iU)} will in general be complex valued, and will have the same storage
requirements as its time domain inverse.

In this document, @dfn{grid} refers to an arbitrary n-dimensional
@code{Array} object. The Fourier transform of a time domain sample is 
referred to as a @dfn{frequency domain} grid; a time domain sample is
also referred to as an @dfn{image}.

@section Hermetian frequency domain grids
The @code{FFTServer} class exploits the Hermetian property of frequency
domain grids to reduce the required storage by half. For example, in the
plane, we form pairs of points @var{(u,v)} and @var{(-u,-v)}; the value
at one is the complex conjugate of the value at the other, and we can
abitrarily choose either to represent both.

We may then represent a complex-valued transform as a sequence of real
and imaginary values, in the same amount of space required by time
domain inverse. Real and imaginary pairs are stored consecutively; for a
multi-dimensional object, real and imaginary pairs are indexed along the
first dimension.

Suppose @var{A} is an real valued array of size 4, representing two
complex numbers. Suppose @var{U} is an equivalent complex valued array,
of size 2, consisting of four real numbers. Then @var{A(0)} and
@var{A(1)} are the real and imaginary parts of a single complex number,
@var{U(0)}. Then @var{A(2)} and @var{A(3)} represent @var{U(1)} and
@var{U(-1)}. But what about @var{U(2)} and @var{U(-2)}? Well,
@var{U(2)=U(-2)}, since the sample @var{U} is periodic with period
4. But @var{U(4/2)=U(2)} is the Nyquist sample, and there is no room for
it in @var{A}. If @var{A} has size 5, then space will be required for
the imaginary component of @var{U(2)}, the last element. Thus another
array is required to store this Nyquist component. In general, if
@var{A} is a multi-dimensional object with dimensions @var{(a, b, c,
..., n)}, then the Nyquist array will have size @var{(2, b, c, ..., n)}
if @var{a} is even, and size @var{(1, b, c, ..., n)} if @var{a} is
odd. To simplify implementation and avoid ambiguity in the
representations, the size of the so-called Nyquist array associated with
@var{A} is @var{(2, b, c, ..., n)}.  Beware that ``Nyquist array'' is a
misnomer; if the first dimension @var{a} is odd, then there will be no
sample at the Nyquist frequency in @var{a}. Throughout this document,
@dfn{Nyquist array} will refer to this object.

The association of Hermetian grid and Nyquist array is referred to as
the @dfn{unpacked} format for an Hermetian grid.

It is possible to reduce this storage size, and pack the Nyquist array
into the Hermetian grid, by using the following properties:

@enumerate
@item 
There will be points whose values are their own conjugates. This
property is only true of points where every coordinate is either 0 or
@var{N/2}, where @var{N} is the size of the corresponding
dimension. Note that @var{N/2} is the Nyquist frequency. But if a
complex number is its own conjugate, then its imaginary part is zero. We
may store the real part of another such number in the imaginary part of
the first.


@item
Consider an array @var{A} with dimensions @var{(a, b, c, ..., n)}.  Consider
the set @var{X} of elements in @var{A} whose first coordinate is 0. Then
the conjugate @var{y} of a point @var{x} in @var{X} will also be in
@var{X}. If @var{a} is even, then the Nyquist array will also have this
property, since points in the Nyquist array have an implicit first
coordinate of @var{a}/2, the Nyquist frequency in @var{a}. Hence we may
combine @var{X} and the Nyquist array in @var{X}, and later reconstruct
both. If @var{a} is odd, then each row in the Nyquist array will contain
the real and imaginary components of the last element in the
corresponding row in @var{A}. The real component will be duplicated, for
convenience. Thus we need only save the imaginary components of the
Nyquist array; these will fit in exactly half of @var{X}. In either
case, we @dfn{pack} @var{X} and the Nyquist array into @var{X}, and
later @dfn{unpack} and reconstruct both.
@end enumerate

Thus we may represent an entire complex valued Hermetian frequency
domain sample in the same space required by its real valued inverse.
This is referred to as a @dfn{packed} format.

This section describes the layout of the Hermetian @var{UV} grid currently
used by the @sc{aips++} classes @code{FFTServer}, @code{FourierTool},
and @code{GridTool}.  We will describe the format using a 2-dimensional
@var{UV} grid as an example. First we consider the case when @var{M} is
even. This grid represents the transform of a real
image of size @var{M x N}.  The format of the @var{UV} grid is shown in Figure 1.
@iftex
@tex
\medskip
\epsfxsize=11cm
\epsfysize=9cm
\epsffile{uvgrid.eps}
@end tex
@end iftex

The @var{U} frequency values are sampled over the range @var{U = 0} to
@var{U=M/2}.  Here @var{M/2} is the Nyquist frequency in U. Since
each sample point has both a real and an imaginary value, we require
@var{M/2+1} complex numbers along this axis, or @var{2*(M/2+1)} 
pairs of floating point numbers.  We do not need to sample in the
range @var{-(M/2 - 1)} to @var{-1} because of the Hermetian symmetry of
the @var{UV} frequency domain containing Fourier components of a real
image. @var{R} and @var{I} denote real and imaginary components.

The @var{V} frequency values are sampled over the range @var{V =-N/2,
..., -1, 0, 1, ..., N/2-1}.  Here, @var{-N/2} is the Nyquist frequency
in V. Therefore we have a total of @var{N} sample points along this axis.

For example, if we are transforming a 1024 x 1024 real image, then the
size of the @var{UV} grid will actually be 1026 x 1024. However, as the
figure suggests, we can split the grids up into two sub grids, one
containing @var{U} data points up to @var{M/2-1}, and a separate array
containing the Nyquist @var{U} point at @var{M/2}. In this way, most of
the frequency domain data can be stored in an array the same size as
the real-valued time domain image.

This separate array is the @dfn{Nyquist array} and is private member
object @code{FourierTool} object.

Now consider the case when both @var{M} and @var{N} are both odd.
@iftex
@tex
\medskip
\epsfxsize=10cm
\epsfysize=9cm
\epsffile{uvgridodd.eps}
@end tex
@end iftex

Since @var{N} is odd, there will be no Nyquist component in @var{V}, and
the imaginary component at @var{(0,-(N-1)/2)} will in general @emph{not}
be zero.  Since @var{M} is odd, there will be no Nyquist component in
@var{U}, and the Nyquist array will be used to store the real and
imaginary components of the last elements in each row of the grid. The
real element will be duplicated in the first component of each row in
the Nyquist array.

Although Figures 1 and 2 describe 2-dimensional grids, the
@code{FFTServer} class can perform @sc{FFT}s on arbitrary
multi-dimensional objects. You should view the grid and Nyquist arrays
as a sequence of rows. Each row is a sequence of real/imaginary
pairs. If the first dimension is even, then the Nyquist row will contain
the real and imaginary components of the Nyquist sample. If the first
dimension is odd, then the Nyquist row will contain the real and
imaginary components of the last frequency sample. The real component
will be duplicated in the last element of the row in the grid.

Normally, any complex arrays that you create from sampled data should
not have any values at the Nyquist frequency. A sample at the Nyquist
frequency may indicate that your sampling interval is incorrect.
@code{GridTool} will warn you when you place data in a @var{UV} grid at
the Nyquist frequency.

An @code{FFTServer} object contains a @code{private} Array object which
is used to store the Nyquist array. We can use the packing technique
described above to store the entire Nyquist array in the grid; this
allows the user to store the entire frequency domain sample in the same
space required by its real valued inverse.

Two different packing techniques are used: one, when the first dimension
is even, and the other, when the first dimension is odd. During packing,
half of the Nyquist data are copied to the @var{UV} grid.

@iftex
The following figure describes the packing of a 2-dimensional grid when
the first dimension @var{M} is even:

@tex
\medskip
\hbox{
\epsfxsize=9cm
\epsfysize=9cm
\epsfbox{packeven.eps}
}
@end tex
@end iftex

Both arrays are examined in storage order; @sc{aips++} @code{Array}
objects are stored in @sc{fortran} array order. The first index in a
@sc{FORTRAN} multi-dimensional array varies fastest as elements in
memory are examined sequentially.

If @var{M} is even, then the Nyquist array will have the same symmetry
properties as the @var{U=0} column of the grid, and the imaginary
components at the Nyquist and zero frequencies in @var{V} will be
zero. There we copy the real component from the Nyquist array to the
imaginary component of the grid. The other elements are copied from the
Nyquist array to the @var{U=0} column of the grid. The overwritten
values can be computed later, by using the fact that the value at
@var{(u, v)} is the complex conjugate of the point at @var{(-u, -v)}. If
@var{M} is odd, then the Nyquist array will not have any symmetry
properties, but its real component will be duplicated in the last column
of the @var{UV} grid. Then we need only copy the imaginary components from the
Nyquist array to the @var{UV} grid.

@iftex
The following figure describes the packing of a 2-dimensional grid when
the first dimension @var{M} is odd and the second dimension @var{N} is
even:

@tex
\medskip
\hbox{
\epsfxsize=12cm
\epsfysize=9.5cm
\epsfbox{packodd.eps}
}
@end tex
@end iftex

The imaginary components of the Nyquist array are copied sequentially,
in storage order, to succesive real and imaginary components in the
@var{U=0} column of the @var{UV} grid. If the element in the @var{UV} grid is its
own conjugate, then we cannot overwrite the real component, so only the
imaginary part is used.

@iftex
The following figure describes the packing of a 2-dimensional grid when
both dimensions @var{M} and @var{N} are odd:

@tex
\medskip
\hbox{
\epsfxsize=13cm
\epsfysize=8cm
\epsfbox{packodd1.eps}
}
@end tex
@end iftex       

Many of the @code{FFTServer} methods expect frequency domain data in
packed form, and the data are unpacked prior to the transform. The
behaviour for each method is specified below.
@xref{General Methods, , FFTServer methods}, for details.

The first step of unpacking is the reverse of the packing process. Data
are copied from the @var{U=0} column of the @var{UV} grid to the Nyquist
array. The second step recomputes the values that were used to store
Nyquist data during packing; the location of an element's conjugate in
the grid must be determined. If the first dimension is even, this is
performed in both the grid and the Nyquist array.  If the first
dimension is odd, then the conjugate property is only true for the
@var{U=0} column of the grid. The real components of the Nyquist array
are copied from the last element of each row in the @var{UV} grid.

@iftex
The computing of complex conjugates during reconstruction is described
in the following figure. The figure depicts a @var{UV} grid with even
dimensions.
@tex
\medskip
\hbox{
\epsfxsize=12cm
\epsfysize=9cm
\epsfbox{unpack1.eps}
}
@end tex
@end iftex

Most @sc{fft}s expect frequency data to be ordered @var{(0, 1, ...,
Nyquist, ..., -1)}, where the zero frequency sample is at the origin in
the array. Our @var{UV} grid (Figure 1) has its @var{V} frequencies ordered
@var{(Nyquist, ..., -1, 0, 1, ..., Nyquist - 1)}; the zero frequency is
at the mid point.  The @dfn{phase center} is the zero frequency sample.
The @dfn{image center} is the zero time sample, or @dfn{phase
reference}. Note that the phase reference is a time domain sample, not a
frequency domain sample, since it is the sample at @var{t=0}, and its
phase offset is zero.

Thus, before performing a transform from the frequency to time domain,
it is necessary to reorder the @var{UV} grid. In the 2-dimensional case, this
is equivalent to flipping the top and bottom halves of the array. This
operation is done by the @code{exchangeUV} method described in Chapter 5
and shown in the diagram below.  Since a @sc{dft} frequency domain
sample is periodic in every dimension, this process is equivalent to
shifting the sample in frequency by half the period, in all dimensions
but the first.

@iftex
@tex
\medskip
\epsfxsize=13cm
\epsfysize=9cm
\epsffile{exchangeuv.eps}
@end tex
@end iftex

The phase reference position of a real image that emerges from an @sc{fft}
will be in the lower left hand corner of the image. However, since radio
astronomers normally define the phase reference position to be the
centre of the field, we must flip the quadrants of the image that
emerges from the @sc{fft} to obtain a picture that makes sense to most
of us. The @code{flipImage} method implements this operation. Figure 6
illustrates the process for the 2 dimensional case.  Our particular
sequence of operations means that the phase reference pixel in the image
will be located at point @var{(M/2, N/2)}, or @var{(512, 512)} for
an image of size 1024 x 1024 points, if indexing starts from 0.

The @code{flipImage} method is equivalent to moving the object through
the periodic sample space. The shift is by half the image size, in each
dimension.

If any dimension is odd, then the flipImage operation is not its own
inverse. For example, suppose V is the vector @var{V=(0,1,2,3,4)}.  If
we choose the middle element 2 as the phase center, and exchange halves,
the result is @var{(2,3,4,0,1)}. If we again choose the middle element
as the phase center and exchange halves, the result is
@var{(4,0,1,2,3)}.  To ensure invertibility, we must choose the middle
point according to the domain in which we are flipping.  Thus, the image
center and the phase center will in general be two different points. The
@code{FFTServer} and @code{FourierTool} classes define these points as
follows.

@enumerate
@item
If a dimension @var{i} has an even size @var{N}, the samples will be
ordered @var{-N/2, ..., -1, 0, 1, ..., N/2-1}. If samples are indexed
@var{(0, 1, ..., N-1)}, then both the phase and image centers are
defined to be the point with index @var{N/2}.

@item
If a dimension @var{i} has odd size @var{N}, the the samples will be
ordered @var{-(N-1)/2, ..., -1, 0, 1, ..., (N-1)/2)}. If samples are
indexed @var{(0, 1, ..., N-1)}, then the phase center is defined to be
the point with index @var{(N-1)/2}. That will be the middle point. The
image center is defined to be the point with index @var{(N+1)/2}.

@item
The first dimension is given special treatment, according to whether the
object represents an Hermitian grid, a full complex grid, or a real
time-domain sample. If the object is an Hermitian frequency-domain
sample, then the phase center will always have index zero. Otherwise,
the centers will be defined as in the first two rules.
@end enumerate

For example, suppose @var{A} is a five-dimensional array representing an
Hermitian frequency domain sample, with dimensions
@var{(4,5,2,3,4)}. Then the phase center will be the pixel with
coordinates @var{(0,2,1,1,2)}, assuming that indexing starts from 0. The
image center will be the pixel with coordinates @var{(0,3,1,2,2)}. If
@var{A} is a fully complex grid, the phase center will be the pixel with
coordinates @var{(2,2,1,1,2)}.

@strong{Caution:} The @code{FFTServer}, @code{FourierTool}, and
@code{GridTool} classes expect data to be treated in this manner. In
particular, it is assumed by the @code{pack}, @code{unpack},
@code{flipImage}, and @code{exchangeUV} methods. If you expect a
different phase or image center, your images will be corrupt!

Methods are also provided for users who wish to perform direct
@sc{fft}s; both complex to complex and real to real methods are
provided. No image flipping, packing, or unpacking is done in those
cases. These methods should be used by programmers requiring an optimal
@sc{dft}.

@strong{Note:} The @sc{FFT} functions used by the @sc{FFTServer} class
can perform an @sc{FFT} on an array of arbitrary size. A multi
dimensional @sc{FFT} is reduced to a series of one-dimensional
@sc{FFT}s. Given a one-dimensional array of size @var{n}, the running
time of the @sc{FFT} algorithm is a function of the prime factorization
of @var{n}. If @var{n} is a power of 2, the algorithm has an asymptotic
time complexity in @var{O(n log n)}. For large primes @var{n}, the
running time will approach @var{O(n*n)}. 

Note that image flipping is equivalent to shifting in either the time or
frequency domains; a choice must be made regarding phase-center
convention. Frequency or time shifting theorems can also be applied
before or after a transform, to achieve the same effect. The
@code{shift} method uses this fact; the transform method @code{cxfft}
uses @code{shift}. However, for an image with odd size, the multipliers
will in general be complex valued, and so this technique cannot be used
for Hermetian grids.

@iftex
This figure describes the image flipping of a fully complex image.
@tex
\medskip
\epsfxsize=7cm
\epsfysize=7cm
\epsffile{flipimage.eps}
@end tex
@end iftex

The steps that occur inside the @sc{fft} method for transforming from
the frequency domain to the time domain are
@enumerate
@item
unpack the @var{UV} frequency data
@item
exchange the @var{UV} data to move the phase center to the
@code{Array}'s origin
@item
perform an inverse @sc{fft} from the frequency to the time domain
@item
flip the resulting image
@end enumerate

During an @sc{fft} from the image domain to the frequency domain,
we perform these steps in reverse order.

@enumerate
@item
flip image to move the phase reference point to the @code{Array}'s origin
@item
do a forward @sc{fft} from the image domain to the frequency domain
@item
exchange the @var{UV} data to move the phase center to the center of the grid
@item
pack the @var{UV} frequency data 
@end enumerate

@section Full Complex @var{UV} grids

In general, the transform of a complex image will be a complex image
without Hermetian symmetry. In this case, we must sample and store the
entire domain.


@iftex
For example, consider a @var{UV} grid of dimensions @var{M x N}, where both
@var{M} and @var{N} are even. Then the grid will be structured as
follows:

@tex
\bigskip
\hbox{
\epsfxsize=9cm
\epsfysize=9cm
\epsfbox{complexuv.eps}
}
@end tex
@end iftex

If we flip the quadrants of this @var{UV} grid, then the data in U will be
ordered from @var{(0, ..., M/2-1, Nyquist, ..., -1)} and the data in V
will be ordered from @var{(0, ..., N/2-1, Nyquist, ..., -1)}. As
discussed in the previous section, this is the sequence expected by most
@sc{fft} algorithms.  Then we may perform a forward complex to complex
@sc{fft}.  The transformed result will have its phase
reference position in the lower left hand corner of the image,
as did the real image described in the previous section. So we must
again flip the quadrants of the image to obtain one with its phase
reference point at the centre.  The steps that occur inside the full
complex @sc{fft} method for going from the frequency domain to the
complex image domain are

@enumerate
@item
flip @var{UV} grid to move zero frequency sample to origin
@item
do @sc{fft} from frequency to time domain
@item
flip complex image that comes out of @sc{fft}
@end enumerate

During a fully complex @sc{fft} from the time domain to the frequency domain,
we perform these steps in reverse order.

@enumerate
@item
flip complex image to move phase reference point to origin
@item
do @sc{fft} from complex image domain to @var{UV} frequency domain
@item
flip the quadrants of the @var{UV} data to arrange frequencies with 
zero frequencies in centre of the @var{UV} grid
@end enumerate

@node The FourierTool Base Class, FourierTool Methods, Frequency Domain Data Structures, Top
@comment  node-name,  next,  previous,  up
@chapter Base Class Methods
@section Class @code{FourierTool}
@menu
* FourierTool Methods::
@end menu

The @code{FFTServer} class is derived from the @code{FourierTool} base
class.  A @code{FourierTool} object contains the Nyquist data array used
during the manipulation of Hermetian grids, and the class provides
methods to manage this array. Currently the @code{FFTServer} and
@code{GridTool} classes are derived from this base class.  

@iftex
This inheritance hierarchy is shown below.
@tex
\bigskip
\hbox{
\epsfxsize=6.5cm
\epsfysize=6.5cm
\epsfbox{fourierhierarc.eps}
}
@end tex
@end iftex

The class @code{FourierTool<T, S>} is a template class with two
parameters. The only legal instantiations of this class or those
derived from it are

@itemize @bullet
@item
@code{FourierTool<float,Complex>}
@item
@code{FourierTool<double,DComplex>}
@end itemize

This is to ensure that the class methods may always map between real and
complex valued floating point types of a given precision.

@node FourierTool Methods, General Methods, The FourierTool Base Class, The FourierTool Base Class
@comment  node-name,  next,  previous,  up
@section @code{FourierTool} Methods

This section describes the use of the @code{public} @code{FourierTool}
methods. Examples of using these methods are shown in Chapter 6.

Note that the only legal instantiations of @code{FourierTool} are
@itemize @bullet
@item
@code{FourierTool<float,Complex>}
@item
@code{FourierTool<double,DComplex>}
@end itemize
@noindent
hence the parameter @code{T} will refer to a real floating point type
and the parameter @code{S} will refer to a complex floating point type.

@sp 1

@itemize @bullet
@item
     @code{void pack(Array<T> &uv_grid);}
@item
     @code{void pack(Array<S> &uv_grid);}
@end itemize 

These methods pack the @code{FourierTool} object's Nyquist array into
the grid @code{uv_grid}. All sampled frequency domain data are stored in
@code{uv_grid}.

@sp 1

@itemize @bullet
@item
     @code{void unpack(Array<T> &uv_grid);}

@item
     @code{void unpack(Array<S> &uv_grid);}
@end itemize 

These methods extract the Nyquist data from the packed @code{uv_grid}
object, and store them in the @code{FourierTool} object's Nyquist array.
They then restore all data in the Hermetian grid @code{uv_grid},
overwriting those values that were used to store the packed data.

The figures in the previous chapter illustrate the packing and
unpacking operations in a graphical format.

@sp 1

@itemize @bullet
@item
     @code{void reset();}
@end itemize 

This method initializes the Nyquist array to zero.

@sp 1

@itemize @bullet
@item
     @code{const Array<T> &extractNYF();}
@item
     @code{const Array<S> &extractNYC();}
@end itemize 

These methods return a copy of the Nyquist array. @code{extractNYF}
returns a real valued array with first dimension of size 2; complex
values are represented as consecutive real and imaginary pairs.
@code{extractNYC} returns a complex valued array with first dimension of
size 1.

@sp 1

@itemize @bullet
@item
     @code{void insertNYF(const Array<T> &arr);}
@item
     @code{void insertNYC(const Array<S> &arr);}
@end itemize 

These methods copy the array @code{arr} into the @code{FourierTool}
object's internal Nyquist array. The first accepts a real valued array
as a parameter; the second accepts a complex valued array. The
dimensions of @code{arr} must be the same as the existing Nyquist array;
since the internal Nyquist array is stored as a real array, its first
dimension will be of size 2. An equivalent complex valued array will
have a first dimension of size 1.

@sp 1

@itemize @bullet
@item
     @code{void expand(Array<T> &arr, int by1ifodd=0);}

@item
     @code{void expand(Array<S> &arr, int by1ifodd=0);}
@end itemize 

These methods increase the size of the first dimension of @code{arr} by
2. Each row in the internal Nyquist array will be copied to the two new
elements at the end of each row in @code{arr}.  If @code{by1ifodd != 0},
and the first dimension in @code{arr} is odd, then @code{expandby1(arr)}
will be invoked instead.

@emph{Note:} Currently these methods copy the entire array @code{arr}.

@sp 1

@itemize @bullet
@item
     @code{void expandby1(Array<T> &arr);}

@item
     @code{void expandby1(Array<S> &arr);}
@end itemize 

These methods increase the size of the first dimension of @code{arr} by
1. The imaginary component of each row in the internal Nyquist array
will be copied to the new element at the end of each row in @code{arr}.

@emph{Note:} Currently these methods copy the entire array @code{arr}.

@sp 1

@itemize @bullet
@item
     @code{void shrink(Array<T> &arr, int by1ifodd=0);}

@item
     @code{void shrink(Array<S> &arr, int by1ifodd=0);}
@end itemize 

The last two elements of each row in @code{arr} are copied to each row
in the Nyquist array. Then the size of the first dimension of @code{arr}
is reduced by two.q If the first dimension of @code{arr} is odd and
@code{by1ifodd != 0}, then @code{shrinkby1(arr)} will be invoked
instead.

@emph{Note:} Currently these methods copy the entire array @code{arr}.

@sp 1

@itemize @bullet
@item
     @code{void shrinkby1(Array<T> &arr);}

@item
     @code{void shrinkby1(Array<S> &arr);}
@end itemize 

These methods reduce the size of the first dimension of @code{arr} by 1.
The imaginary component in each row of the internal Nyquist array will
be copied to the new element at the end of each row in @code{arr}. 

@emph{Note:} Currently these methods copy the entire array @code{arr}.


@c ======================================================================
@node General Methods, Special Methods, FourierTool Methods, Top
@comment  node-name,  next,  previous,  up
@chapter General Purpose Methods

This chapter describes the @code{public} @code{FFTServer} methods which
will be most frequently used. This set includes constructors and the
transform methods. 

Note that the only legal instantiations of @code{FFTServer} are
@itemize @bullet
@item
@code{FFTServer<float,Complex>}
@item
@code{FFTServer<double,DComplex>}
@end itemize
@noindent
hence the parameter @code{T} will refer to a real floating point type
and the parameter @code{S} will refer to a complex floating point type.

@itemize @bullet
@item
     @code{FFTServer();}
@item
     @code{FFTServer<T,S> (Array<T>&);}
@item
     @code{FFTServer<T,S> (Array<S>&);}
@item
     @code{FFTServer<T,S> (IPosition&);}
@end itemize 


These are the constructors for the class.  Since the size of the
internal Nyquist array is determined by the size of your working array,
an @code{FFTServer} object must be constructed or @code{Set} with an
@code{Array} or @code{IPosition} object before use.

The default constructor associates the new @code{FFTServer} object with
a 1 dimensional @code{Array} of 0 size. If you use this constructor
explicitly, you must later use the @code{Set} method to resize the
object before doing any transforms.

Once the size of an @code{FFTServer} object is determined, you may
safely use it to perform @sc{FFT}s on different @code{Array} objects.  A
transform on a different @code{Array} objects will be safe if the
contents of the internal Nyquist array are not relevant to, or will not
be used during, the transform. See the transform method descriptions for
more details.

The @code{Array} or @code{IPosition} object may be of arbitrary size and
dimension. You use also any objects of classes derived from
@code{Array}, such as @code{Vector}s, @code{Matrix}es, or @code{Cube}s.

Some of the @sc{fortran} routines used by the @code{FFTServer} class
separate the factorization of integers and the computation of
trigonometric functions into initialization subroutines. This saves
computation time when performing repeated transforms on @code{Vector}s
of the same size. The constructors perform this initialization,
affording you this optimization.

@itemize @bullet
@item
@code{void Set(const Array<T> &arr);}
@item
@code{void Set(const Array<S> &arr, int has_ny=0);}
@item
@code{void Set(const IPosition&);}
@end itemize 

These methods resize the @code{FFTServer} object to conform with the
size @code{arr}. They should be used when an existing @code{FFTServer}
object is to perform transforms on a new array of a different size. The
array can be specified, or an @code{IPosition} object can be passed
specifying an @code{Array}'s shape.

The @code{has_ny=0} parameter for the complex case specifies that the
@code{arr} parameter has an extra column of Nyquist data; this would be
the case if @code{arr} had been @code{expand}ed.

Here is an example of creating an @code{FFTServer} object.

@smallexample
Matrix<float> abc(128,128);
FFTServer<float,Complex> fft(abc);
@end smallexample

An @code{FFTServer} object called @code{fft} has been created and can be
used to perform @sc{fft}s on the @code{Matrix} @code{abc} of size
@var{128 x 128}, or other @code{Array} objects of the same size. (And
different sizes, see the discussion above.)

An equivalent initialization could be done by

@smallexample
Matrix<float> abc(128,128);
IPosition Shape(abc.shape()); // note that the 
                              // IPosition(const IPosition&) constructor
                              // uses copy, not reference semantics
FFTServer<float,Complex> fft(Shape);
@end smallexample
The next example constructs an @code{FFTServer} object with a
@code{Complex} array.

@smallexample
Matrix<Complex> abc(128,128);
FFTServer fft_complex<float,Complex> (abc);
@end smallexample

The object @code{abc} can be used to perform @sc{fft}s on any two
dimensional Complex array of size 128 x 128, since the Nyquist array is
@emph{not} used during full complex to complex transforms. 
     
@sp 1

@itemize @bullet
@item
    @code{~FFTServer();}
@end itemize 

The class destructor. It is currently trivial.

@sp 1

@itemize @bullet
@item
@code{FFTServer<T,S> &operator=(const FFTServer<T,S>&);}
@end itemize

The copy constructor. It has copy semantics.

For all transforms, the @code{dir} parameter specifies the direction of
the transform:

@itemize @bullet
@item If @code{dir > 0}, then a forward @sc{fft}
will be performed. 

@item
If @code{dir <= 0}, then a backward @sc{fft} will be
performed. In the current version of the @code{FFTServer} class,
@code{dir == 0} always means perform a backward transform.

@item
The case @code{dir == 0} has additional method specific meaning; for example,
@code{fft} will not normalize the array after the backward transform.

@end itemize

Usually, the result of an inverse transformation will be normalized;
every element will be multiplied by the factor @var{1/N}, where @var{N}
is the number of elements in the array.

@sp 1

@itemize @bullet
@item
    @code{void fft(Array<T> &arr, int dir);}
@end itemize 

This method performs an in-place forward or backward @sc{fft} on
@code{arr}. The direction is specified by dir. The array @code{arr} is
real-valued. After a forward transform, @code{arr} will be a packed
Hermetian grid with complex values arranged as consecutive real,
imaginary pairs. The inverse transform expects a packed Hermetian grid
with complex values arranged as consecutive real, imaginary pairs; after
the transform, @code{arr} will be a normalized, real valued time domain
sample.

This method flips @code{arr} before and after the transform.

Normalization of @code{arr} is performed after a backward transform
unless @code{dir == 0}.

@sp 1

@itemize @bullet
@item  
    @code{void nyfft(Array<T> &arr, int dir);}
@end itemize 

This method performs an in-place forward or backward @sc{fft} on
@code{arr}; the behaviour is identical to the method @code{fft}, except
that the internal Nyquist array is not read. Rather, implied Nyquist
data are stored in the last two elements of each row in @code{arr}. If
the size of that dimension is odd, then the real component of the last
element will be duplicated after a forward transform. During a forward
transform, the last two elements will be set, and the internal Nyquist
array will also be set, for convenience. During a backward transform,
the last two elements will be read from; after the transform, they
should be zero.  The internal Nyquist array is neither modified nor read
during a backward transform.

The size of @code{arr} should be @var{(x+2, y, z, ..., n)}, where
@var{x} is the implied true size of the real valued time domain sample.

The method flips the image before and after the transform.

Normalization of @code{arr} is performed after a backward transform
unless @code{dir == 0}. 

@sp 1


@itemize @bullet
@item
@code{void cxfft(Array<S> &arr, int dir, int center=1);}
@end itemize 

This method performs an in-place complex to complex transform on the
array @code{arr}. The internal Nyquist array is neither read nor
modified. @code{arr} is flipped before and after the
transform. Normalization of @code{arr} is performed after a backward
transform unless @code{dir==0}. If @code{center==0}, no flipping is
done.

This method can be used with any @code{FFTServer} object, regardless of
size, since the internal Nyquist array is not referenced.


@emph{Note:} The following methods @code{rcfft}, @code{crfft},
@code{rcnyfft}, and @code{crnyfft} copy the entire array several times.
Avoid using them if speed is your first concern; they are provided for
convenience.

@sp 1

@itemize @bullet
@item
     @code{Array<S> rcfft(Array<T> &rdata);}
@end itemize 

This member performs a forward transform on @code{rdata}, and returns
the normalized Hermetian result as a packed complex array. If the first
dimension of @code{rdata} is odd, then @code{expandby1} will be invoked
on the result; thus @code{crfft} will not in general be its inverse. See
below.

Flipping is done before and after the transform. @code{rdata} is not
modified.

Here are some examples using this method.

@smallexample
Matrix<float> m1(512,512); m1 = float(0.0);
m1(256, 256) = 10.0;      // assign some data to matrix 
m1(299, 349) = 20.0;      //   m1
FFTServer ffts<float,Complex>(m1);   
        // initialize an FFTServer object
Matrix<Complex> cm1 = ffts.rcfft(m1); 
        // do real to complex fft

Matrix<double> m2(179,159); m2 = float(0.0);  
        // odd sized double array
m2(25, 25) = 100.4;     
        // assign some data to m2
m2(120, 105) = 110;

FFTServer ffts2<double,DComplex>(m2);
Matrix<DComplex> cm2 = ffts.rcfft(m2); 
                                // real to complex fft
                                // note that expandby1 has been called.
                                // since the first dimension of m2 is odd.
                                // the size of the first dimension
                                // of cm2 will be 90

// do the reverse transform. We must set shrinkodd to 1.
Matrix<double> m2back = ffts.crfft(m2, 1);

// Now m2back will be the same as m2.

@end smallexample

@code{show_how_uv_mat} is a complex array of size 256 x 512, 
containing the uv data in a packed format.

Since @code{rcfft} works with arrays, the same type of operator will work
with either vectors, matrices or cubes.

@smallexample
Vector<float> show_how_vec(512); show_how_vec = float(0.0);
show_how_vec(256) = 10.0;           // assign some data to vector 
show_how_vec(299) = 20.0;           //   show_how_vec
FFTServer show_fft_vec<float, Complex> (show_how_vec); 
                                    // initialize an FFTServer object, 
                                    //   show_fft_vec
Vector<Complex> show_how_uv_vec = show_fft_vec.rcfft(show_how_vec); 
                                    // do real to complex fft
@end smallexample

@code{show_how_uv_vec} is a complex vector of size 256, containing the
frequency data in a packed format.  For a one-dimensional vector, this
means that the real part of the first complex point is the real value
for frequency 0, and the imaginary part of the first complex point is
the real value for the Nyquist frequency.

@itemize @bullet
@item
     @code{Array<T> rcnyfft(Array<T> &arr);}
@end itemize 

Performs a forward transform on @code{arr}, and returns the result as a
normalized complex array. The treatment of @code{arr} is as in
@code{nyfft}; except if the first dimension is odd, then the method
@code{expandby1} will be invoked on the complex result. Thus
@code{crnyfft} is not always the inverse of this operation. See below.


@itemize @bullet
@item
     @code{Array<T> crfft(Array<S> &arr, int do_scale=1, int shrinkodd=0);}
@end itemize 

Performs an inverse transform on the packed Hermetian complex array
@code{arr}, and returns the result as a real array. @code{arr} will be
normalized after a backward transform, unless @code{do_scale == 0}. If
@code{arr} was the result of @code{rcfft} on an array with a first
dimension of odd size, then @code{shrinkodd} should be set to 1. The
method @code{shrinkby1} will be invoked on the object first.

Here is an example of this method.

@smallexample
Matrix<Complex> show_how_cmplx(256,512); show_how_cmplx = Complex(0.0,0.0);
show_how_cmplx(128, 256) = Complex(10.0, 0.0);  
                           // assign some data to matrix show_how_cmplx
show_how_cmplx(149, 349) = Complex(20.0,10.0);  

FFTServer show_fft_cmplx<float, Complex> (show_how_cmplx);   
                           // initialize an FFTServer object, show_fft
Matrix<float> show_how_image = show_fft_cmplx.crfft(show_how_cmplx); 
                           // do complex to real fft
@end smallexample

@code{show_how_image} is a real matrix of size 512 x 512 containing the image.

Since @code{crfft} works with arrays, the same type of operator will work
with either vectors, matrices or cubes.

@smallexample
Vector<Complex> show_how_vec(256); show_how_vec = Complex(0.0);
show_how_vec(128) = Complex(10.0,10.0); 
                           // assign some data to vector show_how_vec
show_how_vec(58) = Complex(20.0,5.0);      

FFTServer show_fft_vec<float, Complex> (show_how_vec);   
                           // initialize an FFTServer object, 
                           //   show_fft_vec
Vector<float> show_how_vector = show_fft_vec.crfft(show_how_vec); 
                           // do complex to real fft

// odd example, showing use of shrinkodd
Vector<double> v1(17);   // vector of size 17
v1=0;                   // assign some data
v1(1)=15;
FFTServer fft2<double, DComplex> (v1);

Vector<DComplex> cv1=rcfft(v1); // cv1 is a complex vector of length 9
                                // it has been expanded by 1

                                // must set shrinkodd to 1, because 
                                // v1 is odd size
Vector<double> v1same=crfft(cv1, 1, 1)
                                // v1same should now be equal to v1
@end smallexample

@code{show_how_vector} is a real vector of size 256.

By default, @code{crfft} will normalize the data before returning it.
The scaling factor is @var{1/(number of elements in @code{data})}. If
@code{do_scale==0}, the result will not be normalized after a backward
transform. 

If you are making maps from a uv grid, you would want to avoid this
automatic scaling since it is likely that the sum of the weights associated
with the uv grid will not correspond to the automatic scaling factor
defined above.

@sp 1

@itemize @bullet
@item
     @code{Array<T> crnyfft(Array<S> &arr, int do_scale=1, int shrinkodd=0);}
@end itemize 

Performs an inverse transform on the Hermetian complex array @code{arr},
and returns the result as a real array. Each row in @code{arr} should
have an additional complex element at the end containing the Nyquist
component, as in @code{nyfft}. The result will be normalized unless
@code{do_scale == 0}. If @code{arr} was the result of @code{rcnyfft} on
an array with a first dimension of odd size, then @code{shrinkodd}
should be set to 1. The method @code{shrinkby1} will be invoked on the
object first.

Here is an example demonstrating the use of crnyfft and rcnyfft:

@smallexample

Cube<float> c(3, 4, 4);
        // cube with an odd first dimension
FFTServer<float,Complex> ffts1(c);
Cube<Complex> cx = ffts1.rcnyfft(c); 
        // cx is a complex cube with dimensions (2, 4, 4)

        // must set shrinkodd to 1 if we want the size to be interpreted
        // correctly
Cube<float> csame = crnyfft(cx, 1, 1)

        // csame and c should be the same

IPosition size(5); 
        // let's make a 5 dimensional array
size = 4;
size(3) = 7;
size(2) = 9;    
        // size now looks like (4, 4, 9, 7, 4);
Array<double> arr(size); 
        // define a 5 dimensional array of doubles
        // ... initialize arr ...

FFTServer<double,DComplex> ffts2(size); 
        // create our FFTServer object

Array<DComplex> carr = ffts2.rcnyfft(arr);
        // ok, carr is a complex array with dimensions (3, 4, 9, 7, 4);
        // that's  3 = (4/2) + 1 for the Nyquist part

        // Do the inverse. Don't have to set shrinkodd, because the first 
        // dimension is even
Array<double> darr = ffts2.crnyfft(carr);
        // darr should now be the same as arr
        
@end smallexample

@itemize @bullet
@item
     @code{void rrfft(Array <T> &arr, int dir, int do_scale=1);}
@end itemize 

Performs a forward or backward  @sc{fft} on @code{arr}. If the transform
is forward, the result will be an unpacked Hermetian grid. If the
transform is backward, the input must be an unpacked Hermetian grid and
the result will be a real valued time domain sample. Identical to @code{fft},
except that the data are assumed to be unpacked. No packing or unpacking
is done. Image flipping is performed.

@itemize @bullet
@item
     @code{void rndfft(Array <T> &arr, int dir, int do_scale=1);}
@end itemize 

Performs a forward or backward @sc{fft} on @code{arr}; the direction is
specified by @code{dir}. Identical to @code{rrfft}, except that no image
flipping is performed. This invokes the @sc{fortran} @sc{fft} functions;
the method @code{rrfft} invokes this after performing image flipping. In
turn, the method @sc{fft} performs packing and unpacking, and invokes
@code{rrfft}.

@itemize @bullet
@item
     @code{void rndnyfft(Array<T> &arr, int dir, int do_scale=1);}
@end itemize

Performs a forward or backward @sc{fft} on @code{arr}; the direction is
specified by @code{dir}. Identical in behaviour to @code{nyfft}, except
that no image flipping, packing, or unpacking, are performed. Result
will be normalized after an inverse transform unless
@code{do_scale==0}. The internal Nyquist array will be assigned to, for
later convenience.  @code{nyfft} invokes this routine after (and before)
doing image flipping.


@sp 1

The following methods @code{cndfft} and @code{rcndfft} provide a direct
interface to multi-dimensional @sc{fortran} @sc{dft} routines. They
should be used for programmers who want optimal complex to complex
transforms, and do not require image flipping or internal Nyquist array
manipulation.

Since the @code{cndfft} and @code{rcndfft} methods do not modify or read
the internal Nyquist array, any @code{FFTServer} object can be used to
transform any @code{Array} object with these methods.


@itemize @bullet
@item
     @code{void cndfft(Array<S> &arr, int dir, int do_scale=1);}
@end itemize 

Perform a complex to complex transform on the array @code{arr}. Result
will be normalized after a backward transform unless @code{do_scale==0}

@itemize @bullet
@item
     @code{void rcndfft(Array<T> &rdata, Array<T> &cdata, int dir, int
	       do_scale=1);}
@end itemize 

Perform a complex to complex transform, with the real and imaginary
components provided as separate real arrays @code{rdata} and
@code{cdata}, which must conform. Result will be normalized after a
backward transform unless @code{do_scale==0}. 

@itemize @bullet
@item
     @code{float scaleFactor(void);}
@end itemize 

Return the scale factor used in the most recently performed complex to real
fft.


Here is an example of using @code{cndfft}, @code{rcndfft}, and
@code{scaleFactor}:

@smallexample
FFTServer<float, Complex> ffts; 
        // generic FFTServer object

Vector<Complex> cxx(1024);
        // complex Vector of size 1024

        // ... initialize it 

ffts.cndfft(cxx, -1, 0);

float s = scaleFactor();
        // get the scale factor from the reverse transform

cxx = cxx * Complex(s, 0);
        // normalize cxx

        // direct inverse transform, don't scale

Matrix<float> real(512, 512), imag(512, 512);
        // real and imaginary parts

ffts.rcndfft(real, imag, 1);
        // direct forward transform
@end smallexample


@itemize @bullet
@item
    @code{float wtsum(Array<T> &);}
@end itemize 

This method sums up the values in a weights array created by the
@code{GridTool}, and associated with a Hermetian @var{UV} grid.  Then proper
scaling of an image produced from the @sc{fft} of a gridded @var{UV} plane can be
done.

@smallexample

   Matrix <float> image(1024,1024), wts(513,1024);
   FFTServer fft<float, Complex> (image);
      ...   grid uv data into into image with aid of gridtool, etc
      ...   the gridtool will assign weight values to the 
              weight array, wts
   fft.fft(image,0);                // FFT uv plane to image domain
                                    // but don't do default normalization
                                    //   scaling is done by dividing 
                                    //   by sum of weights
   float sum_of_weight = fft.wtsum(wts);
   image = image / sum_of_weight;   // normalize fft
@end smallexample

@itemize @bullet
@item
    @code{float cxWtsum(Array<T> &);}
@end itemize 

This function sums up the weights associated with a full complex grid
for @sc{fft} normalization.

@itemize @bullet
@item
     @code{void uvassign(Array<T> &, Array<float> &)}
@item
     @code{void uvassign(Array<S> &, Array<float> &)}
@end itemize 

This method copies uv grid weights associated with a Hermetian @var{UV}
grid on to a @var{UV} grid in preparation for doing a real to complex
@sc{fft} for an antenna pattern.  Packing is also done.

@smallexample
   image = 0.0;
   fft.uvassign(image, wts);          // copy wts array to image array 
   fft.fft(image, 0);                 // do the fft
   image = image / sum_of_weight;     // normalize by sum of weights
      ... voila, an antenna pattern
@end smallexample

@itemize @bullet
@item
     @code{void cxUVassign(Array<S>&, Array<T>&)}
@end itemize 

This method copies @var{UV} grid weights associated with a full complex @var{UV}
grid on to a @var{UV} grid in preparation for doing a complex to complex
backward @sc{fft} for an antenna pattern.

@c ======================================================================
@node Special Methods,  , General Methods, Top
@chapter Special Methods

The following methods are public members of the FFTServer class, but are
unlikely to be used often. They are normally used by methods such as
 such as @code{crfft}.

@itemize @bullet
@item
@smallexample void flipImage(Array<T> &image,
 int image_type=fftparms::DEF_IMAGE_TYPE, int parity=1);
@end smallexample

@item
@smallexample void flipImage(Array<S> &image, 
   int image_type=fftparms::DEF_IMAGE_TYPE, int parity=1);
@end smallexample 

@end itemize 

If @code{parity==1}, moves @code{image}'s phase center to the origin of
the array, in the periodic n-dimensional sample space whose period is
determined by the dimensions of @code{image}. If @code{parity==0}, moves
@code{image}'s image center to the origin.

You can think of it as dividing an n-dimensional image into 2^n equal
parts and swapping each of these parts with that which diametrically opposes
it.  So, for a matrix, it flips quadrants, for a cube, it flips octants, and so
on. 

If @code{image_type} is not equal to @code{fftparms::DEF_IMAGE_TYPE==0},
then @code{image} is assumed to have dimensions @var{(a+2, b, c, ...,
n)}, and the last two elements in each row will not be moved.

You might be asking yourself, ``what about the method @code{nyfft}, and
other methods that have an extra two elements in each row? Don't those
values need to be moved too?'' 

The answers are they don't need it, and no, because this method is meant
to be invoked on time domain samples, or non-Hermetian complex-valued
frequency domain samples. A time domain sample does not have Nyquist
data; the extra space is only used in an Hermetian frequency-domain
sample.  The method @code{exchangeUV} is used to flip an Hermetian grid,
because the phase center for the first dimension is already at the
origin. Hence no flipping in the first dimension needs to be done for an
Hermetian grid.

@sp 1

@itemize @bullet
@item
@code{void shift(Array<S> &arr, S factor, int timeshift, const Vector<T> &shift);}
@end itemize

Performs the equivalent of shifting the complex valued array @code{arr}
in either the time or frequency domains. The shifting theorems of
discrete transforms are applied.
@iftex
@tex
For example, let $h(k)$ be a function of time, and let $H(n)$ be its
Fourier Transform. Then for the real number $i$, $h(k - i)$ has as its
transform $H(n) e^{-j2\pi ni/N}$, where $j=\sqrt{-1}$, and $N$ is the
number of samples for $h$. Similarly, $H(n-i)$ has as its inverse
transform $h(k)e^{j2\pi i k/N}$. This property can be generalized to an
$n$ dimensional transform. @cite{Brigham [2]}.
@end tex
@end iftex

If @code{timeshift} is nonzero, the sign of the exponent in the complex
exponential function will be negative. If @code{timeshift==0}, the sign of the
exponent will be positive. Every element in @code{arr} will be multiplied by
@code{factor}. The amount to shift in dimension @code{i} is specified by
@code{shift(i)}; the number of elements in @code{shift} must be equal to
the number of dimensions in @code{arr}.

Thus invoking this method on an @code{Array} before a transform is
equivalent to applying the transform, then shifting the elements after;
similarly, this method can be applied after a transform to perform the
equivalent of shifting before.

Example:

@smallexample

Vector<Complex> v1(4) = 0;
v1(0) = Complex(1,0);
        // v1 looks like ((1,0), (0,0), (0,0) (0,0))
Vector<float> v2(4) = 0;
v2(1) = Complex(1,0);
        // v2 looks like ((0,0), (1,0), (0,0) (0,0))

Vector<float> s(1) = 1;
        // s looks like (1)

FFTServer<float,Complex> ffts(v1);

ffts.shift(v1, 1, 1, s); 
        // shift in time by 1

ffts.cxfft(v1, 1);
ffts.cxfft(v2, 1);
        // can use same FFTServer object to transform both
        // for full complex transform.

        // now v1 and v2 will be the same

v1 = 0;
v2 = 0;
v1(0) = v2(1) = Complex(1,0);
        // Reset v1 and v2; they now look like they did above

ffts.shift(v1, 1.0/4, 0, s);
        // shift in frequency domain; use factor to normalize

ffts.cxfft(v1, 0);
        // backward transform, don't normalize
ffts.cxfft(v2, -1);

        // now v1 and v2 should be the same.
@end smallexample

@sp 1

@itemize @bullet
@item
     @code{void exchangeUV(Array<T> &image);}
@item
     @code{void exchangeUV(Array<S> &image);}
@end itemize 

Move @code{image}'s phase center to the origin of the array, in the
periodic n-dimensional sample space whose period is determined by the
dimensions of @code{image}. 

This method should only be used for Hermetian frequency domain samples.
You can think of it as moving the sample through periodic space, in each
dimension but the first, through a distance of half the period. Thus it
does nothing for a @code{Vector}, and exchanges top and bottom halves
for a @code{Matrix}.

@chapter Examples

For more examples of using the @code{FFTServer} and @code{FourierTool}
classes, please see the source code for the test program
@code{FFTServerTest.cc}. The correct output can be found in
@code{FFTServerTest.out}. Note that roundoff errors are introduced by the
transform methods, and you will see small numbers where you expect zero.

@section Structure of @code{FFTServerTest.cc}

The @code{FFTServerTest.cc} program demonstrates the validity of
@code{FFTServer} and @code{FourierTool} methods by visually
demonstrating their behaviour. For the transform methods, a forward
transform is always followed by an inverse transform; the difference
between the original array and the identity transform is computed and
reported. This should usually be close to zero; small errors may be
introduced due to round off error. Substantial errors are a reason for
concern and should be investigated.

Three @code{template} functions are provided for testing the class
methods.  Each testing function tests both complex and real forms of the
methods, using the complex and real valued @code{Array} parameters.  The
results of the operations are displayed on the standard output, for
visual inspection. The same initial arrays are used for each test.

@itemize @bullet
@item  
@code {
template<class T, class S>
void testBaseMethods(Array<T> &re, Array<S> &im)
}

Demonstrates the @code{FourierTool} methods @code{pack}, @code{unpack}, 
@code{extractNYF}, @code{extractNYC}, @code{insertNYF},
@code{insertNYC}, @code{shrink}, @code{expand}, @code{shrinkby1}, and
@code{expandby1}.


@sp 1

@item
@code {
template<class T, class S>
void testTransformMethods(Array<T> &re, Array<S> &im)
}

Demonstrates the @code{FFTServer} constructors, all of the transform
methods, @code{extract*} and @code{insert*}. Note that the
@code{FFTServer} constructors simply invoke the @code{Set} methods
directly.  The @code{FourierTool} base methods must work correctly for
these results to be meaningful.  The direct transform tests
@code{rndfft} and @code{cndfft} directly call @sc{fortran}; compare
other transform methods against these. Be aware of the effects of
flipping and packing.


@sp 1

@item
@code {
template<class T, class S>
void testFlipMethods(Array<T> &re, Array<S> &im)
}

Demonstrates the @code{FFTServer} methods @code{flipImage},
@code{exchangeUV}.

@end itemize

At the end of @code{main} in @code{FFTServerTest.cc}, there is a
demonstration of the validity of the @code{FFTServer} method
@code{shift}. The equivalence of invoking @code{shift} before a transform and
transforming a shifted array is demonstrated.

@section Implementations of the transform, packing, and unpacking methods

This section describes the implementations of some of the transform
methods in the @code{FFTServer} class, and the packing and unpacking
methods in the @code{FourierTool} class.

@subsection Transform Methods

The @code{FFTServer} class uses @sc{FORTRAN} @sc{FFT}
routines. Functions from the Netlib library and a function originally
written by R.C. Singleton are used. The Netlib functions are used for
one-dimensional transforms on Hermetian arrays. The Singleton function
is used for full complex to complex multidimensional transforms, and for
transforms that require arbitrary indexing.

There are four @code{FFTServer} methods that call the @sc{FORTRAN}
@sc{FFT} routines: @code{rndfft}, @code{rndnyfft}, @code{cndfft}, and
@code{rcndfft}. The last routines do little more than invoke the
multidimensional R.C. Singleton @sc{FFT}. All other transform methods
invoke one of these four methods. A general description of @code{rndfft}
and @code{rndnyfft} follows; please refer to the source code for more
details.

A multi-dimensional @sc{FFT} may be performed by applying @sc{FFT}s
along 1-dimensional vectors. For example, transforming a @var{8 x 10}
@code{Matrix} @var{M} is equivalent to performing @var{10} @sc{FFT}s along the
rows of @var{M}, then performing @var{8} @sc{FFT}s along the columns of
@var{N}. In general, a n-dimensional @sc{FFT} is performed by applying
@sc{FFT}s along all vectors in each of the n-dimensions. If the
@sc{FFT} is to be performed in place without copying of elements, an
indexing skip must be specified. The file @code{extern_fft.h} provides
the following interface to the R.C. Singleton multidimensional @sc{FFT}:

@code{
void 
mfft(float *a, float *b, int *ntot, int *n, int *nspan, int *isn);
}

The sign of @code{isn} specifies the direction of the transform;
negative for a forward transform, and positive for a backward
transform. The magnitude of @code{isn} speicifies the indexing increment
between successive elements in the current dimension. This allows the
user to apply a transform to any sub vector of a multidimensional array,
by specifying its starting point in the array, the vector's length, and
the increment between successive elements.  For an array in @sc{FORTRAN}
order with dimensions @var{(a, b, c, ..., n)}, the indexing increment
between successive elements along dimension @var{i} will be @var{a * b *
... * j} where @var{j} is the size of dimension @var{i-1}. (1)

Since the methods @code{rndfft} and @code{rndnyfft} perform transforms
on Hermetian arrays, the general multi-dimensional complex to complex
Singleton routine can not be used directly; the Nyquist elements must be
considered separately.

Both methods proceed as follows, given an @code{Array}
@code{arr}. Details of indexing calculations are not given here; please
refer to the source code.

@enumerate

@item
If the transform is forward, the Netlib @sc{FFT} routine is used to
perform a forward transform on each row in @code{arr}. Elements in each
row will be arranged @var{re(1), re(2), im(2), ..., re(n-2), re(n-1)}
for the even case, and @var{re(1), re(2), im(2), ..., re(n-1), im(n-1)}
for the odd case. Elements are shuffled to arrange each row as an array
of real and imaginary pairs. 

@item
For each dimension, the Singleton @sc{FFT} routine is used to perform a
forward or backward transform on each vector in that dimension. The
first real and imaginary components will be consecutive elements in
@code{arr}; the indexing skip between successive complex pairs will be
twice the product (1) computed above. If the location of the next vector
is beyond the end of @code{arr}, then the location of the next vector
can be computed by subtracting the length of @code{arr} plus one
normally, or @code{arr} plus two if the last vector computed was a
Nyquist component.

@item
For a backward transform, the Netlib @sc{FFT} routine is used to
transform each row in @code{arr}. Elements are shuffled and copied to
the Nyquist array.

@end enumerate

@subsection Packing and Unpacking Methods

The @code{FourierTool} methods access the underlying storage of an
@code{Array} @code{arr} during the @code{pack} and @code{unpack}
operations.  The real valued Nyquist array is considered a sequence of
rows; the first plane of @code{arr} is isomorphic to the Nyquist
array. Each row in the Nyquist array is a single complex number.

The @code{pack} and @code{unpack} operations proceed similarly at
first. An array @code{used} of integers, the same shape and size as the
Nyquist array, is used to record elements and their conjugates as the
array is traversed.

The pack operation proceeds as follows.

For each row @var{i} in the Nyquist array,

@enumerate

@item 
The location of the complex conjugate of @var{i} in the Nyquist array is
computed, under the assumption that the first dimension of @code{arr} is
even. The corresponding location in the first plane of @code{arr} is the
complex conjugate in @code{arr}, whether the first dimension of
@code{arr} is even or odd.

@item
If the element in @code{arr} corresponding to @var{i} is marked as used,
then this step is skipped and loop continues with the next row.
Otherwise, the element and its conjugate are marked as used.

@item 
If the element in @code{arr} is its own conjugate, then only the
imaginary part can be overwritten.  If the first dimension of @code{arr}
is even, then the real part of the Nyquist element is copied to the
imaginary part of the element of @code{arr}. If the first dimension of
@code{arr} is odd, then the imaginary part of the Nyquist element is
copied to the imaginary part the element of @code{arr}.

Otherwise, if the element in @code{arr} is not its own conjugate, both
the real and imaginary parts can be overwritten.  If the size of the
first dimension of @code{arr} is even, then the real and imaginary parts
from the Nyquist row and copied to @code{arr}. Since @code{used} marks
this element and its conjugate, we are guaranteed to not overwrite the
conjugate later in the traversal.

If the size of the first dimension of @code{arr} is even, then the
imaginary parts from two consecutive elements in @code{arr} are copied
to the real and imaginary parts of the element in @code{arr}. A separate
pointer into the Nyquist array must be advanced by two rows.

@end enumerate

The unpack operation proceeds similary, and differs in the third step:

@enumerate 3
@item 
If the element in @code{arr} is its own conjugate, then the real part is
the real part in @code{arr}, and the imaginary part is the real or
imaginary part in the Nyquist array. If the first dimension of
@code{arr} is odd, then the imaginary part of @code{arr} is copied to
the imaginary part in the Nyquist array, and the real component at the
end of the row in @code{arr} is copied to the real part of the element
in the Nyquist array. Otherwise, the imaginary part of @code{arr} is
copied to the real part of the Nyquist array, and zero is written to the
imaginary part in the Nyquist array.

If the element in @code{arr} is not its own conjugate, then its values
are copied to the Nyquist array. If the first dimension of @code{arr} is
odd, then the real and imaginary parts from @code{arr} are copied to the
imaginary parts of two consecutive elements in the Nyquist array, and
the real part of the last element of the row in @code{arr} is copied to
the real part of the Nyquist element. 

If the first dimension of @code{arr} is even, then the real and
imaginary parts of the element in @code{arr} is copied to the Nyquist
element. The conjugate of the element in the Nyquist array is computed,
and stored in the conjugate's location.

In any case, the value of the conjugate in @code{arr} is used to
reconstruct the value in @code{arr}.

@end enumerate

For details of the process, please consult the code.


@page
@unnumbered References

@enumerate
@item
@sc{Bracewell, Ronald N.} @emph{The Fourier Transform and Its
Applications.} McGraw Hill, 1986. 

@item
@sc{Brigham, E. Oran.} @emph{The Fast Fourier Transform.} Prentice-Hall,
Inc., Englewood Cliffs, N.J., 1974.

@item
Personal communications with Dr. Tony Willis, Dominion Radio
Astrophysical Observatory, Penticton, B.C., Canada, January to April
1995.

@bye

<?xml version="1.0" encoding="iso-8859-1" ?> 
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1 plus MathML 2.0//EN" 
"http://www.w3.org/Math/DTD/mathml2/xhtml-math11-f.dtd" > 
<html xmlns="http://www.w3.org/1999/xhtml"  
> 
<head><title>NOTE 216 &#8211; Lattice Expression Language Implementation</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<!-- xhtml,mathml,fn-in,html --> 
<meta name="src" content="216.tex" /> 
<meta name="date" content="2015-05-29 10:59:00" /> 
<link rel="stylesheet" type="text/css" href="216.css" /> 
</head><body 
>
<div class="maketitle">
                                                                                               
                                                                                               
                                                                                               
                                                                                               

<h2 class="titleHead">NOTE 216 &#8211; Lattice Expression Language Implementation</h2>
<div class="author" ><span 
class="cmr-12">Neil Killeen (ATNF) and Ger van Diepen (NFRA)</span></div>
<br />
<div class="date" ><span 
class="cmr-12">1998 January 20</span></div>
</div><a 
href="216.pdf" >A pdf version of this note is available.</a>
<h3 class="sectionHead"><span class="titlemark">1 </span> <a 
 id="x1-10001"></a>Introduction</h3>
<!--l. 3--><p class="noindent" >The Lattice Expression Language (just a fancy name for some C++ classes !) allows manipulation of
mathematical expressions involving <span 
class="cmtt-10x-x-109">Lattices </span>directly from C++. The <span 
class="cmtt-10x-x-109">Lattices </span>involved in the expressions are
iterated through tile by tile, and the expression evaluated for each pixel in the tiles. Thus there are no large
temporary <span 
class="cmtt-10x-x-109">Lattices</span>, and the iteration is efficient.
</p><!--l. 10--><p class="noindent" >LEL offers many of the standard numerical and logical operators and functions (that can be applied to
scalars and <span 
class="cmtt-10x-x-109">Arrays</span>), as well as some additional astronomically oriented ones. It can handle <span 
class="cmtt-10x-x-109">Float</span>,
<span 
class="cmtt-10x-x-109">Double</span>, <span 
class="cmtt-10x-x-109">Complex </span>and <span 
class="cmtt-10x-x-109">DComplex Lattices</span>, including expressions involving mixtures of these types
of <span 
class="cmtt-10x-x-109">Lattices</span>. Conversion of data types is automatic, although the user can also embed explicit
conversions.
</p><!--l. 18--><p class="noindent" >The user can build expressions from subexpressions, finally evaluating the final expression.
</p><!--l. 21--><p class="noindent" >Throughout this document we will refer to objects of class <span 
class="cmtt-10x-x-109">Lattice</span>. In reality, this is an abstract class and the
real objects would be derived from it.
</p><!--l. 25--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">2 </span> <a 
 id="x1-20002"></a>Class Structures</h3>
<!--l. 27--><p class="noindent" >The expression is parsed, by the compiler, into a tree, and the nodes of the tree are built with the LEL classes.
The tree is also evaluated with the LEL classes.
</p><!--l. 31--><p class="noindent" >LEL is implemented with a Letter/Envelope scheme. The relational structure between the classes is
straightforward. The Envelope class is <span 
class="cmtt-10x-x-109">LatticeExpr</span>. <span 
class="cmtt-10x-x-109">LatticeExpr </span>invokes <span 
class="cmtt-10x-x-109">LatticeExprNode</span>, which provides a
bridge from <span 
class="cmtt-10x-x-109">LatticeExpr </span>to the letter classes <span 
class="cmtt-10x-x-109">LELBinary</span>, <span 
class="cmtt-10x-x-109">LELBinaryCmp</span>, <span 
class="cmtt-10x-x-109">LELBinaryBool</span>, <span 
class="cmtt-10x-x-109">LELConvert</span>,
<span 
class="cmtt-10x-x-109">LELFunction1D</span>, <span 
class="cmtt-10x-x-109">LELFunctionND</span>, <span 
class="cmtt-10x-x-109">LELFunctionReal1D</span>, <span 
class="cmtt-10x-x-109">LELFunctionFloat</span>, <span 
class="cmtt-10x-x-109">LELFunctionDouble</span>,
<span 
class="cmtt-10x-x-109">LELFunctionComplex</span>, <span 
class="cmtt-10x-x-109">LELFunctionDComplex</span>, <span 
class="cmtt-10x-x-109">LELFunctionBool</span>, <span 
class="cmtt-10x-x-109">LELLattice</span>, <span 
class="cmtt-10x-x-109">LELUnaryConst</span>, <span 
class="cmtt-10x-x-109">LELUnary</span>, and
<span 
class="cmtt-10x-x-109">LELUnaryBool</span>. The letter classes all inherit from <span 
class="cmtt-10x-x-109">LELInterface </span>which defines their common interface. There is
one more class, <span 
class="cmtt-10x-x-109">LELAttribute</span>, which is a helper class containing some attribute information about the
expression.
                                                                                               
                                                                                               
</p><!--l. 45--><p class="noindent" >The purpose of the bridge class, <span 
class="cmtt-10x-x-109">LatticeExprNode </span>is to handle type conversions. If all the data were of the same
type (e.g. <span 
class="cmtt-10x-x-109">Float</span>) we would not need the bridge class and <span 
class="cmtt-10x-x-109">LatticeExpr </span>would directly invoke the letter
classes.
</p><!--l. 50--><p class="noindent" >The user is exposed to the classes <span 
class="cmtt-10x-x-109">LatticeExpr </span>and <span 
class="cmtt-10x-x-109">LatticeExprNode</span>. Exposure to <span 
class="cmtt-10x-x-109">LatticeExpr </span>is
largely implicit (see later). Use of <span 
class="cmtt-10x-x-109">LatticeExprNode </span>may be explicit if subexpression manipulation is
desired.
</p><!--l. 55--><p class="noindent" >The classes are
</p>
<div class="center" 
>
<!--l. 57--><p class="noindent" >
</p>
<div class="tabular"><table id="TBL-2" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-2-1g"><col 
id="TBL-2-1" /></colgroup><colgroup id="TBL-2-2g"><col 
id="TBL-2-2" /></colgroup><colgroup id="TBL-2-3g"><col 
id="TBL-2-3" /></colgroup><colgroup id="TBL-2-4g"><col 
id="TBL-2-4" /></colgroup><colgroup id="TBL-2-5g"><col 
id="TBL-2-5" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-1-"><td colspan="5" style="text-align:center; white-space:nowrap;" id="TBL-2-1-1"  
class="td11">                                                                                                                                                                  <div class="multicolumn"  style="text-align:center; white-space:nowrap;"><span 
class="cmbx-10x-x-109">LEL Classes</span></div></td></tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-2-1"  
class="td11">Class </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-2-2"  
class="td11">Source files </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-2-3"  
class="td11">templation </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-2-4"  
class="td11">inheritance                                                                                                                                                                                                                                              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-2-5"  
class="td11">use          </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-3-1"  
class="td11">LatticeExpr                </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-3-2"  
class="td11">LatticeExpr.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}   </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-3-3"  
class="td11"><!--l. 64--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-3-4"  
class="td11">Lattice<!--l. 64--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-3-5"  
class="td11">Envelope  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-4-1"  
class="td11">LatticeExprNode         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-4-2"  
class="td11">LatticeExprNode.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}</span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-4-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-4-4"  
class="td11">none                                                                                                                                                                                                                                                                                                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-4-5"  
class="td11">bridge      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-5-1"  
class="td11">LELAttribute             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-5-2"  
class="td11">LELAttribute.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}  </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-5-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-5-4"  
class="td11">none                                                                                                                                                                                                                                                                                                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-5-5"  
class="td11">helper      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-6-1"  
class="td11">LELInterface              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-6-2"  
class="td11">LELInterface.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}  </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-6-3"  
class="td11"><!--l. 67--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-6-4"  
class="td11">none                                                                                                                                                                                                                                                                                                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-6-5"  
class="td11">Base class </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-7-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-7-1"  
class="td11">LELBinaryEnums        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-7-2"  
class="td11">LELBinaryEnums.h     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-7-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-7-4"  
class="td11">none                                                                                                                                                                                                                                                                                                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-7-5"  
class="td11">Enum      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-8-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-8-1"  
class="td11">LELBinary                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-8-2"  
class="td11">LELBinary.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}    </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-8-3"  
class="td11"><!--l. 69--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-8-4"  
class="td11">LELInterface<!--l. 69--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-8-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-9-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-9-1"  
class="td11">LELBinaryCmp          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-9-2"  
class="td11">LELBinary.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}    </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-9-3"  
class="td11"><!--l. 70--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-9-4"  
class="td11">LELInterface<!--l. 70--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Bool<!--l. 70--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-9-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-10-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-10-1"  
class="td11">LELBinaryBool          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-10-2"  
class="td11">LELBinary<span 
class="cmsy-10x-x-109">{</span>.h,2.cc<span 
class="cmsy-10x-x-109">}  </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-10-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-10-4"  
class="td11">LELInterface<!--l. 71--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Bool<!--l. 71--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-10-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-11-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-11-1"  
class="td11">LELConvert               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-11-2"  
class="td11">LELConvert.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}   </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-11-3"  
class="td11"><!--l. 72--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi><mo 
class="MathClass-punc">,</mo><mi 
>F</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-11-4"  
class="td11">LELInterface<!--l. 72--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-11-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-12-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-12-1"  
class="td11">LELFunctionEnums     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-12-2"  
class="td11">LELFunctionEnums.h   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-12-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-12-4"  
class="td11">none                                                                                                                                                                                                                                                                                                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-12-5"  
class="td11">enum       </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-13-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-13-1"  
class="td11">LELFunction1D          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-13-2"  
class="td11">LELFunction.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}  </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-13-3"  
class="td11"><!--l. 74--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-13-4"  
class="td11">LELInterface<!--l. 74--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-13-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-14-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-14-1"  
class="td11">LELFunctionND         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-14-2"  
class="td11">LELFunction.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}  </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-14-3"  
class="td11"><!--l. 75--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-14-4"  
class="td11">LELInterface<!--l. 75--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-14-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-15-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-15-1"  
class="td11">LELFunctionReal1D    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-15-2"  
class="td11">LELFunction.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}  </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-15-3"  
class="td11"><!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-15-4"  
class="td11">LELInterface<!--l. 76--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-15-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-16-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-16-1"  
class="td11">LELFunctionFloat       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-16-2"  
class="td11">LELFunction<span 
class="cmsy-10x-x-109">{</span>.h,2.cc<span 
class="cmsy-10x-x-109">} </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-16-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-16-4"  
class="td11">LELInterface<!--l. 77--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 77--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-16-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-17-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-17-1"  
class="td11">LELFunctionDouble     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-17-2"  
class="td11">LELFunction<span 
class="cmsy-10x-x-109">{</span>.h,2.cc<span 
class="cmsy-10x-x-109">} </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-17-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-17-4"  
class="td11">LELInterface<!--l. 78--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Double<!--l. 78--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-17-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-18-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-18-1"  
class="td11">LELFunctionComplex  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-18-2"  
class="td11">LELFunction<span 
class="cmsy-10x-x-109">{</span>.h,2.cc<span 
class="cmsy-10x-x-109">} </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-18-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-18-4"  
class="td11">LELInterface<!--l. 79--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Complex<!--l. 79--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-18-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-19-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-19-1"  
class="td11">LELFunctionDComplex</td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-19-2"  
class="td11">LELFunction<span 
class="cmsy-10x-x-109">{</span>.h,2.cc<span 
class="cmsy-10x-x-109">} </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-19-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-19-4"  
class="td11">LELInterface<!--l. 80--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>DComplex<!--l. 80--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-19-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-20-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-20-1"  
class="td11">LELFunctionBool        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-20-2"  
class="td11">LELFunction<span 
class="cmsy-10x-x-109">{</span>.h,2.cc<span 
class="cmsy-10x-x-109">} </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-20-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-20-4"  
class="td11">LELInterface<!--l. 81--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Bool<!--l. 81--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-20-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-21-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-21-1"  
class="td11">LELLattice                </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-21-2"  
class="td11">LELLattice.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}   </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-21-3"  
class="td11"><!--l. 82--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-21-4"  
class="td11">LELInterface<!--l. 82--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-21-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-22-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-22-1"  
class="td11">LELUnaryEnums        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-22-2"  
class="td11">LELUnaryEnums.h      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-22-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-22-4"  
class="td11">none                                                                                                                                                                                                                                                                                                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-22-5"  
class="td11">enum       </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-23-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-23-1"  
class="td11">LELUnaryConst          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-23-2"  
class="td11">LELUnary.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}    </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-23-3"  
class="td11"><!--l. 84--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-23-4"  
class="td11">LELInterface<!--l. 84--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-23-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-24-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-24-1"  
class="td11">LELUnary                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-24-2"  
class="td11">LELUnary.<span 
class="cmsy-10x-x-109">{</span>h,cc<span 
class="cmsy-10x-x-109">}    </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-24-3"  
class="td11"><!--l. 85--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-24-4"  
class="td11">LELInterface<!--l. 85--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo> <mi 
>T</mi> <mo 
class="MathClass-rel">&#x003E;</mo></math>                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-24-5"  
class="td11">letter class</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-2-25-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-25-1"  
class="td11">LELUnaryBool           </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-25-2"  
class="td11">LELUnary<span 
class="cmsy-10x-x-109">{</span>.h,2.cc<span 
class="cmsy-10x-x-109">}   </span></td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-25-3"  
class="td11">none                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-25-4"  
class="td11">LELInterface<!--l. 86--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Bool<!--l. 86--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-2-25-5"  
class="td11">letter class</td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-2-26-"><td  style="text-align:left; white-space:nowrap;" id="TBL-2-26-1"  
class="td11">                    </td>
</tr></table>
</div></div>
<!--l. 92--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">3 </span> <a 
 id="x1-30003"></a>How It Works</h3>
<!--l. 94--><p class="noindent" >Let us look at an example expression and examined how the system works.
</p><!--l. 96--><p class="noindent" >For example,
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-1">
&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;a;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Double&#x003E;&#x00A0;c;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;a.copyData(b+c);
</div>
<!--l. 103--><p class="nopar" >
</p><!--l. 105--><p class="noindent" >Thus, we evaluate the sum of the <span 
class="cmtt-10x-x-109">Lattices b </span>and <span 
class="cmtt-10x-x-109">c </span>and fill the <span 
class="cmtt-10x-x-109">Lattice a </span>with the result. Note that the result
of <span 
class="cmtt-10x-x-109">b+c </span>is a <span 
class="cmtt-10x-x-109">Double Lattice </span>which will be assigned to a <span 
class="cmtt-10x-x-109">Float Lattice</span>.
</p><!--l. 109--><p class="noindent" >There are two distinct steps in this; the first is the creation of the expression tree. The second is the evaluation
of the tree after its creation. Both occur at run time; the creation first, and then, via the <span 
class="cmtt-10x-x-109">copyData </span>call, the
evaluation.
</p><!--l. 114--><p class="noindent" >The tree is a structure which can be thought of as representing the hierarchy of operations. For our example
above, it looks like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-2">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;b&#x00A0;&#x00A0;&#x00A0;c
</div>
<!--l. 120--><p class="nopar" >
</p><!--l. 122--><p class="noindent" >Really, <span 
class="cmtt-10x-x-109">b </span>and <span 
class="cmtt-10x-x-109">c </span>are not operations, the actual software operation is something that gets the values of the
<span 
class="cmtt-10x-x-109">Lattice </span>into core from the <span 
class="cmtt-10x-x-109">Lattice</span>. The tree is more accurately written as
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-3">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+
&#x00A0;<br />&#x00A0;&#x00A0;getLatticeValues&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;getLatticeValues
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;b&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;c
</div>
<!--l. 130--><p class="nopar" >
</p><!--l. 132--><p class="noindent" >but we will use the short-hand tree expression style.
</p><!--l. 134--><p class="noindent" >A more complex expression like <span 
class="cmtt-10x-x-109">(a+sin(b)+2) / 10 </span>would be
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-4">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;/
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;10.0
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;+&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;a
&#x00A0;<br />sin&#x00A0;&#x00A0;&#x00A0;&#x00A0;2.0
&#x00A0;<br />b
</div>
<!--l. 143--><p class="nopar" >
</p><!--l. 145--><p class="noindent" >The tree is evaluated bottom up. Conceptually, the <span 
class="cmtt-10x-x-109">sin </span>of the <span 
class="cmtt-10x-x-109">Lattice b </span>is evaluated and <span 
class="cmtt-10x-x-109">2.0 </span>added to the
resultant <span 
class="cmtt-10x-x-109">Lattice</span>. Then that is added to the <span 
class="cmtt-10x-x-109">Lattice a</span>, and that resultant <span 
class="cmtt-10x-x-109">Lattice </span>is divided by
<span 
class="cmtt-10x-x-109">10.0</span>.
</p><!--l. 153--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">3.1 </span> <a 
 id="x1-40003.1"></a>Tree Creation</h4>
<!--l. 155--><p class="noindent" >Let us consider the creation of the expression tree first. The <span 
class="cmtt-10x-x-109">Lattice::copyData </span>member function expects as its
argument a <span 
class="cmtt-10x-x-109">Lattice</span>. Thus, the expression in the argument has to find a way to be converted to a
<span 
class="cmtt-10x-x-109">Lattice</span>. It is the LatticeExpr class that knows how to evaluate expressions involving <span 
class="cmtt-10x-x-109">Lattices</span>,
and LatticeExpr inherits from <span 
class="cmtt-10x-x-109">Lattice</span>. So any <span 
class="cmtt-10x-x-109">LatticeExpr </span>object is a valid argument for the
copyData call. We need to show that <span 
class="cmtt-10x-x-109">b+c </span>is a <span 
class="cmtt-10x-x-109">Lattice</span>; in this case a <span 
class="cmtt-10x-x-109">LatticeExpr </span>object, derived from
<span 
class="cmtt-10x-x-109">Lattice</span>.
</p><!--l. 165--><p class="noindent" >Internally, <span 
class="cmtt-10x-x-109">LatticeExpr </span>contains a <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object, so let us consider class <span 
class="cmtt-10x-x-109">LatticeExprNode </span>first.
<span 
class="cmtt-10x-x-109">LatticeExprNode </span>exists to handle type conversions for mixed type expressions. It is a non-templated class and
is not derived from any other class. It contains, as private data members, a variety of pointers to the class
<span 
class="cmtt-10x-x-109">LELInterface</span>. <span 
class="cmtt-10x-x-109">LELInterface </span>is an abstract base class, from which are derived concrete classes. These derived
classes are constructed in the tree, and when the expression is evaluated, they enable one to evaluate expressions
such as binary expressions, or functions, or get chunks of a <span 
class="cmtt-10x-x-109">Lattice </span>etc. These derived classes are (mostly)
templated, and the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>class contains one <span 
class="cmtt-10x-x-109">LELInterface </span>pointer object for each conceivable type
(<span 
class="cmtt-10x-x-109">Float</span>, <span 
class="cmtt-10x-x-109">Double</span>, <span 
class="cmtt-10x-x-109">Complex</span>, and <span 
class="cmtt-10x-x-109">DComplex</span>). The appropriate type for the <span 
class="cmtt-10x-x-109">LELInterface </span>pointer and the
templated derived <span 
class="cmtt-10x-x-109">LELInterface </span>object it is pointing to is the type of the data that it is manipulating. For
example, if a <span 
class="cmtt-10x-x-109">LELLattice </span>object is constructed from a <span 
class="cmtt-10x-x-109">Lattice&#x003C;Float&#x003E; </span>then the appropriate type is
<span 
class="cmtt-10x-x-109">Float</span>.
</p><!--l. 184--><p class="noindent" >Now, expressions like <span 
class="cmtt-10x-x-109">b </span>and <span 
class="cmtt-10x-x-109">c </span>can be converted to <span 
class="cmtt-10x-x-109">LatticeExprNode </span>objects via constructors such
as
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-5">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(const&#x00A0;Lattice&#x003C;Float&#x003E;&amp;&#x00A0;lattice);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(const&#x00A0;Lattice&#x003C;Double&#x003E;&amp;&#x00A0;lattice);
</div>
<!--l. 190--><p class="nopar" >
</p><!--l. 192--><p class="noindent" >Recall that the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object contains private data members (<span 
class="cmtt-10x-x-109">LELInterface </span>pointers) of many
different types. Only the data member of the relevant type will be assigned. For example, the Float constructor
looks like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-6">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode::LatticeExprNode&#x00A0;(const&#x00A0;Lattice&#x003C;Float&#x003E;&amp;&#x00A0;lattice)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;:&#x00A0;donePrepare_p&#x00A0;(False),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;dtype_p&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(TpFloat),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pExprFloat_p&#x00A0;&#x00A0;(new&#x00A0;LELLattice&#x003C;Float&#x003E;&#x00A0;(lattice))
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pAttr_p&#x00A0;=&#x00A0;&amp;pExprFloat_p-&#x003E;getAttribute();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 205--><p class="nopar" >
</p><!--l. 207--><p class="noindent" >The constructor notes that no optimizations (see later) have been performed, and also notes
what type of data it is being asked to handle. Now look at the <span 
class="cmtt-10x-x-109">new </span>statement. A pointer
(<span 
class="cmtt-10x-x-109">pExprFloat</span><!--l. 209--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
></mrow><mrow 
><mi 
>p</mi> </mrow> </msub 
> </math>
of type <span 
class="cmtt-10x-x-109">LELInterface&#x003C;Float&#x003E;</span>) to an object of class <span 
class="cmtt-10x-x-109">LELLattice </span>is created (<span 
class="cmtt-10x-x-109">LELLattice </span>is a class derived from
<span 
class="cmtt-10x-x-109">LELInterface</span>, the abstract base class).
</p><!--l. 214--><p class="noindent" >Thus, from the expressions <span 
class="cmtt-10x-x-109">b </span>or <span 
class="cmtt-10x-x-109">c</span>, we can create <span 
class="cmtt-10x-x-109">LatticeExprNode </span>objects from the <span 
class="cmtt-10x-x-109">Lattice </span>objects associated
with <span 
class="cmtt-10x-x-109">b </span>and <span 
class="cmtt-10x-x-109">c</span>. We must now look at the full expression, <span 
class="cmtt-10x-x-109">b+c</span>. Remember that <span 
class="cmtt-10x-x-109">Lattice b </span>is of type <span 
class="cmtt-10x-x-109">Float </span>and
<span 
class="cmtt-10x-x-109">Lattice c </span>is of type <span 
class="cmtt-10x-x-109">Double</span>, and the output <span 
class="cmtt-10x-x-109">Lattice a </span>is of type <span 
class="cmtt-10x-x-109">Float </span>(and therefore copyData is expecting a
<span 
class="cmtt-10x-x-109">Lattice&#x003C;Float&#x003E; </span>for its argument).
</p><!--l. 222--><p class="noindent" ><span 
class="cmtt-10x-x-109">LatticeExprNode </span>has an operator <!--l. 222--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
function declared as
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-7">
&#x00A0;&#x00A0;&#x00A0;friend&#x00A0;LatticeExprNode&#x00A0;operator+&#x00A0;(const&#x00A0;LatticeExprNode&amp;&#x00A0;left,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;LatticeExprNode&amp;&#x00A0;right);
</div>
<!--l. 227--><p class="nopar" >
</p><!--l. 230--><p class="noindent" >The friend keyword makes it a globally accessible operator. Now, you can see that it takes two other
<span 
class="cmtt-10x-x-109">LatticeExprNode </span>objects, in our case, those that we made from <span 
class="cmtt-10x-x-109">b </span>and <span 
class="cmtt-10x-x-109">c</span>.
</p><!--l. 234--><p class="noindent" >The <!--l. 234--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
operator returns another <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object; it is defined as
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-8">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;operator+&#x00A0;(const&#x00A0;LatticeExprNode&amp;&#x00A0;left,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;LatticeExprNode&amp;&#x00A0;right)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;LatticeExprNode::newNumBinary&#x00A0;(LELBinaryEnums::ADD,&#x00A0;left,&#x00A0;right);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 242--><p class="nopar" >
</p><!--l. 244--><p class="noindent" >where the static function <span 
class="cmtt-10x-x-109">LatticeExprNode::newNumBinary </span>has returned the desired <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object
(which embodies the two subexpression, <span 
class="cmtt-10x-x-109">b </span>and <span 
class="cmtt-10x-x-109">c</span>).
</p><!--l. 248--><p class="noindent" >Now, recall that what we really want in the copyData call is an object of type <span 
class="cmtt-10x-x-109">LatticeExpr </span>(which is a
<span 
class="cmtt-10x-x-109">Lattice</span>). Currently we have a <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object. So there has to be an automatic conversion from the
non-templated <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object to the templated <span 
class="cmtt-10x-x-109">LatticeExpr </span>object. This is done with one of the
operators in <span 
class="cmtt-10x-x-109">LatticeExprNode </span>from the list
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-9">
&#x00A0;&#x00A0;&#x00A0;operator&#x00A0;LatticeExpr&#x003C;Float&#x003E;();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;operator&#x00A0;LatticeExpr&#x003C;Double&#x003E;();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;operator&#x00A0;LatticeExpr&#x003C;Complex&#x003E;();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;operator&#x00A0;LatticeExpr&#x003C;DComplex&#x003E;();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;operator&#x00A0;LatticeExpr&#x003C;Bool&#x003E;();
</div>
<!--l. 261--><p class="nopar" >
</p><!--l. 263--><p class="noindent" >For reasons that we don&#8217;t understand, this could not be made to work yet with a constructor of the
type
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-10">
&#x00A0;&#x00A0;&#x00A0;LatticeExpr&#x00A0;(const&#x00A0;LatticeExprNode&amp;&#x00A0;expr)
</div>
<!--l. 268--><p class="nopar" >
</p><!--l. 271--><p class="noindent" >These operators are are in reality casting operators. For example, if you had
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-11">
&#x00A0;&#x00A0;&#x00A0;Double&#x00A0;x;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Int&#x00A0;i;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;x&#x00A0;=&#x00A0;(Double)i;
</div>
<!--l. 278--><p class="nopar" >
</p><!--l. 280--><p class="noindent" >the <span 
class="cmtt-10x-x-109">i </span>would be cast to a <span 
class="cmtt-10x-x-109">Double</span>. Similarly,
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-12">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;node;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExpr&#x003C;Float&#x003E;&#x00A0;expr;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;expr&#x00A0;=&#x00A0;(LatticeExpr&#x003C;Float&#x003E;)node;
</div>
<!--l. 286--><p class="nopar" >
</p><!--l. 288--><p class="noindent" >converts the node to the <span 
class="cmtt-10x-x-109">expr</span>.
</p><!--l. 290--><p class="noindent" >Since they are in class <span 
class="cmtt-10x-x-109">LatticeExprNode</span>, they expect to operate on a <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object. The name of
the operator is the same as the return type: <span 
class="cmtt-10x-x-109">LatticeExpr&#x003C;T&#x003E; </span>This is in general a dangerous practice, as one
gets automatic conversions that weren&#8217;t wanted sometimes. But we seem to have no choice for
now.
</p><!--l. 296--><p class="noindent" >Now, for our example, the type that <span 
class="cmtt-10x-x-109">Lattice::copyData </span>is expecting is a <span 
class="cmtt-10x-x-109">Float</span>, because that is the type of the
<span 
class="cmtt-10x-x-109">Lattice a</span>. Therefore, the casting operator that will be invoked is
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-13">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode::operator&#x00A0;LatticeExpr&#x003C;Float&#x003E;()
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;LatticeExpr&#x003C;Float&#x003E;&#x00A0;(LatticeExprNode(makeFloat()),&#x00A0;0);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 305--><p class="nopar" >
</p><!--l. 307--><p class="noindent" >So a <span 
class="cmtt-10x-x-109">LatticeExpr </span>constructor of the form
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-14">
&#x00A0;&#x00A0;&#x00A0;LatticeExpr&#x00A0;(const&#x00A0;LatticeExprNode&amp;&#x00A0;expr,&#x00A0;uInt&#x00A0;iDummy)
</div>
<!--l. 311--><p class="nopar" >
</p><!--l. 313--><p class="noindent" >is explicitly invoked by this casting operator. First however, the <span 
class="cmtt-10x-x-109">makeFloat </span>function is invoked explicitly to
convert the data in the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object to the correct internal type, which is <span 
class="cmtt-10x-x-109">Float </span>for our example.
Actually, the return type from <span 
class="cmtt-10x-x-109">makeFloat </span>is a <span 
class="cmtt-10x-x-109">CountedPtr&#x003C;LELInterface&#x003C;Float&#x003E;&#x003E;</span>. Therefore, to convert that
to a <span 
class="cmtt-10x-x-109">LatticeExprNode</span>, the constructor
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-15">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;Float&#x003E;*&#x00A0;expr);
</div>
<!--l. 322--><p class="nopar" >
</p><!--l. 324--><p class="noindent" >is automatically invoked. This is given to the <span 
class="cmtt-10x-x-109">LatticeExpr </span>constructor and finally returned.
</p><!--l. 327--><p class="noindent" >Now returning to the <span 
class="cmtt-10x-x-109">newNumBinary </span>static function above, there is another subtlety being handled. Here is
where we handle some additional type conversion. We know that <span 
class="cmtt-10x-x-109">Lattice a </span>wants a <span 
class="cmtt-10x-x-109">Float Lattice </span>in the
<span 
class="cmtt-10x-x-109">Lattice::copyData </span>function. We saw above that the <span 
class="cmtt-10x-x-109">newNumBinary </span>static function produced a
<span 
class="cmtt-10x-x-109">LatticeExprNode </span>which was automatically converted to a <span 
class="cmtt-10x-x-109">LatticeExpr </span>object of type Float. The thing we
didn&#8217;t see yet was how the handling of the mixed type expression <span 
class="cmtt-10x-x-109">b+c </span>was dealt with by <span 
class="cmtt-10x-x-109">newNumBinary</span>. That is,
we don&#8217;t know yet what the type of <span 
class="cmtt-10x-x-109">b+c </span>was, although we know that <span 
class="cmtt-10x-x-109">makeFloat </span>was able to handle it, whatever
it was. So let us look inside <span 
class="cmtt-10x-x-109">newNumBinary</span>.
</p><!--l. 338--><p class="noindent" >This function is implemented as
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-16">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;LatticeExprNode::newNumBinary&#x00A0;(LELBinaryEnums::Operation&#x00A0;oper,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;LatticeExprNode&amp;&#x00A0;left,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;LatticeExprNode&amp;&#x00A0;right)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;DataType&#x00A0;dtype&#x00A0;=&#x00A0;resultDataType&#x00A0;(left.dataType(),&#x00A0;right.dataType());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch&#x00A0;(dtype)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;TpFloat:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;new&#x00A0;LELBinary&#x003C;Float&#x003E;&#x00A0;(oper,&#x00A0;left.makeFloat(),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;right.makeFloat());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;TpDouble:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;new&#x00A0;LELBinary&#x003C;Double&#x003E;&#x00A0;(oper,&#x00A0;left.makeDouble(),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;right.makeDouble());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;TpComplex:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;new&#x00A0;LELBinary&#x003C;Complex&#x003E;&#x00A0;(oper,&#x00A0;left.makeComplex(),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;right.makeComplex());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;TpDComplex:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;new&#x00A0;LELBinary&#x003C;DComplex&#x003E;&#x00A0;(oper,&#x00A0;left.makeDComplex(),
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;right.makeDComplex());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;default:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;throw&#x00A0;(AipsError
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;("LatticeExpr:&#x00A0;Bool&#x00A0;argument&#x00A0;used&#x00A0;in&#x00A0;numerical&#x00A0;binary&#x00A0;operation"));
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;LatticeExprNode();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 365--><p class="nopar" >
</p><!--l. 368--><p class="noindent" >This function returns an expression of one type, as the two expressions that go into it may have
different types. Indeed, in our case, the left expression is a <span 
class="cmtt-10x-x-109">Float </span>and the right a <span 
class="cmtt-10x-x-109">Double</span>. The
function <span 
class="cmtt-10x-x-109">LatticeExprNode::resultDataType </span>says that mixing these two types should result in a
<span 
class="cmtt-10x-x-109">Double </span>so as not to lose precision. Therefore, the left and right expressions are converted to a
<span 
class="cmtt-10x-x-109">Double </span>expression and the <span 
class="cmtt-10x-x-109">LELBinary </span>object that is created is a <span 
class="cmtt-10x-x-109">Double </span>(see also the section on type
conversions).
</p><!--l. 377--><p class="noindent" >In addition, it can be seen that the return statements are returning pointers to objects of type <span 
class="cmtt-10x-x-109">LELBinary</span>, which
is derived from <span 
class="cmtt-10x-x-109">LELInterface</span>. Yet, the function <span 
class="cmtt-10x-x-109">newNumBinary </span>actually returns an object of type
<span 
class="cmtt-10x-x-109">LatticeExprNode</span>. So what is happening is an implicit conversion via a constructor. It&#8217;s one of the private
constructors
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-17">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;Float&#x003E;*&#x00A0;expr);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;Double&#x003E;*&#x00A0;expr);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;Complex&#x003E;*&#x00A0;expr);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;DComplex&#x003E;*&#x00A0;expr);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;Bool&#x003E;*&#x00A0;expr);
</div>
<!--l. 390--><p class="nopar" >
</p><!--l. 392--><p class="noindent" >that is doing the work.
</p><!--l. 396--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">3.2 </span> <a 
 id="x1-50003.2"></a>Evaluation</h4>
<!--l. 398--><p class="noindent" >How does <span 
class="cmtt-10x-x-109">copyData </span>manage to extract the result of the expression evaluation ? The <span 
class="cmtt-10x-x-109">copyData </span>function
ultimately calls the <span 
class="cmtt-10x-x-109">Lattice </span>function <span 
class="cmtt-10x-x-109">getSlice </span>(via an iterator) to fish out the data from its <span 
class="cmtt-10x-x-109">Lattice </span>argument.
<span 
class="cmtt-10x-x-109">getSlice </span>is therefore implemented in <span 
class="cmtt-10x-x-109">LatticeExpr </span>(as it inherits from <span 
class="cmtt-10x-x-109">Lattice </span>where <span 
class="cmtt-10x-x-109">getSlice </span>is declared).
We have seen that <span 
class="cmtt-10x-x-109">LatticeExpr </span>has one private data member, and it is of type <span 
class="cmtt-10x-x-109">LatticeExprNode</span>. The
implementation of <span 
class="cmtt-10x-x-109">LatticeExpr::getSlice </span>is to call the <span 
class="cmtt-10x-x-109">eval </span>function of its <span 
class="cmtt-10x-x-109">LatticeExprNode </span>private data
member (recall that <span 
class="cmtt-10x-x-109">LatticeExprNode </span>has a variety of pointers like <span 
class="cmtt-10x-x-109">CountedPtr&#x003C;LELInterface&#x003C;Float&#x003E;&#x003E; </span>for
each data type). <span 
class="cmtt-10x-x-109">LatticeExprNode </span>has many self-similar <span 
class="cmtt-10x-x-109">eval </span>functions, one for each type (<span 
class="cmtt-10x-x-109">Float, Double </span>etc).
Although the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object does know for what type it was constructed, it actually chooses the
correct version of the <span 
class="cmtt-10x-x-109">eval </span>function by the argument signature. This works because a buffer is included in the
<span 
class="cmtt-10x-x-109">eval </span>interface (this is where the result of the expression is put), and the buffer is of the appropriate
type.
</p><!--l. 417--><p class="noindent" >So invoking <span 
class="cmtt-10x-x-109">eval </span>of <span 
class="cmtt-10x-x-109">LatticeExprNode </span>invokes <span 
class="cmtt-10x-x-109">eval </span>of the object (which has been derived from <span 
class="cmtt-10x-x-109">LELInterface</span>)
and is pointed to by the appropriately typed <span 
class="cmtt-10x-x-109">CountedPtr&#x003C;LELInterface&#x003C;T&#x003E;&#x003E;</span>. In our example involving adding
two <span 
class="cmtt-10x-x-109">Lattices </span>together, those derived classes would be <span 
class="cmtt-10x-x-109">LELLattice </span>(to read the data from the <span 
class="cmtt-10x-x-109">Lattice</span>) and
<span 
class="cmtt-10x-x-109">LELBinary </span>(to add the data). For <span 
class="cmtt-10x-x-109">LELLattice</span>, its <span 
class="cmtt-10x-x-109">eval </span>function actually then uses the getSlice function on the
actual <span 
class="cmtt-10x-x-109">Lattice </span>from which it was constructed (<span 
class="cmtt-10x-x-109">b </span>or <span 
class="cmtt-10x-x-109">c</span>) to fish out the data. The <span 
class="cmtt-10x-x-109">LELBinary eval </span>function will
add the numbers together.
</p><!--l. 428--><p class="noindent" >Finally, since <span 
class="cmtt-10x-x-109">copyData </span>is actually iterating through the <span 
class="cmtt-10x-x-109">LatticeExpr </span>(<span 
class="cmtt-10x-x-109">Lattice</span>) object in optimally sized
chunks. The <span 
class="cmtt-10x-x-109">Lattice </span>expression is evaluated chunk by chunk (usually tile by tile). This means that there are no
large temporary <span 
class="cmtt-10x-x-109">Lattices </span>stored.
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-18">
&#x00A0;&#x00A0;&#x00A0;virtual&#x00A0;void&#x00A0;eval&#x00A0;(Array&#x003C;T&#x003E;&amp;&#x00A0;result,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;PixelRegion&amp;&#x00A0;region)&#x00A0;const&#x00A0;=&#x00A0;0;
</div>
<!--l. 436--><p class="nopar" >
</p><!--l. 438--><p class="noindent" >The derived classes make the actual implementation. The result of the evaluation of the expression is put in the
<span 
class="cmtt-10x-x-109">result </span>array. If the result of the expression evaluation is known to be a scalar (figured out at tree construction
time) then the <span 
class="cmtt-10x-x-109">getScalar </span>function is used to get the value instead.
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-19">
&#x00A0;&#x00A0;&#x00A0;virtual&#x00A0;T&#x00A0;getScalar()&#x00A0;const&#x00A0;=&#x00A0;0;
</div>
<!--l. 447--><p class="nopar" >
</p><!--l. 450--><p class="noindent" >Let&#8217;s look at <span 
class="cmtt-10x-x-109">eval </span>implementations for <span 
class="cmtt-10x-x-109">LELBinary </span>and <span 
class="cmtt-10x-x-109">LELLattice</span>. First, the piece for <span 
class="cmtt-10x-x-109">LELBinary </span>relevant to
the <!--l. 452--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
operator.
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-20">
&#x00A0;&#x00A0;&#x00A0;template&#x00A0;&#x003C;class&#x00A0;T&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;void&#x00A0;LELBinary&#x003C;T&#x003E;::eval(Array&#x003C;T&#x003E;&amp;&#x00A0;result,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;PixelRegion&amp;&#x00A0;region)&#x00A0;const
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch(op_p)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LELBinaryEnums::ADD&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(pLeftExpr_p-&#x003E;isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pRightExpr_p-&#x003E;eval(result,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;pLeftExpr_p-&#x003E;getScalar();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}&#x00A0;else&#x00A0;if&#x00A0;(pRightExpr_p-&#x003E;isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pLeftExpr_p-&#x003E;eval(result,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;pRightExpr_p-&#x003E;getScalar();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}&#x00A0;else&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Array&#x003C;T&#x003E;&#x00A0;temp(result.shape());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pLeftExpr_p-&#x003E;eval(result,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pRightExpr_p-&#x003E;eval(temp,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;temp;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
</div>
<!--l. 474--><p class="nopar" >
</p><!--l. 476--><p class="noindent" >Three cases are handled here: (array,array), (scalar,array) and (array,scalar). The case of (scalar,scalar) is
handled similarly in <span 
class="cmtt-10x-x-109">LELBinary::getScalar</span>.
</p><!--l. 480--><p class="noindent" >The important thing to see here is that the process is recursive. Each of the left and right expressions are evaluated first,
before the <!--l. 481--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
operation is done. So for example, since our example is the (array,array) case, we have
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-21">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Array&#x003C;T&#x003E;&#x00A0;temp(result.shape());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pLeftExpr_p-&#x003E;eval(result,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pRightExpr_p-&#x003E;eval(temp,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;temp;
</div>
<!--l. 490--><p class="nopar" >
</p><!--l. 493--><p class="noindent" >Both the left and right expressions are <span 
class="cmtt-10x-x-109">LELLattice </span>objects. Evaluating them results in filling the <span 
class="cmtt-10x-x-109">result </span>array
with the values from the <span 
class="cmtt-10x-x-109">Lattice </span>in the <span 
class="cmtt-10x-x-109">region</span>. Then the two arrays (<span 
class="cmtt-10x-x-109">result </span>and <span 
class="cmtt-10x-x-109">temp</span>) are added to make the
binary operation result. The <span 
class="cmtt-10x-x-109">LELLattice </span>eval function looks like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-22">
&#x00A0;&#x00A0;&#x00A0;template&#x00A0;&#x003C;class&#x00A0;T&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;void&#x00A0;LELLattice&#x003C;T&#x003E;::eval(Array&#x003C;T&#x003E;&amp;&#x00A0;result,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;PixelRegion&amp;&#x00A0;region)&#x00A0;const
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;//&#x00A0;The&#x00A0;rwRef&#x00A0;function&#x00A0;will&#x00A0;make&#x00A0;a&#x00A0;copy&#x00A0;when&#x00A0;needed&#x00A0;(i.e.&#x00A0;when&#x00A0;ptr
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;//&#x00A0;contains&#x00A0;a&#x00A0;reference&#x00A0;to&#x00A0;the&#x00A0;original&#x00A0;data).
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;COWPtr&#x003C;Array&#x003C;T&#x003E;&#x00A0;&#x003E;&#x00A0;ptr;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pLattice_p-&#x003E;getSlice(ptr,&#x00A0;region.box(),&#x00A0;False);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result.reference(ptr.rwRef());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 512--><p class="nopar" >
</p><!--l. 514--><p class="noindent" >the <span 
class="cmtt-10x-x-109">Lattice </span>function <span 
class="cmtt-10x-x-109">getSlice </span>is used to recover the pixels into the array <span 
class="cmtt-10x-x-109">result</span>. Note we use a <span 
class="cmtt-10x-x-109">COWPtr </span>so
that for say an <span 
class="cmtt-10x-x-109">ArrayLattice</span>, the array references the data only saving a copy, unless it is actually written to.
There is no <span 
class="cmtt-10x-x-109">LELLattice::getScalar </span>function as it doesn&#8217;t make any sense. If you try to call it, you will throw
an exception.
</p><!--l. 523--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">4 </span> <a 
 id="x1-60004"></a>Data Type Conversions</h3>
<!--l. 525--><p class="noindent" >There are two types of conversion going on in these classes, and one can get rather confused between them if not
careful.
</p>
<ul class="itemize1">
<li class="itemize">There are  conversions  imposed  by  the  <span 
class="cmtt-10x-x-109">C++ </span>compiler.  These  convert  from  <span 
class="cmtt-10x-x-109">Lattice&#x003C;T&#x003E; </span>to
<span 
class="cmtt-10x-x-109">LatticeExprNode </span>and from <span 
class="cmtt-10x-x-109">LatticeExprNode </span>to <span 
class="cmtt-10x-x-109">LatticeExpr&#x003C;T&#x003E;</span>
</li>
<li class="itemize">There are conversions done by the expression classes to convert from one data type to another (e.g.
<span 
class="cmtt-10x-x-109">Float </span>to <span 
class="cmtt-10x-x-109">Double</span>). They are run-time conversions generated by the <span 
class="cmtt-10x-x-109">makeXXX </span>functions.</li></ul>
<!--l. 537--><p class="noindent" >The first type of conversion (e.g. <span 
class="cmtt-10x-x-109">LatticeExprNode </span>to <span 
class="cmtt-10x-x-109">LatticeExpr&#x003C;T&#x003E;</span>) is handled by the casting
operator discussed previously. In addition, inside that casting operation are calls to functions like
<span 
class="cmtt-10x-x-109">LatticeExprNode::makeFloat </span>which embed an object of class <span 
class="cmtt-10x-x-109">LELConvert </span>into the tree and then at evaluation
time <span 
class="cmtt-10x-x-109">LELConvert::eval </span>actually converts the data (i.e. the values of the pixels in the <span 
class="cmtt-10x-x-109">eval </span>interface buffer
array) between types so that the <span 
class="cmtt-10x-x-109">LatticeExpr&#x003C;T&#x003E; T </span>type is self-consistent with the type of the <span 
class="cmtt-10x-x-109">LELInterface</span>
<span 
class="cmtt-10x-x-109">CountedPtr </span>inside <span 
class="cmtt-10x-x-109">LatticeExprNode </span>(and hence the right-type eval functions get picked up in
<span 
class="cmtt-10x-x-109">LatticeExprNode</span>).
</p><!--l. 549--><p class="noindent" >Let us look a little harder at the conversion functions like <span 
class="cmtt-10x-x-109">LatticeExprNode::makeDouble </span>(and similar
expressions) that does the type conversion for the actual data arrays in the <span 
class="cmtt-10x-x-109">LELInterface::eval </span>interface. Here
is the implementation
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-23">
&#x00A0;&#x00A0;&#x00A0;CountedPtr&#x003C;LELInterface&#x003C;Double&#x003E;&#x00A0;&#x003E;&#x00A0;LatticeExprNode::makeDouble()&#x00A0;const
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch&#x00A0;(dataType())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;TpFloat:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;new&#x00A0;LELConvert&#x003C;Double,Float&#x003E;&#x00A0;(pExprFloat_p);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;TpDouble:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;pExprDouble_p;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;default:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;throw&#x00A0;(AipsError&#x00A0;("LatticeExpr:&#x00A0;conversion&#x00A0;to&#x00A0;Double&#x00A0;not&#x00A0;possible"));
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;0;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 568--><p class="nopar" >
</p><!--l. 570--><p class="noindent" >So what happens is that if a type conversion is required on the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>to which
<span 
class="cmtt-10x-x-109">makeDouble </span>is being applied, then the returned <span 
class="cmtt-10x-x-109">CountedPtr&#x003C;LELInterface&#x003C;Double&#x003E;&#x003E; </span>is assigned
to a <span 
class="cmtt-10x-x-109">LELConvert </span>object (which inherits from <span 
class="cmtt-10x-x-109">LELInterface</span>). Otherwise, it just returns the
current <span 
class="cmtt-10x-x-109">CountedPtr&#x003C;LELInterface&#x003C;Double&#x003E;&#x003E; </span>object already active inside the <span 
class="cmtt-10x-x-109">LatticeExprNode</span>
(<span 
class="cmtt-10x-x-109">pExprDouble</span><!--l. 576--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
></mrow><mrow 
><mi 
>p</mi> </mrow> </msub 
> </math>).
The <span 
class="cmtt-10x-x-109">LELConvert </span>object is now embedded in the tree. Note that the actual conversion will happen at
evaluation time, not at tree construction time, when the <span 
class="cmtt-10x-x-109">eval </span>function of <span 
class="cmtt-10x-x-109">LELConvert </span>gets called.
<span 
class="cmtt-10x-x-109">LELConvert::eval </span>will actually convert the data in the interface buffer between types (just by
copying).
</p><!--l. 583--><p class="noindent" >Let us look at the actual tree here. Imagine we have
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-24">
&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;a;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Double&#x003E;&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;expr&#x00A0;=&#x00A0;a+b;
</div>
<!--l. 589--><p class="nopar" >
</p><!--l. 591--><p class="noindent" >The tree, with all like types, would be
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-25">
&#x00A0;&#x00A0;&#x00A0;+
&#x00A0;<br />a&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;b
</div>
<!--l. 596--><p class="nopar" >
</p><!--l. 598--><p class="noindent" >Now however, because <span 
class="cmtt-10x-x-109">a </span>and <span 
class="cmtt-10x-x-109">b </span>are different types, we embed a conversion into the tree. In this case, the <span 
class="cmtt-10x-x-109">Float </span>is
converted to a <span 
class="cmtt-10x-x-109">Double</span>.
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-26">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+
&#x00A0;<br />conv&#x00A0;&#x00A0;&#x00A0;&#x00A0;b
&#x00A0;<br />&#x00A0;&#x00A0;a
</div>
<!--l. 606--><p class="nopar" >
</p><!--l. 608--><p class="noindent" >Now let us assign this result of <span 
class="cmtt-10x-x-109">a+b </span>to an output <span 
class="cmtt-10x-x-109">Lattice</span>
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-27">
&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;c;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;c.copyData(expr);
</div>
<!--l. 613--><p class="nopar" >
</p><!--l. 615--><p class="noindent" >The type of <span 
class="cmtt-10x-x-109">a+b </span>is <span 
class="cmtt-10x-x-109">Double</span>, and we need to convert it to <span 
class="cmtt-10x-x-109">Float</span>, the type of <span 
class="cmtt-10x-x-109">c</span>. Thus the tree looks
like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-28">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;conv
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+
&#x00A0;<br />conv&#x00A0;&#x00A0;&#x00A0;&#x00A0;b
&#x00A0;<br />&#x00A0;&#x00A0;a
</div>
<!--l. 623--><p class="nopar" >
</p><!--l. 626--><p class="noindent" >In summary, type conversions of the actual data are handled by embedding <span 
class="cmtt-10x-x-109">LELConvert </span>objects in the tree
where necessary. The embedding is done by the <span 
class="cmtt-10x-x-109">LatticeExprNode::makeXXX </span>functions.
</p><!--l. 632--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">5 </span> <a 
 id="x1-70005"></a>Scalar Results</h3>
<!--l. 635--><p class="noindent" >So far, we have assumed that the result of all expressions is of the same shape. For example, adding two
<span 
class="cmtt-10x-x-109">Lattices </span>together where the <span 
class="cmtt-10x-x-109">Lattices </span>have the same shape. However, we need to also handle expressions where
the resultant of the operation on a <span 
class="cmtt-10x-x-109">Lattice </span>is a scalar. For example, <span 
class="cmtt-10x-x-109">min(a) </span>where the minimum value of the
<span 
class="cmtt-10x-x-109">Lattice a </span>is returned, must also be handled.
</p><!--l. 642--><p class="noindent" >This is done in two places. Firstly, when any of the derived <span 
class="cmtt-10x-x-109">LEL* </span>classes are constructed, it is known whether the
result of the operation for which that class exists is a scalar or not. For example, the class <span 
class="cmtt-10x-x-109">LELUnaryConst</span>,
which exists to handle an expression like <span 
class="cmtt-10x-x-109">2.0 </span>knows that its result, after evaluation, is a scalar.
Similarly, class <span 
class="cmtt-10x-x-109">LELFunction1D</span>, when it is handling functions <span 
class="cmtt-10x-x-109">min</span>, <span 
class="cmtt-10x-x-109">max</span>, <span 
class="cmtt-10x-x-109">mean </span>and <span 
class="cmtt-10x-x-109">sum </span>(which take one
argument) knows that it returns a scalar. Otherwise, and for all other classes, it is seen whether the
result of evaluating the tree below is a scalar or not. If the former, then the result is also a scalar.
Storage of the knowledge about whether the result is a scalar or not is handled by the attribute class,
<span 
class="cmtt-10x-x-109">LELAttribute</span>.
</p><!--l. 655--><p class="noindent" >Secondly, the knowledge that the result of the evaluation of the tree below the current location is
scalar or not is used to optimize the computation (we could just replicate scalars into arrays of
course).
</p><!--l. 659--><p class="noindent" >For example, consider the expression <span 
class="cmtt-10x-x-109">b+min(c) </span>where <span 
class="cmtt-10x-x-109">b </span>and <span 
class="cmtt-10x-x-109">c </span>are <span 
class="cmtt-10x-x-109">Lattices</span>. The result of <span 
class="cmtt-10x-x-109">min(c) </span>is a scalar (we
will discuss the optimization of only evaluating this once later). Evaluating <span 
class="cmtt-10x-x-109">b+min(c) </span>means that scalar is added
to each element of <span 
class="cmtt-10x-x-109">b </span>so the final result is not a scalar.
</p><!--l. 665--><p class="noindent" >The tree looks like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-29">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;b&#x00A0;&#x00A0;&#x00A0;&#x00A0;min
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;c
</div>
<!--l. 671--><p class="nopar" >
</p><!--l. 673--><p class="noindent" >The code handling the binary operator <!--l. 673--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
needs to know whether the result of the left and right expressions are scalars or not. For example, if they were
both scalars, it would just add those scalars together and pass them on up the tree (noting at tree construction
time that its result was scalar). This operation is handled in the <span 
class="cmtt-10x-x-109">LELBinary </span>class, and the relevant code for the
<!--l. 678--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
operation is
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-30">
&#x00A0;&#x00A0;&#x00A0;template&#x00A0;&#x003C;class&#x00A0;T&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;void&#x00A0;LELBinary&#x003C;T&#x003E;::eval(Array&#x003C;T&#x003E;&amp;&#x00A0;result,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;PixelRegion&amp;&#x00A0;region)&#x00A0;const
&#x00A0;<br />&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch(op_p)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LELBinaryEnums::ADD&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(pLeftExpr_p-&#x003E;isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pRightExpr_p-&#x003E;eval(result,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;pLeftExpr_p-&#x003E;getScalar();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}&#x00A0;else&#x00A0;if&#x00A0;(pRightExpr_p-&#x003E;isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pLeftExpr_p-&#x003E;eval(result,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;pRightExpr_p-&#x003E;getScalar();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}&#x00A0;else&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Array&#x003C;T&#x003E;&#x00A0;temp(result.shape());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pLeftExpr_p-&#x003E;eval(result,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pRightExpr_p-&#x003E;eval(temp,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;+=&#x00A0;temp;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;break;
</div>
<!--l. 700--><p class="nopar" >
</p><!--l. 703--><p class="noindent" >Here you can see that it checks the left and right arguments to see if they are scalar and acts optimally
accordingly, using the <span 
class="cmtt-10x-x-109">getScalar </span>function (rather than the <span 
class="cmtt-10x-x-109">eval </span>function) to return the scalar result. But notice
that the case of both right and left being scalar is missing. What happens is that the <span 
class="cmtt-10x-x-109">eval </span>function is only called
by the next object up the tree if the result of that current operation is NOT scalar. If the result is a scalar,
then <span 
class="cmtt-10x-x-109">eval </span>is not called, but <span 
class="cmtt-10x-x-109">getScalar </span>is called. For <span 
class="cmtt-10x-x-109">LELBinary </span>the piece relevant to operator
<!--l. 711--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math> looks
like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-31">
&#x00A0;&#x00A0;&#x00A0;template&#x00A0;&#x003C;class&#x00A0;T&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;T&#x00A0;LELBinary&#x003C;T&#x003E;::getScalar()&#x00A0;const
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch(op_p)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LELBinaryEnums::ADD&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;pLeftExpr_p-&#x003E;getScalar()&#x00A0;+&#x00A0;pRightExpr_p-&#x003E;getScalar();
</div>
<!--l. 720--><p class="nopar" >
</p><!--l. 723--><p class="noindent" >So if we had asked for <span 
class="cmtt-10x-x-109">2.0 + min(c) </span>then both the arguments would be scalars; the tree would
be
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-32">
&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+
&#x00A0;<br />&#x00A0;&#x00A0;2.0&#x00A0;&#x00A0;&#x00A0;min
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;c
</div>
<!--l. 730--><p class="nopar" >
</p><!--l. 732--><p class="noindent" >and <span 
class="cmtt-10x-x-109">LELBinary::getScalar </span>would have been called to evaluate the sum rather than <span 
class="cmtt-10x-x-109">LELBinary::eval</span>. Now if
this expression was being used like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-33">
&#x00A0;&#x00A0;&#x00A0;a.copyData(2+min(c));
</div>
<!--l. 738--><p class="nopar" >
</p><!--l. 740--><p class="noindent" >then the <span 
class="cmtt-10x-x-109">Lattice a </span>will have all of its pixels assigned the same scalar value that resulted from the
expression evaluation. This final assignment decision is handled in the <span 
class="cmtt-10x-x-109">LatticeExprNode eval</span>
functions.
</p><!--l. 747--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">6 </span> <a 
 id="x1-80006"></a>Optimizations</h3>
<!--l. 749--><p class="noindent" >In the previous section, we considered an expression like
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-34">
&#x00A0;&#x00A0;&#x00A0;a.copyData(b+min(c));
</div>
<!--l. 753--><p class="nopar" >
</p><!--l. 755--><p class="noindent" >where the result of <span 
class="cmtt-10x-x-109">min(c) </span>is a scalar. The <span 
class="cmtt-10x-x-109">Lattice </span>expressions classes, normally evaluate their expressions
chunk by chunk (tile by tile). However, it is clear that an expression like <span 
class="cmtt-10x-x-109">min(c) </span>should only be evaluated
once, and thereafter, for every chunk of the output <span 
class="cmtt-10x-x-109">Lattice</span>, <span 
class="cmtt-10x-x-109">a</span>, that pre-evaluated scalar result
used.
</p><!--l. 761--><p class="noindent" >Let us look at one of the <span 
class="cmtt-10x-x-109">eval </span>function calls in <span 
class="cmtt-10x-x-109">LatticeExprNode</span>. Recall that this is the function that the
<span 
class="cmtt-10x-x-109">Lattice::copyData </span>is eventually going to end up invoking and there is one for each data type depending upon
the type of the output <span 
class="cmtt-10x-x-109">Lattice</span>. Let us look at the <span 
class="cmtt-10x-x-109">Float </span>version.
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-35">
&#x00A0;&#x00A0;&#x00A0;void&#x00A0;LatticeExprNode::eval&#x00A0;(Array&#x003C;Float&#x003E;&amp;&#x00A0;result,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;PixelRegion&amp;&#x00A0;region)&#x00A0;const
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;DebugAssert&#x00A0;(dataType()&#x00A0;==&#x00A0;TpFloat,&#x00A0;AipsError);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(!donePrepare_p)&#x00A0;{
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;//&#x00A0;If&#x00A0;first&#x00A0;time,&#x00A0;try&#x00A0;to&#x00A0;do&#x00A0;optimization.
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;LatticeExprNode*&#x00A0;This&#x00A0;=&#x00A0;(LatticeExprNode*)this;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;LELInterface&#x003C;Float&#x003E;::replaceScalarExpr&#x00A0;(This-&#x003E;pExprFloat_p);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;This-&#x003E;donePrepare_p&#x00A0;=&#x00A0;True;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;=&#x00A0;pExprFloat_p-&#x003E;getScalar();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}&#x00A0;else&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Array&#x003C;Float&#x003E;&#x00A0;temp(result.shape());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;pExprFloat_p-&#x003E;eval(temp,&#x00A0;region);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;result&#x00A0;=&#x00A0;temp;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 788--><p class="nopar" >
</p><!--l. 791--><p class="noindent" >The only optimization we do at present is to replace expressions that result in a scalar by a scalar expression
(<span 
class="cmtt-10x-x-109">LELUnaryConst</span>).
</p><!--l. 794--><p class="noindent" >So, the first time this function is entered, the optimization is attempted. Thereafter, the expression is just
evaluated. Note that the caste is necessary to convert the const <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object to a non-const one so
we can change it (yuck) !
</p><!--l. 799--><p class="noindent" >The implementation of the static function <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr </span>is
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-36">
&#x00A0;&#x00A0;&#x00A0;template&#x003C;class&#x00A0;T&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;void&#x00A0;LELInterface&#x003C;T&#x003E;::replaceScalarExpr&#x00A0;(CountedPtr&#x003C;LELInterface&#x003C;T&#x003E;&#x00A0;&#x003E;&amp;&#x00A0;expr)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;expr-&#x003E;prepare();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(expr-&#x003E;isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;expr&#x00A0;=&#x00A0;new&#x00A0;LELUnaryConst&#x003C;T&#x003E;&#x00A0;(expr-&#x003E;getScalar());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 810--><p class="nopar" >
</p><!--l. 812--><p class="noindent" >So it takes a <span 
class="cmtt-10x-x-109">CountedPtr&#x003C;LELInterface&#x003E; </span>and then does two things. First, the <span 
class="cmtt-10x-x-109">prepare </span>function is called.
Second, if the result of the input expression is a scalar, it evaluates the value of the scalar with the <span 
class="cmtt-10x-x-109">getScalar</span>
function and replaces the expression by a <span 
class="cmtt-10x-x-109">LELUnaryConst </span>object of that scalar value and appropriate
type.
</p><!--l. 818--><p class="noindent" >Each of the <span 
class="cmtt-10x-x-109">LEL* </span>classes derived from <span 
class="cmtt-10x-x-109">LELInterface </span>has a prepare function. These either do nothing, or call
replaceScalarExpr. Thus the process is recursive.
</p><!--l. 822--><p class="noindent" >Let us consider a couple of simple examples. One that does no optimzation and one that does.
</p><!--l. 825--><p class="noindent" >Consider the expression
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-37">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;myExpr&#x00A0;=&#x00A0;a+b;
</div>
<!--l. 829--><p class="nopar" >
</p><!--l. 831--><p class="noindent" >where <span 
class="cmtt-10x-x-109">a </span>and <span 
class="cmtt-10x-x-109">b </span>are <span 
class="cmtt-10x-x-109">Float Lattices</span>. The tree is
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-38">
&#x00A0;&#x00A0;+
&#x00A0;<br />a&#x00A0;&#x00A0;&#x00A0;b
</div>
<!--l. 836--><p class="nopar" >
</p><!--l. 840--><p class="noindent" >After construction of the tree, the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object <span 
class="cmtt-10x-x-109">myExpr </span>has one active <span 
class="cmtt-10x-x-109">LELInterface </span>pointer,
<span 
class="cmtt-10x-x-109">pExprFloat</span><!--l. 841--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><msub><mrow 
></mrow><mrow 
><mi 
>p</mi> </mrow> </msub 
> </math>,
which points at the <span 
class="cmtt-10x-x-109">LELBinary </span>object constructed to handle the
<!--l. 842--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
operation. The <span 
class="cmtt-10x-x-109">LELBinaryObject </span>has two internal <span 
class="cmtt-10x-x-109">LELInterface </span>pointers, one for each of the left and right
expressions (call them <span 
class="cmtt-10x-x-109">pLeft</span><span 
class="cmtt-10x-x-109">_p </span>and <span 
class="cmtt-10x-x-109">pRight</span><span 
class="cmtt-10x-x-109">_p</span>). These pointers each point at a <span 
class="cmtt-10x-x-109">LELLattice </span>object, one for each
Lattice. The <span 
class="cmtt-10x-x-109">LELLattice </span>objects maintain pointers to the actual <span 
class="cmtt-10x-x-109">Lattice </span>objects. This is summarized in the
following table.
</p>
<div class="center" 
>
<!--l. 850--><p class="noindent" >
</p>
<div class="tabular"><table id="TBL-3" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-3-1g"><col 
id="TBL-3-1" /></colgroup><colgroup id="TBL-3-2g"><col 
id="TBL-3-2" /></colgroup><colgroup id="TBL-3-3g"><col 
id="TBL-3-3" /></colgroup><colgroup id="TBL-3-4g"><col 
id="TBL-3-4" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-1-"><td  style="text-align:left; white-space:nowrap;" id="TBL-3-1-1"  
class="td11">Object </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-1-2"  
class="td11">Contains a                                                                                                                                                                                                                                                                                           </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-1-3"  
class="td11">Points at a                                                                                                                                                                                                                                                                                        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-1-4"  
class="td11">Expressions</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-3-2-1"  
class="td11">            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-2-2"  
class="td11">LELInterface<!--l. 854--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 854--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo> <mo 
class="MathClass-bin">*</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-2-3"  
class="td11">                                                                                                                                                                                           </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-2-4"  
class="td11">          </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-3-3-1"  
class="td11">myExpr        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-3-2"  
class="td11">pExprFloat_p                                                                                                                                                                                                                                                                                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-3-3"  
class="td11">LELBinary<!--l. 856--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 856--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-3-4"  
class="td11">a+b          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-3-4-1"  
class="td11">pExprFloat_p</td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-4-2"  
class="td11">pLeft_p                                                                                                                                                                                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-4-3"  
class="td11">LELLattice<!--l. 857--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 857--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-4-4"  
class="td11">a              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-3-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-3-5-1"  
class="td11"> </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-5-2"  
class="td11">pRight_p                                                                                                                                                                                                                                                                                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-5-3"  
class="td11">LELLattice<!--l. 858--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 858--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-3-5-4"  
class="td11">b              </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-3-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-3-6-1"  
class="td11"> </td>
</tr></table>
</div></div>
<!--l. 865--><p class="noindent" >Here is the sequence of events. The numbers indicate the layer of the tree that we have penetrated to. 1 is the
top of the tree.
</p><!--l. 869--><p class="noindent" >1. In <span 
class="cmtt-10x-x-109">LatticeExprNode::eval</span>, <span 
class="cmtt-10x-x-109">replaceScalarExpr(myExpr.pExprFloat</span><span 
class="cmtt-10x-x-109">_p</span>) is called. <span 
class="cmtt-10x-x-109">replaceScalarExpr</span>
renames the pointer passed to it in the argument list expr. This points at the <span 
class="cmtt-10x-x-109">LELBinary </span>object
</p><!--l. 873--><p class="noindent" >2. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the <span 
class="cmtt-10x-x-109">LELBinary </span>object calls prepare with <span 
class="cmtt-10x-x-109">expr-&#x003E;prepare()</span>
</p><!--l. 876--><p class="noindent" >3. In <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>, <span 
class="cmtt-10x-x-109">replaceScalarExpr(pLeft</span><span 
class="cmtt-10x-x-109">_p) </span>is called.
</p><!--l. 878--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the <span 
class="cmtt-10x-x-109">LELLattice </span>object calls prepare with <span 
class="cmtt-10x-x-109">expr-&#x003E;prepare()</span>
</p><!--l. 881--><p class="noindent" >5. In <span 
class="cmtt-10x-x-109">LELLattice::prepare</span>; this does nothing and we return to <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>
</p><!--l. 884--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the result of evaluating the <span 
class="cmtt-10x-x-109">LELLattice </span>expression is seen to not be
a scalar and we return to <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>
</p><!--l. 887--><p class="noindent" >3. In <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>, <span 
class="cmtt-10x-x-109">replaceScalarExpr(pRight</span><span 
class="cmtt-10x-x-109">_p) </span>is called.
</p><!--l. 889--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the <span 
class="cmtt-10x-x-109">LELLattice </span>object calls prepare with <span 
class="cmtt-10x-x-109">expr-&#x003E;prepare()</span>.
</p><!--l. 892--><p class="noindent" >5. In <span 
class="cmtt-10x-x-109">LELLattice::prepare</span>; this does nothing and we return to <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>
</p><!--l. 895--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the result of evaluating the LELLattice expression is seen to not be a
scalar and we return to <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>
                                                                                               
                                                                                               
</p><!--l. 898--><p class="noindent" >3. In <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>, we return to <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>
</p><!--l. 900--><p class="noindent" >2. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the result of evaluating the <span 
class="cmtt-10x-x-109">LELBinary </span>expression is seen to not be a
scalar and we return to <span 
class="cmtt-10x-x-109">LatticeExprNode::eval</span>
</p><!--l. 903--><p class="noindent" >1. In <span 
class="cmtt-10x-x-109">LatticeExprNode::eval </span>we note that we have done the optimization and now evaluate the expression
<span 
class="cmtt-10x-x-109">a+b</span>.
</p><!--l. 907--><p class="noindent" >The net result of all this was that nothing happened. This was because there were no scalar expressions to
optimize.
</p><!--l. 911--><p class="noindent" >Now let&#8217;s consider an expression where the optimization will occur. Consider the expression
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-39">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;myExpr&#x00A0;=&#x00A0;a+min(b);
</div>
<!--l. 916--><p class="nopar" >
</p><!--l. 918--><p class="noindent" >where <span 
class="cmtt-10x-x-109">a </span>and <span 
class="cmtt-10x-x-109">b </span>are <span 
class="cmtt-10x-x-109">Float Lattices</span>. The tree is
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-40">
&#x00A0;&#x00A0;+
&#x00A0;<br />a&#x00A0;&#x00A0;&#x00A0;min
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;b
</div>
<!--l. 924--><p class="nopar" >
</p><!--l. 926--><p class="noindent" >The min function returns a scalar - the minimum of the <span 
class="cmtt-10x-x-109">Lattice b </span>which should be added to the
pixels of <span 
class="cmtt-10x-x-109">Lattice a</span>. We should be able to optimize it out of the iteration loop and replace the tree
by
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-41">
&#x00A0;&#x00A0;+
&#x00A0;<br />a&#x00A0;&#x00A0;&#x00A0;constant
</div>
<!--l. 933--><p class="nopar" >
</p><!--l. 936--><p class="noindent" >After construction of the tree, the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>object <span 
class="cmtt-10x-x-109">myExpr </span>has one active <span 
class="cmtt-10x-x-109">LELInterface</span>
pointer, <span 
class="cmtt-10x-x-109">pExprFloat</span><span 
class="cmtt-10x-x-109">_p</span>, which points at the <span 
class="cmtt-10x-x-109">LELBinary </span>object constructed to handle the
<!--l. 938--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">+</mo></math>
operation. The <span 
class="cmtt-10x-x-109">LELBinaryObject </span>has two internal <span 
class="cmtt-10x-x-109">LELInterface </span>pointers, one for each of the left and right
expressions (call them <span 
class="cmtt-10x-x-109">pLeft</span><span 
class="cmtt-10x-x-109">_p </span>and <span 
class="cmtt-10x-x-109">pRight</span><span 
class="cmtt-10x-x-109">_p</span>). <span 
class="cmtt-10x-x-109">pLeft</span><span 
class="cmtt-10x-x-109">_p </span>points at a <span 
class="cmtt-10x-x-109">LELLattice </span>object, for <span 
class="cmtt-10x-x-109">Lattice a</span>.
<span 
class="cmtt-10x-x-109">pRight</span><span 
class="cmtt-10x-x-109">_p </span>points at a <span 
class="cmtt-10x-x-109">LELFunction1D </span>object to handle the <span 
class="cmtt-10x-x-109">min </span>function. This <span 
class="cmtt-10x-x-109">LELFunction1D </span>object has a
<span 
class="cmtt-10x-x-109">LELInterface </span>pointer called <span 
class="cmtt-10x-x-109">pExpr</span><span 
class="cmtt-10x-x-109">_p </span>which points at a <span 
class="cmtt-10x-x-109">LELLattice </span>object, for <span 
class="cmtt-10x-x-109">Lattice b</span>. This is summarized
in the following table.
</p>
<div class="center" 
>
<!--l. 949--><p class="noindent" >
</p>
<div class="tabular"><table id="TBL-4" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-4-1g"><col 
id="TBL-4-1" /></colgroup><colgroup id="TBL-4-2g"><col 
id="TBL-4-2" /></colgroup><colgroup id="TBL-4-3g"><col 
id="TBL-4-3" /></colgroup><colgroup id="TBL-4-4g"><col 
id="TBL-4-4" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-1-"><td  style="text-align:left; white-space:nowrap;" id="TBL-4-1-1"  
class="td11">Object </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-1-2"  
class="td11">Contains a                                                                                                                                                                                                                                                                                           </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-1-3"  
class="td11">Points at a                                                                                                                                                                                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-1-4"  
class="td11">Expressions</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-4-2-1"  
class="td11">            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-2-2"  
class="td11">LELInterface<!--l. 953--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 953--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo> <mo 
class="MathClass-bin">*</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-2-3"  
class="td11">                                                                                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-2-4"  
class="td11">          </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-4-3-1"  
class="td11">myExpr        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-3-2"  
class="td11">pExprFloat_p                                                                                                                                                                                                                                                                                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-3-3"  
class="td11">LELBinary<!--l. 955--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 955--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-3-4"  
class="td11">a+min(b)   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-4-4-1"  
class="td11">pExprFloat_p</td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-4-2"  
class="td11">pLeft_p                                                                                                                                                                                                                                                                                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-4-3"  
class="td11">LELLattice<!--l. 956--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 956--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-4-4"  
class="td11">a              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-4-5-1"  
class="td11"> </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-5-2"  
class="td11">pRight_p                                                                                                                                                                                                                                                                                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-5-3"  
class="td11">LELFunction1D<!--l. 957--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 957--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-5-4"  
class="td11">min(b)      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-4-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-4-6-1"  
class="td11">pRight_p </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-6-2"  
class="td11">pExpr_p                                                                                                                                                                                                                                                                                              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-6-3"  
class="td11">LELLattice<!--l. 958--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>Float<!--l. 958--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-4-6-4"  
class="td11">b              </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-4-7-"><td  style="text-align:left; white-space:nowrap;" id="TBL-4-7-1"  
class="td11"> </td>
</tr></table>
</div></div>
<!--l. 965--><p class="noindent" >Here is the sequence of events. The numbers indicate the layer of the tree that we have penetrated to. 1 is the
top of the tree.
</p><!--l. 968--><p class="noindent" >1. In <span 
class="cmtt-10x-x-109">LatticeExprNode::eval</span>, <span 
class="cmtt-10x-x-109">replaceScalarExpr(myExpr.pExprFloat</span><span 
class="cmtt-10x-x-109">_p</span>) is called. <span 
class="cmtt-10x-x-109">replaceScalarExpr </span>calls
the pointer passed to it in the argument list &#8221;expr&#8221; This points at the <span 
class="cmtt-10x-x-109">LELBinary </span>object
</p><!--l. 972--><p class="noindent" >2. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the <span 
class="cmtt-10x-x-109">LELBinary </span>object calls prepare with <span 
class="cmtt-10x-x-109">expr-&#x003E;prepare()</span>
</p><!--l. 975--><p class="noindent" >3. In <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>, <span 
class="cmtt-10x-x-109">replaceScalarExpr(pLeft</span><span 
class="cmtt-10x-x-109">_p</span>) is called. <span 
class="cmtt-10x-x-109">pLeft</span><span 
class="cmtt-10x-x-109">_p </span>points at a <span 
class="cmtt-10x-x-109">LELLattice</span>
object
</p><!--l. 978--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the <span 
class="cmtt-10x-x-109">LELLattice </span>object calls prepare with <span 
class="cmtt-10x-x-109">expr-&#x003E;prepare()</span>.
</p><!--l. 981--><p class="noindent" >5. In <span 
class="cmtt-10x-x-109">LELLattice::prepare</span>; this does nothing and we return to <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>
</p><!--l. 984--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the result of evaluating the <span 
class="cmtt-10x-x-109">LELLattice </span>expression is seen to not be
a scalar and we return to <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>
</p><!--l. 988--><p class="noindent" >3. In <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>, <span 
class="cmtt-10x-x-109">replaceScalarExpr(pRight</span><span 
class="cmtt-10x-x-109">_p</span>) is called; <span 
class="cmtt-10x-x-109">pRight</span><span 
class="cmtt-10x-x-109">_p </span>points to a <span 
class="cmtt-10x-x-109">LELFunction1D</span>
object this time.
</p><!--l. 991--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the <span 
class="cmtt-10x-x-109">LELFunction1D </span>object calls prepare with <span 
class="cmtt-10x-x-109">expr-&#x003E;prepare()</span>.
</p><!--l. 994--><p class="noindent" >5. In <span 
class="cmtt-10x-x-109">LELFunction1D::prepare</span>, <span 
class="cmtt-10x-x-109">replaceScalarExpr(pExpr</span><span 
class="cmtt-10x-x-109">_p</span>) is called
                                                                                               
                                                                                               
</p><!--l. 996--><p class="noindent" >6. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the <span 
class="cmtt-10x-x-109">LELLattice </span>object calls prepare with <span 
class="cmtt-10x-x-109">expr-&#x003E;prepare()</span>.
</p><!--l. 999--><p class="noindent" >7. In <span 
class="cmtt-10x-x-109">LELLattice::prepare</span>; this does nothing and we return to <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>
</p><!--l. 1002--><p class="noindent" >6. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the result of evaluating the <span 
class="cmtt-10x-x-109">LELLattice </span>expression is seen to not be
a scalar and we return to <span 
class="cmtt-10x-x-109">LELFunction1D::prepare</span>
</p><!--l. 1006--><p class="noindent" >5. In <span 
class="cmtt-10x-x-109">LELFunction1D::prepare</span>, we return to <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>
</p><!--l. 1008--><p class="noindent" >4. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the result of evaluating the <span 
class="cmtt-10x-x-109">LELFunction1D </span>expression IS seen to be
a scalar. We evaluate that scalar value (another recursive chain) with the <span 
class="cmtt-10x-x-109">getScalar </span>function via the call
<span 
class="cmtt-10x-x-109">expr-&#x003E;getScalar()</span>. We replace the object pointed at by <span 
class="cmtt-10x-x-109">expr </span>(in this case, <span 
class="cmtt-10x-x-109">expr </span>is pointing at a
<span 
class="cmtt-10x-x-109">LELFunction1D </span>object) by a <span 
class="cmtt-10x-x-109">LELUnaryConst </span>object constructed with the result of the <span 
class="cmtt-10x-x-109">getScalar</span>
call
</p><!--l. 1016--><p class="noindent" >We return to <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>
</p><!--l. 1018--><p class="noindent" >3. From <span 
class="cmtt-10x-x-109">LELBinary::prepare</span>, we return to <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>.
</p><!--l. 1020--><p class="noindent" >2. In <span 
class="cmtt-10x-x-109">LELInterface::replaceScalarExpr</span>, the result of evaluating the <span 
class="cmtt-10x-x-109">LELBinary </span>expression is seen to not be a
scalar and we return to <span 
class="cmtt-10x-x-109">LatticeExprNode::eval</span>
</p><!--l. 1024--><p class="noindent" >1. In <span 
class="cmtt-10x-x-109">LatticeExprNode::eval </span>we note that we have done the optimization and now evaluate the expression
<span 
class="cmtt-10x-x-109">a+constant</span>
</p><!--l. 1029--><p class="noindent" >Note that the call to getScalar by the <span 
class="cmtt-10x-x-109">LELFunction1D </span>object invokes a recursive chain as well, although it
doesn&#8217;t go far in this case. Let&#8217;s look inside the <span 
class="cmtt-10x-x-109">LELFunction1D::getScalar </span>function and see what happens
there. The relevant piece is implemented according to
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-42">
&#x00A0;&#x00A0;&#x00A0;template&#x00A0;&#x003C;class&#x00A0;T&#x003E;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;T&#x00A0;LELFunction1D&#x003C;T&#x003E;::getScalar()&#x00A0;const
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;switch(function_p)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LELFunctionEnums::MIN1D&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(pExpr_p-&#x003E;isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;pExpr_p-&#x003E;getScalar();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Bool&#x00A0;firstTime&#x00A0;=&#x00A0;True;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;T&#x00A0;minVal&#x00A0;=&#x00A0;T();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;LatticeExpr&#x003C;T&#x003E;&#x00A0;latExpr(pExpr_p,&#x00A0;0);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RO_LatticeIterator&#x003C;T&#x003E;&#x00A0;iter(latExpr,&#x00A0;latExpr.niceCursorShape());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;while&#x00A0;(!&#x00A0;iter.atEnd())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;T&#x00A0;minv&#x00A0;=&#x00A0;min(iter.cursor());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(firstTime&#x00A0;&#x00A0;||&#x00A0;&#x00A0;minv&#x00A0;&#x003C;&#x00A0;minVal)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;firstTime&#x00A0;=&#x00A0;False;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;minVal&#x00A0;=&#x00A0;minv;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;iter++;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;minVal;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 1058--><p class="nopar" >
</p><!--l. 1061--><p class="noindent" >The <span 
class="cmtt-10x-x-109">LELInterface </span>pointer <span 
class="cmtt-10x-x-109">pExpr</span><span 
class="cmtt-10x-x-109">_p</span>, is pointing at a <span 
class="cmtt-10x-x-109">LELLattice </span>object, which was constructed from the actual
<span 
class="cmtt-10x-x-109">Lattice</span>, <span 
class="cmtt-10x-x-109">b</span>. First it looks to see whether the expression in hand, the <span 
class="cmtt-10x-x-109">LELLattice </span>expression, is a scalar or not. If
it is, it finds the value and returns. For example, if we had asked for <span 
class="cmtt-10x-x-109">min(2.0) </span>this would happen. If it isn&#8217;t,
then we continue on. Now again, <span 
class="cmtt-10x-x-109">pExpr</span><span 
class="cmtt-10x-x-109">_p </span>is pointing at a <span 
class="cmtt-10x-x-109">LELLattice </span>object (derived from <span 
class="cmtt-10x-x-109">LELInterface</span>). But
that is not a <span 
class="cmtt-10x-x-109">Lattice</span>; we need to get at the <span 
class="cmtt-10x-x-109">Lattice </span>from which it was constructed. Since we are inside class
<span 
class="cmtt-10x-x-109">LELFunction1D</span>, we can&#8217;t get at the pointer inside the <span 
class="cmtt-10x-x-109">LELLattice </span>class which does point at the <span 
class="cmtt-10x-x-109">Lattice</span>.
Thus, instead, we construct a <span 
class="cmtt-10x-x-109">LatticeExpr&#x003C;T&#x003E; </span>object (which does inherit from <span 
class="cmtt-10x-x-109">Lattice</span>) from the
<span 
class="cmtt-10x-x-109">LELLattice</span>.
</p><!--l. 1075--><p class="noindent" >This happens with the constructor
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-43">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;Float&#x003E;*&#x00A0;expr);
</div>
<!--l. 1079--><p class="nopar" >
</p><!--l. 1081--><p class="noindent" >which makes a <span 
class="cmtt-10x-x-109">LatticeExprNode</span>. From there it is converted to a <span 
class="cmtt-10x-x-109">LatticeExpr </span>via the casting operators
described in section 2.1 Then it is a simple matter to create a <span 
class="cmtt-10x-x-109">Lattice </span>iterator, iterate through the <span 
class="cmtt-10x-x-109">Lattice </span>(via
the <span 
class="cmtt-10x-x-109">LatticeExpr</span>) and work out the minimum value.
</p><!--l. 1087--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">7 </span> <a 
 id="x1-90007"></a>Relational and Logical Expressions</h3>
<!--l. 1089--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">7.1 </span> <a 
 id="x1-100007.1"></a>Relational Expressions</h4>
<!--l. 1091--><p class="noindent" >So far in the discussion, it has been assumed that the result of all expressions was either a numeric array or
scalar. However, we also want to be able to handle operations which result in <span 
class="cmtt-10x-x-109">Boolean</span>s. For example, consider
<span 
class="cmtt-10x-x-109">Lattices</span>
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-44">
&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;a;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Bool&#x003E;&#x00A0;c;
</div>
<!--l. 1100--><p class="nopar" >
</p><!--l. 1102--><p class="noindent" >and the expression
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-45">
&#x00A0;&#x00A0;&#x00A0;c.copyData(a&#x003E;b);
</div>
<!--l. 1106--><p class="nopar" >
</p><!--l. 1108--><p class="noindent" >so the <span 
class="cmtt-10x-x-109">Bool Lattice c </span>is <span 
class="cmtt-10x-x-109">True </span>or <span 
class="cmtt-10x-x-109">False </span>depending upon whether the data values of <span 
class="cmtt-10x-x-109">a </span>were greater than those of
<span 
class="cmtt-10x-x-109">b </span>or not.
</p><!--l. 1112--><p class="noindent" >What has to be handled here is that the output of the
<!--l. 1112--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-rel">&#x003E;</mo></math>
operation is <span 
class="cmtt-10x-x-109">Boolean</span>, whereas the type of the data which went into the operation was <span 
class="cmtt-10x-x-109">Float</span>.
</p><!--l. 1116--><p class="noindent" >This relational operator, and like ones (<!--l. 1116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>,
<!--l. 1116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-rel">&#x003E;</mo><mo 
class="MathClass-rel">=</mo></math>,
<!--l. 1116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-rel">&#x003C;</mo><mo 
class="MathClass-rel">=</mo></math>,
<!--l. 1116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-rel">=</mo><mo 
class="MathClass-rel">=</mo></math>,
!<!--l. 1116--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">=</mo></math>) are
handled in the class <span 
class="cmtt-10x-x-109">LELBinaryCmp</span>. It is templated on class <span 
class="cmtt-10x-x-109">T </span>but inherits from <span 
class="cmtt-10x-x-109">LELInterface&#x003C;Bool&#x003E; </span>rather
than <span 
class="cmtt-10x-x-109">LELInterface&#x003C;T&#x003E;</span>.
</p><!--l. 1121--><p class="noindent" >The <span 
class="cmtt-10x-x-109">LELInterface </span>class <span 
class="cmtt-10x-x-109">eval </span>function is declared as
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-46">
&#x00A0;&#x00A0;&#x00A0;//&#x00A0;Evaluate&#x00A0;the&#x00A0;expression&#x00A0;and&#x00A0;fill&#x00A0;the&#x00A0;result&#x00A0;array
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;virtual&#x00A0;void&#x00A0;eval&#x00A0;(Array&#x003C;T&#x003E;&amp;&#x00A0;result,
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;PixelRegion&amp;&#x00A0;region)&#x00A0;const&#x00A0;=&#x00A0;0;
</div>
<!--l. 1127--><p class="nopar" >
</p><!--l. 1130--><p class="noindent" >This indicates that the array, <span 
class="cmtt-10x-x-109">result</span>, which results from evaluating the expression is of type <span 
class="cmtt-10x-x-109">T</span>. Since
<span 
class="cmtt-10x-x-109">LELBinaryCmp </span>inherits from <span 
class="cmtt-10x-x-109">LELInterface&#x003C;Bool&#x003E;</span>, the type of its evaluation array, result, is Bool. This is just
what we want. The result of <span 
class="cmtt-10x-x-109">b&#x003E;c </span>is a <span 
class="cmtt-10x-x-109">Bool </span>array.
</p><!--l. 1136--><p class="noindent" >The <span 
class="cmtt-10x-x-109">LELBinaryCmp </span>class itself is still templated in class <span 
class="cmtt-10x-x-109">T </span>because that is the type of the <span 
class="cmtt-10x-x-109">Lattices </span>that go into
it.
</p><!--l. 1140--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">7.2 </span> <a 
 id="x1-110007.2"></a>Logical Expressions</h4>
<!--l. 1142--><p class="noindent" >Take as an example,
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-47">
&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Bool&#x003E;&#x00A0;a;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Bool&#x003E;&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Bool&#x003E;&#x00A0;c;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;c.copyData(a&amp;&amp;b);
</div>
<!--l. 1149--><p class="nopar" >
</p><!--l. 1151--><p class="noindent" >so the <span 
class="cmtt-10x-x-109">Bool Lattice c </span>is <span 
class="cmtt-10x-x-109">True </span>if <span 
class="cmtt-10x-x-109">Lattice a </span>and <span 
class="cmtt-10x-x-109">b </span>are <span 
class="cmtt-10x-x-109">True</span>. This kind of operator can only be
defined for <span 
class="cmtt-10x-x-109">Boolean Lattices</span>. Therefore the class <span 
class="cmtt-10x-x-109">LELBinaryBool </span>is not templated and inherits from
<span 
class="cmtt-10x-x-109">LELInterface&#x003C;Bool&#x003E;</span>. If the data types of the <span 
class="cmtt-10x-x-109">Lattices </span>are not <span 
class="cmtt-10x-x-109">Bool </span>it will throw an exception.
</p><!--l. 1158--><p class="noindent" >Similarly, the class <span 
class="cmtt-10x-x-109">LELUnaryBool </span>exists to handle unary logical operations such as
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-48">
&#x00A0;&#x00A0;&#x00A0;c.copyData(!a)
</div>
<!--l. 1163--><p class="nopar" >
</p><!--l. 1166--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">8 </span> <a 
 id="x1-120008"></a>Other Specializations</h3>
<!--l. 1169--><p class="noindent" >There are a few other specialized classes because not all possible data types can be handled by some functions.
For example, <span 
class="cmtt-10x-x-109">LELFunctionReal1D </span>is a specialized version of <span 
class="cmtt-10x-x-109">LELFunction1D</span>. The former exists to handle
functions such as <span 
class="cmtt-10x-x-109">asin</span>, <span 
class="cmtt-10x-x-109">acos </span>etc which only function with real data.
</p><!--l. 1175--><p class="noindent" >Similarly, the classes <span 
class="cmtt-10x-x-109">LELFunction</span><span 
class="cmsy-10x-x-109">{</span><span 
class="cmtt-10x-x-109">Float,Double,Complex,DComplex</span><span 
class="cmsy-10x-x-109">} </span>exist to handle functions with an
arbitrary number of arguments for each data type. Probably some of these could be combined into a templated
class in the same way as the 1-argument <span 
class="cmtt-10x-x-109">LELFunction*1D </span>classes, but there is enough difference between them
to make this worthwhile.
</p><!--l. 1182--><p class="noindent" >Deserving of special mention for their cunning implementation are the functions, <span 
class="cmtt-10x-x-109">nelements</span>, <span 
class="cmtt-10x-x-109">ntrue</span>, and
<span 
class="cmtt-10x-x-109">nfalse</span>. These are implemented in <span 
class="cmtt-10x-x-109">LELFunctionDouble</span>, which is not templated and it inherits from
<span 
class="cmtt-10x-x-109">LELInterface&#x003C;Double&#x003E;</span>.
</p><!--l. 1187--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">8.1 </span> <a 
 id="x1-130008.1"></a>Function <span 
class="cmtt-10x-x-109">nelements</span></h4>
<!--l. 1189--><p class="noindent" >Consider the expression
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-49">
&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Bool&#x003E;&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Double&#x003E;&#x00A0;a;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;a.copyData(nelements(b));
</div>
<!--l. 1195--><p class="nopar" >
</p><!--l. 1198--><p class="noindent" >Function <span 
class="cmtt-10x-x-109">nelements </span>operates on a <span 
class="cmtt-10x-x-109">Lattice </span>of any data type, and returns the number of elements in the
<span 
class="cmtt-10x-x-109">Lattice </span>in a <span 
class="cmtt-10x-x-109">Double</span>. <span 
class="cmtt-10x-x-109">LELFunctionDouble </span>is not templated, and yet this function handles <span 
class="cmtt-10x-x-109">Lattices </span>of any type.
It is implemented directly in <span 
class="cmtt-10x-x-109">LatticeExprNode</span>
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-50">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;nelements(const&#x00A0;LatticeExprNode&amp;&#x00A0;expr)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Block&#x003C;LatticeExprNode&#x003E;&#x00A0;arg(1,&#x00A0;expr);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;new&#x00A0;LELFunctionDouble&#x00A0;(LELFunctionEnums::NELEM,&#x00A0;arg);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 1210--><p class="nopar" >
</p><!--l. 1213--><p class="noindent" >The new statement creates a pointer to a <span 
class="cmtt-10x-x-109">LELFunctionDouble </span>object, which inherits from <span 
class="cmtt-10x-x-109">LELInterface&#x003C;Double&#x003E;</span>.
This is then automatically converted to a <span 
class="cmtt-10x-x-109">LatticeExprNode </span>by the constructor
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-51">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode(LELInterface&#x003C;Double&#x003E;*&#x00A0;expr);
</div>
<!--l. 1219--><p class="nopar" >
</p><!--l. 1221--><p class="noindent" >Now, <span 
class="cmtt-10x-x-109">LELFunctionDouble </span>knows that the result of function <span 
class="cmtt-10x-x-109">nelements </span>is a scalar, so it is only implemented in
<span 
class="cmtt-10x-x-109">getScalar</span>. The implementation in <span 
class="cmtt-10x-x-109">LELFunctionDouble::getScalar </span>is
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-52">
&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LELFunctionEnums::NELEM&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(arg_p[0].isScalar())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;1;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;arg_p[0].shape().product();
</div>
<!--l. 1231--><p class="nopar" >
</p><!--l. 1233--><p class="noindent" ><span 
class="cmtt-10x-x-109">arg</span><span 
class="cmtt-10x-x-109">_p[0] </span>is the first element in a <span 
class="cmtt-10x-x-109">Block&#x003C;LatticeExprNode&#x003E;</span>. In our example, it is a <span 
class="cmtt-10x-x-109">LatticeExprNode </span>housing
the <span 
class="cmtt-10x-x-109">LELLattice </span>object that is needed to access the LatticeBool (<span 
class="cmtt-10x-x-109">b</span>). Now recall that <span 
class="cmtt-10x-x-109">LELLattice </span>is fully
templated, so it can of course handle any type of Lattice. But <span 
class="cmtt-10x-x-109">LELFunctionDouble </span>doesn&#8217;t know anything at all
about the type of this Lattice in the path that is followed for this function; all type checking is bypassed. The
statement <span 
class="cmtt-10x-x-109">arg</span><span 
class="cmtt-10x-x-109">_p[0].shape().product() </span>invokes the appropriate <span 
class="cmtt-10x-x-109">LatticeExprNode </span>function to return the
shape attribute.
</p><!--l. 1244--><p class="noindent" >
</p>
<h4 class="subsectionHead"><span class="titlemark">8.2 </span> <a 
 id="x1-140008.2"></a>Functions <span 
class="cmtt-10x-x-109">ntrue </span>and <span 
class="cmtt-10x-x-109">nfalse</span></h4>
<!--l. 1246--><p class="noindent" >These functions only work on Bool <span 
class="cmtt-10x-x-109">Lattices </span>and count up the number of <span 
class="cmtt-10x-x-109">True </span>or <span 
class="cmtt-10x-x-109">False </span>values. Like <span 
class="cmtt-10x-x-109">nelements</span>
they are implemented directly from <span 
class="cmtt-10x-x-109">LatticeExprNode</span>. E.g.
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-53">
&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;ntrue&#x00A0;(const&#x00A0;LatticeExprNode&amp;&#x00A0;expr)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;AlwaysAssert&#x00A0;(expr.dataType()&#x00A0;==&#x00A0;TpBool,&#x00A0;AipsError);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Block&#x003C;LatticeExprNode&#x003E;&#x00A0;arg(1,&#x00A0;expr);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;new&#x00A0;LELFunctionDouble(LELFunctionEnums::NTRUE,&#x00A0;arg);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 1258--><p class="nopar" >
</p><!--l. 1261--><p class="noindent" >Immediately though a test is made for the type of the expression that is having the function applied to it. If it&#8217;s
not a <span 
class="cmtt-10x-x-109">Bool</span>, an exception is thrown. Otherwise we proceed into <span 
class="cmtt-10x-x-109">LELFunctionDouble </span>again. Since the
result is a scalar they are only implemented in <span 
class="cmtt-10x-x-109">LELFunctionDouble::getScalar </span>For example, for
<span 
class="cmtt-10x-x-109">ntrue</span>
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-54">
&#x00A0;&#x00A0;&#x00A0;switch&#x00A0;(function_p)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;case&#x00A0;LELFunctionEnums::NTRUE&#x00A0;:
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;uInt&#x00A0;ntrue&#x00A0;=&#x00A0;0;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Bool&#x00A0;deleteIt;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;LatticeExpr&#x003C;Bool&#x003E;&#x00A0;latExpr(arg_p[0],&#x00A0;0);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;RO_LatticeIterator&#x003C;Bool&#x003E;&#x00A0;iter(latExpr,&#x00A0;latExpr.niceCursorShape());
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;while&#x00A0;(!&#x00A0;iter.atEnd())&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;Array&#x003C;Bool&#x003E;&amp;&#x00A0;array&#x00A0;=&#x00A0;iter.cursor();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;const&#x00A0;Bool*&#x00A0;data&#x00A0;=&#x00A0;array.getStorage&#x00A0;(deleteIt);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;uInt&#x00A0;n&#x00A0;=&#x00A0;array.nelements();
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;for&#x00A0;(uInt&#x00A0;i=0;&#x00A0;i&#x003C;n;&#x00A0;i++)&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;if&#x00A0;(data[i])&#x00A0;{
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;ntrue++;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;array.freeStorage&#x00A0;(data,&#x00A0;deleteIt);
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;iter++;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;}
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;return&#x00A0;ntrue;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;}
</div>
<!--l. 1289--><p class="nopar" >
</p><!--l. 1291--><p class="noindent" >A <span 
class="cmtt-10x-x-109">LatticeExpr&#x003C;Bool&#x003E; </span>(which is a <span 
class="cmtt-10x-x-109">Lattice</span>) is explicitly created from the <span 
class="cmtt-10x-x-109">LatticeExprNode </span>via the constructor.
This is then iterated through to get implement the function.
</p><!--l. 1296--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">9 </span> <a 
 id="x1-150009"></a>Static LatticeExprNode functions</h3>
<!--l. 1298--><p class="noindent" >The following table lists helper functions in <span 
class="cmtt-10x-x-109">LatticeExprNode </span>and their uses for creating appropriate nodes in
the tree.
</p>
<div class="center" 
>
<!--l. 1302--><p class="noindent" >
</p>
                                                                                               
                                                                                               
<div class="tabular"><table id="TBL-5" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-5-1g"><col 
id="TBL-5-1" /></colgroup><colgroup id="TBL-5-2g"><col 
id="TBL-5-2" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-1-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-1-1"  
class="td11">LatticeExprNode   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-1-2"  
class="td11">Reason                                                                          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-2-1"  
class="td11">function                </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-2-2"  
class="td11">                                                     </td></tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-3-1"  
class="td11">newNumUnary </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-3-2"  
class="td11">Create a new node for a numerical unary operation.</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-4-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-4-2"  
class="td11">The result has the same data type as the input                     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-5-1"  
class="td11">newNumBinary      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-5-2"  
class="td11">Create a new node for a numerical binary operator.               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-6-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-6-2"  
class="td11">The result has the same data type as the combined input type.</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-7-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-7-1"  
class="td11">newBinaryCmp       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-7-2"  
class="td11">Create a new node for a comparison binary operator.             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-8-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-8-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-8-2"  
class="td11">The result has the same data type as the combined input type.</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-9-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-9-1"  
class="td11">newNumFunc1D     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-9-2"  
class="td11">Create a new node for a numerical function with 1 argument.  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-10-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-10-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-10-2"  
class="td11">The result has the same data type as the input.                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-11-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-11-1"  
class="td11">newRealFunc1D      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-11-2"  
class="td11">Create a new node for a real numerical function with 1           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-12-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-12-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-12-2"  
class="td11">argument. The result has the same data type as the input.      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-13-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-13-1"  
class="td11">newComplexFunc1D</td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-13-2"  
class="td11">Create a new node for a complex numerical function with 1     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-14-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-14-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-14-2"  
class="td11">argument. The result has the same data type as the input.      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-15-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-15-1"  
class="td11">newNumReal1D      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-15-2"  
class="td11">Create a new node for a real numerical function with 1           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-16-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-16-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-16-2"  
class="td11">argument. The resultant type is non-complex                        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-17-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-17-1"  
class="td11">newNumFunc2D     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-17-2"  
class="td11">Create a new node for a numerical function with 2 arguments. </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-5-18-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-18-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-5-18-2"  
class="td11">The result has the same data type as the combined input type.</td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-5-19-"><td  style="text-align:left; white-space:nowrap;" id="TBL-5-19-1"  
class="td11">                 </td>
</tr></table></div></div>
<!--l. 1328--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">10 </span> <a 
 id="x1-1600010"></a>Memory Management</h3>
<!--l. 1330--><p class="noindent" >Although there are many <span 
class="cmtt-10x-x-109">new </span>statements in these classes, there are no matching <span 
class="cmtt-10x-x-109">delete </span>statements. This is
because all the pointers are <span 
class="cmtt-10x-x-109">CountedPtr </span>objects and that class handles the cleanup of released
memory.
</p><!--l. 1338--><p class="noindent" >
</p>
<h3 class="sectionHead"><span class="titlemark">11 </span> <a 
 id="x1-1700011"></a>Functionality</h3>
<!--l. 1340--><p class="noindent" >In this section we list the full functionality available in the <span 
class="cmtt-10x-x-109">LEL </span>classes.
</p><!--l. 1343--><p class="noindent" >The next small table lists the data type codes used subsequently.
</p>
<div class="center" 
>
<!--l. 1345--><p class="noindent" >
</p>
<div class="tabular"><table id="TBL-6" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-6-1g"><col 
id="TBL-6-1" /></colgroup><colgroup id="TBL-6-2g"><col 
id="TBL-6-2" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-1-"><td  style="text-align:left; white-space:nowrap;" id="TBL-6-1-1"  
class="td11">Type </td><td  style="text-align:left; white-space:nowrap;" id="TBL-6-1-2"  
class="td11">Code</td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-6-2-1"  
class="td11">Float       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-6-2-2"  
class="td11">1     </td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-6-3-1"  
class="td11">Double </td><td  style="text-align:left; white-space:nowrap;" id="TBL-6-3-2"  
class="td11">2</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-6-4-1"  
class="td11">Complex  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-6-4-2"  
class="td11">3     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-6-5-1"  
class="td11">DComplex</td><td  style="text-align:left; white-space:nowrap;" id="TBL-6-5-2"  
class="td11">4     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-6-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-6-6-1"  
class="td11">Bool </td><td  style="text-align:left; white-space:nowrap;" id="TBL-6-6-2"  
class="td11">5     </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-6-7-"><td  style="text-align:left; white-space:nowrap;" id="TBL-6-7-1"  
class="td11"> </td>
</tr></table></div></div>
<!--l. 1360--><p class="noindent" >First we give a descriptive table of the available classes and the generic input Lattice expression types and
output types that they handle.
</p>
                                                                                               
                                                                                               
<div class="center" 
>
<!--l. 1364--><p class="noindent" >
</p>
<div class="tabular"><table id="TBL-7" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-7-1g"><col 
id="TBL-7-1" /></colgroup><colgroup id="TBL-7-2g"><col 
id="TBL-7-2" /></colgroup><colgroup id="TBL-7-3g"><col 
id="TBL-7-3" /></colgroup><colgroup id="TBL-7-4g"><col 
id="TBL-7-4" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-1-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-1-1"  
class="td11">Class                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-1-2"  
class="td11">Description                                                              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-1-3"  
class="td11">Type that Operates on</td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-1-4"  
class="td11">Return Type</td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-2-1"  
class="td11">LELLattice                </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-2-2"  
class="td11">Reads Lattice pixels                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-2-3"  
class="td11">1,2,3,4,5                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-2-4"  
class="td11">1,2,3,4,5      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-3-1"  
class="td11">LELUnary                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-3-2"  
class="td11">Handles numerical unary operators                               </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-3-3"  
class="td11">1,2,3,4                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-3-4"  
class="td11">1,2,3,4        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-4-1"  
class="td11">LELUnaryConst          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-4-2"  
class="td11">Handles scalar constants                                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-4-3"  
class="td11">1,2,3,4,5                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-4-4"  
class="td11">1,2,3,4,5      </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-5-1"  
class="td11">LELUnaryBool           </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-5-2"  
class="td11">Handles logical unary operators                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-5-3"  
class="td11">5                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-5-4"  
class="td11">5               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-6-1"  
class="td11">LELBinary                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-6-2"  
class="td11">Handles numerical binary operators                              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-6-3"  
class="td11">1,2,3,4                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-6-4"  
class="td11">1,2,3,4        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-7-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-7-1"  
class="td11">LELBinaryCmp          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-7-2"  
class="td11">Handles relational binary numerical operators                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-7-3"  
class="td11">1,2,3,4                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-7-4"  
class="td11">5               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-8-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-8-1"  
class="td11">LELBinaryBool          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-8-2"  
class="td11">Handles logical binary operators                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-8-3"  
class="td11">5                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-8-4"  
class="td11">5               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-9-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-9-1"  
class="td11">LELFunction1D          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-9-2"  
class="td11">Handles numerical 1-argument functions                        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-9-3"  
class="td11">1,2,3,4                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-9-4"  
class="td11">1,2,3,4        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-10-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-10-1"  
class="td11">LELFunctionND         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-10-2"  
class="td11">Handles numerical N-argument functions                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-10-3"  
class="td11">1,2,3,4                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-10-4"  
class="td11">1,2,3,4        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-11-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-11-1"  
class="td11">LELFunctionReal1D    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-11-2"  
class="td11">Handles real numerical 1-argument functions                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-11-3"  
class="td11">1,2                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-11-4"  
class="td11">1,2             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-12-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-12-1"  
class="td11">LELFunctionFloat       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-12-2"  
class="td11">Handles numerical N-argument functions returning Float  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-12-3"  
class="td11">1,3                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-12-4"  
class="td11">1               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-13-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-13-1"  
class="td11">LELFunctionDouble     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-13-2"  
class="td11">Handles numerical N-argument functions returning Double</td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-13-3"  
class="td11">2,4                          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-13-4"  
class="td11">2               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-14-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-14-1"  
class="td11">LELFunctionComplex  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-14-2"  
class="td11">Handles complex numerical N-argument functions            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-14-3"  
class="td11">3                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-14-4"  
class="td11">3               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-15-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-15-1"  
class="td11">LELFunctionDComplex</td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-15-2"  
class="td11">Handles double complex numerical N-argument functions  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-15-3"  
class="td11">4                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-15-4"  
class="td11">4               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-7-16-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-16-1"  
class="td11">LELFunctionBool        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-16-2"  
class="td11">Handles logical N-argument functions                            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-16-3"  
class="td11">5                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-7-16-4"  
class="td11">5               </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-7-17-"><td  style="text-align:left; white-space:nowrap;" id="TBL-7-17-1"  
class="td11">                    </td>
</tr></table></div></div>
<!--l. 1388--><p class="noindent" >Note that some classes are essentially non-templated specializations of others. For example, <span 
class="cmtt-10x-x-109">LELFunctionReal1D</span>
handles functions that couldn&#8217;t be in <span 
class="cmtt-10x-x-109">LELFunction1D </span>because there was no complex version of that function (e.g.
<span 
class="cmtt-10x-x-109">asin</span>) so templating would fail.
</p><!--l. 1394--><p class="noindent" >In the usage column of the last table, the examples use the following objects:
                                                                                               
                                                                                               
</p>
<div class="verbatim" id="verbatim-55">
&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;a;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Float&#x003E;&#x00A0;b;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Double&#x003E;&#x00A0;aDouble;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Double&#x003E;&#x00A0;bDouble;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Complex&#x003E;&#x00A0;aComplex;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Complex&#x003E;&#x00A0;bComplex;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;DComplex&#x003E;&#x00A0;aDComplex;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;DComplex&#x003E;&#x00A0;bDComplex;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Bool&#x003E;&#x00A0;aBool;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Lattice&#x003C;Bool&#x003E;&#x00A0;bBool;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;Double&#x00A0;const;
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;LatticeExprNode&#x00A0;expr;
</div>
<!--l. 1410--><p class="nopar" >
</p><!--l. 1413--><p class="noindent" >
                                                                                               
                                                                                               
</p>
<div class="center" 
>
<!--l. 1414--><p class="noindent" >
</p>
<div class="tabular"><table id="TBL-8" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-8-1g"><col 
id="TBL-8-1" /></colgroup><colgroup id="TBL-8-2g"><col 
id="TBL-8-2" /></colgroup><colgroup id="TBL-8-3g"><col 
id="TBL-8-3" /></colgroup><colgroup id="TBL-8-4g"><col 
id="TBL-8-4" /></colgroup><colgroup id="TBL-8-5g"><col 
id="TBL-8-5" /></colgroup><colgroup id="TBL-8-6g"><col 
id="TBL-8-6" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-1-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-1-1"  
class="td11">Class                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-1-2"  
class="td11">Operation                                                                                                                           </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-1-3"  
class="td11">Input Data Type</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-1-4"  
class="td11">Result dim. </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-1-5"  
class="td11">Arguments</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-1-6"  
class="td11">Usage example                                                                                                                                             </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-2-1"  
class="td11">LELLattice            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-2-2"  
class="td11">getSlice                                                                                                                              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-2-3"  
class="td11">1,2,3,4,5            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-2-4"  
class="td11">Array         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-2-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-2-6"  
class="td11">expr = a                                                                                                                                                     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-3-1"  
class="td11">LELUnary             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-3-2"  
class="td11">-                                                                                                                                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-3-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-3-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-3-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-3-6"  
class="td11">expr = <!--l. 1420--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-bin">-</mo> <mi 
>a</mi></math>            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-4-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-4-2"  
class="td11">+                                                                                                                                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-4-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-4-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-4-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-4-6"  
class="td11">expr = +a (does nothing)                                                                                                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-5-1"  
class="td11">LELUnaryConst     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-5-2"  
class="td11">constant                                                                                                                             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-5-3"  
class="td11">1,2,3,4,5            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-5-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-5-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-5-6"  
class="td11">expr = const                                                                                                                                               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-6-1"  
class="td11">LELUnaryBool       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-6-2"  
class="td11">!                                                                                                                                        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-6-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-6-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-6-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-6-6"  
class="td11">expr = !aBool                                                                                                                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-7-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-7-1"  
class="td11">LELBinary            </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-7-2"  
class="td11">+                                                                                                                                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-7-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-7-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-7-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-7-6"  
class="td11">expr = a+b                                                                                                                                                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-8-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-8-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-8-2"  
class="td11">-                                                                                                                                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-8-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-8-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-8-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-8-6"  
class="td11">expr = a<!--l. 1425--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-bin">-</mo></math>b           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-9-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-9-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-9-2"  
class="td11">*                                                                                                                                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-9-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-9-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-9-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-9-6"  
class="td11">expr = a*b                                                                                                                                                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-10-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-10-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-10-2"  
class="td11">/                                                                                                                                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-10-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-10-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-10-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-10-6"  
class="td11">expr = a/b                                                                                                                                                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-11-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-11-1"  
class="td11">LELBinaryCmp      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-11-2"  
class="td11">==                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-11-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-11-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-11-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-11-6"  
class="td11">expr = a==b                                                                                                                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-12-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-12-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-12-2"  
class="td11">!=                                                                                                                                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-12-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-12-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-12-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-12-6"  
class="td11">expr = a!=b                                                                                                                                                </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-13-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-13-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-13-2"  
class="td11"><!--l. 1430--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-13-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-13-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-13-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-13-6"  
class="td11">expr = a<!--l. 1430--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo></math>b           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-14-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-14-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-14-2"  
class="td11"><!--l. 1431--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-14-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-14-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-14-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-14-6"  
class="td11">expr = a<!--l. 1431--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo></math>b           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-15-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-15-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-15-2"  
class="td11"><!--l. 1432--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo><mo 
class="MathClass-rel">=</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-15-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-15-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-15-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-15-6"  
class="td11">expr = a<!--l. 1432--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo><mo 
class="MathClass-rel">=</mo></math>b           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-16-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-16-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-16-2"  
class="td11"><!--l. 1433--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003E;</mo><mo 
class="MathClass-rel">=</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-16-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-16-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-16-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-16-6"  
class="td11">expr = a<!--l. 1433--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" > <mo 
class="MathClass-rel">&#x003C;</mo><mo 
class="MathClass-rel">=</mo></math>b           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-17-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-17-1"  
class="td11">LELBinaryBool      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-17-2"  
class="td11">==                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-17-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-17-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-17-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-17-6"  
class="td11">expr = aBool==bBool                                                                                                                                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-18-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-18-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-18-2"  
class="td11">!=                                                                                                                                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-18-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-18-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-18-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-18-6"  
class="td11">expr = aBool!=bBool                                                                                                                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-19-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-19-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-19-2"  
class="td11">&amp;&amp;                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-19-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-19-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-19-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-19-6"  
class="td11">expr = Bool&amp;&amp;bBool                                                                                                                                    </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-20-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-20-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-20-2"  
class="td11"><!--l. 1437--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-rel">|</mo><mo 
class="MathClass-rel">|</mo></math></td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-20-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-20-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-20-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-20-6"  
class="td11">expr = Bool<!--l. 1437--><math 
 xmlns="http://www.w3.org/1998/Math/MathML"  
display="inline" ><mo 
class="MathClass-rel">|</mo><mo 
class="MathClass-rel">|</mo></math>bBool</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-21-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-21-1"  
class="td11">LELFunction1D      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-21-2"  
class="td11">sin                                                                                                                                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-21-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-21-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-21-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-21-6"  
class="td11">expr = sin(a)                                                                                                                                               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-22-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-22-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-22-2"  
class="td11">sinh                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-22-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-22-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-22-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-22-6"  
class="td11">expr = sinh(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-23-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-23-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-23-2"  
class="td11">cos                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-23-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-23-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-23-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-23-6"  
class="td11">expr = cos(a)                                                                                                                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-24-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-24-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-24-2"  
class="td11">cosh                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-24-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-24-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-24-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-24-6"  
class="td11">expr = cosh(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-25-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-25-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-25-2"  
class="td11">exp                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-25-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-25-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-25-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-25-6"  
class="td11">expr = exp(a)                                                                                                                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-26-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-26-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-26-2"  
class="td11">log                                                                                                                                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-26-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-26-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-26-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-26-6"  
class="td11">expr = log(a)                                                                                                                                               </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-27-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-27-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-27-2"  
class="td11">log10                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-27-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-27-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-27-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-27-6"  
class="td11">expr = log10(a)                                                                                                                                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-28-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-28-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-28-2"  
class="td11">sqrt                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-28-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-28-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-28-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-28-6"  
class="td11">expr = sqrt(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-29-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-29-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-29-2"  
class="td11">min                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-29-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-29-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-29-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-29-6"  
class="td11">expr = min(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-30-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-30-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-30-2"  
class="td11">max                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-30-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-30-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-30-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-30-6"  
class="td11">expr = max(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-31-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-31-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-31-2"  
class="td11">mean                                                                                                                                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-31-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-31-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-31-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-31-6"  
class="td11">expr = meann(a)                                                                                                                                          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-32-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-32-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-32-2"  
class="td11">sum                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-32-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-32-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-32-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-32-6"  
class="td11">expr = sum(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-33-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-33-1"  
class="td11">LELFunctionND     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-33-2"  
class="td11">iif                                                                                                                                      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-33-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-33-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-33-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-33-6"  
class="td11">expr = iif(aBool,a,b)                                                                                                                                     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-34-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-34-1"  
class="td11">LELFunctionReal1D</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-34-2"  
class="td11">asin                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-34-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-34-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-34-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-34-6"  
class="td11">expr = asin(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-35-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-35-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-35-2"  
class="td11">acos                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-35-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-35-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-35-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-35-6"  
class="td11">expr = acos(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-36-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-36-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-36-2"  
class="td11">tan                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-36-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-36-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-36-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-36-6"  
class="td11">expr = tan(a)                                                                                                                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-37-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-37-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-37-2"  
class="td11">atan                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-37-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-37-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-37-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-37-6"  
class="td11">expr = atan(a)                                                                                                                                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-38-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-38-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-38-2"  
class="td11">tanh                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-38-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-38-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-38-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-38-6"  
class="td11">expr = tanh(a)                                                                                                                                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-39-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-39-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-39-2"  
class="td11">ceil                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-39-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-39-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-39-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-39-6"  
class="td11">expr = ceil(a)                                                                                                                                              </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-40-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-40-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-40-2"  
class="td11">floor                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-40-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-40-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-40-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-40-6"  
class="td11">expr = floor(a)                                                                                                                                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-41-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-41-1"  
class="td11">LELFunctionFloat   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-41-2"  
class="td11">min                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-41-3"  
class="td11">1                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-41-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-41-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-41-6"  
class="td11">expr = min(a,b)                                                                                                                                           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-42-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-42-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-42-2"  
class="td11">max                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-42-3"  
class="td11">1                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-42-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-42-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-42-6"  
class="td11">expr = max(a,b)                                                                                                                                          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-43-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-43-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-43-2"  
class="td11">pow                                                                                                                                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-43-3"  
class="td11">1                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-43-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-43-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-43-6"  
class="td11">expr = pow(a,b)                                                                                                                                           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-44-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-44-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-44-2"  
class="td11">atan2                                                                                                                                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-44-3"  
class="td11">1                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-44-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-44-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-44-6"  
class="td11">expr = atan2(a,b)                                                                                                                                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-45-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-45-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-45-2"  
class="td11">fmod                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-45-3"  
class="td11">1                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-45-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-45-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-45-6"  
class="td11">expr = fmod(a,b)                                                                                                                                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-46-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-46-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-46-2"  
class="td11">abs                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-46-3"  
class="td11">1,3                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-46-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-46-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-46-6"  
class="td11">expr = abs(a), abs(aComplex)                                                                                                                        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-47-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-47-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-47-2"  
class="td11">arg                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-47-3"  
class="td11">3                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-47-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-47-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-47-6"  
class="td11">expr = arg(aComplex)                                                                                                                                   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-48-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-48-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-48-2"  
class="td11">real                                                                                                                                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-48-3"  
class="td11">1,3                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-48-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-48-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-48-6"  
class="td11">expr = real(aComplex)                                                                                                                                  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-8-49-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-49-1"  
class="td11">                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-49-2"  
class="td11">imag                                                                                                                                  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-49-3"  
class="td11">1,3                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-49-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-49-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-8-49-6"  
class="td11">expr = imag(aComplex)                                                                                                                                </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-8-50-"><td  style="text-align:left; white-space:nowrap;" id="TBL-8-50-1"  
class="td11">                 </td>
</tr></table>
</div></div>
<!--l. 1472--><p class="noindent" >
                                                                                               
                                                                                               
</p>
<div class="center" 
>
<!--l. 1473--><p class="noindent" >
</p>
<div class="tabular"><table id="TBL-9" class="tabular" 
cellspacing="0" cellpadding="0" rules="groups" 
><colgroup id="TBL-9-1g"><col 
id="TBL-9-1" /></colgroup><colgroup id="TBL-9-2g"><col 
id="TBL-9-2" /></colgroup><colgroup id="TBL-9-3g"><col 
id="TBL-9-3" /></colgroup><colgroup id="TBL-9-4g"><col 
id="TBL-9-4" /></colgroup><colgroup id="TBL-9-5g"><col 
id="TBL-9-5" /></colgroup><colgroup id="TBL-9-6g"><col 
id="TBL-9-6" /></colgroup><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-1-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-1-1"  
class="td11">Class                       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-1-2"  
class="td11">Operation</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-1-3"  
class="td11">Input Data Type</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-1-4"  
class="td11">Result dim. </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-1-5"  
class="td11">Arguments</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-1-6"  
class="td11">Usage example                                </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-2-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-2-1"  
class="td11">LELFunctionDouble     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-2-2"  
class="td11">min        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-2-3"  
class="td11">2                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-2-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-2-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-2-6"  
class="td11">expr = min(aDouble,bDouble)           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-3-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-3-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-3-2"  
class="td11">max        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-3-3"  
class="td11">2                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-3-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-3-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-3-6"  
class="td11">expr = max(aDouble,bDouble)           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-4-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-4-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-4-2"  
class="td11">pow        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-4-3"  
class="td11">2                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-4-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-4-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-4-6"  
class="td11">expr = pow(aDouble,bDouble)           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-5-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-5-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-5-2"  
class="td11">atan2      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-5-3"  
class="td11">2                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-5-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-5-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-5-6"  
class="td11">expr = atan2(aDouble,bDouble)         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-6-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-6-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-6-2"  
class="td11">fmod       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-6-3"  
class="td11">2                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-6-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-6-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-6-6"  
class="td11">expr = fmod(aDouble,bDouble)          </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-7-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-7-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-7-2"  
class="td11">abs         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-7-3"  
class="td11">2,4                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-7-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-7-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-7-6"  
class="td11">expr = abs(aDouble), abs(aDComplex)</td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-8-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-8-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-8-2"  
class="td11">arg         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-8-3"  
class="td11">4                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-8-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-8-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-8-6"  
class="td11">expr = arg(aDComplex)                   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-9-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-9-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-9-2"  
class="td11">real        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-9-3"  
class="td11">2,4                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-9-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-9-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-9-6"  
class="td11">expr = real(aDComplex)                   </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-10-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-10-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-10-2"  
class="td11">imag       </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-10-3"  
class="td11">2,4                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-10-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-10-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-10-6"  
class="td11">expr = imag(aDComplex)                 </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-11-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-11-1"  
class="td11">LELFunctionDouble     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-11-2"  
class="td11">ntrue      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-11-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-11-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-11-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-11-6"  
class="td11">expr = ntrue(aBool)                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-12-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-12-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-12-2"  
class="td11">nfalse      </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-12-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-12-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-12-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-12-6"  
class="td11">expr = nfalse(aBool)                        </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-13-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-13-1"  
class="td11">LELFunctionDouble     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-13-2"  
class="td11">nelements</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-13-3"  
class="td11">Any                 </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-13-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-13-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-13-6"  
class="td11">expr = nelements(a)                         </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-14-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-14-1"  
class="td11">LELFunctionComplex  </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-14-2"  
class="td11">pow        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-14-3"  
class="td11">3                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-14-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-14-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-14-6"  
class="td11">expr = pow(aComplex,bComplex)       </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-15-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-15-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-15-2"  
class="td11">conj        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-15-3"  
class="td11">3                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-15-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-15-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-15-6"  
class="td11">expr = conj(aComplex)                     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-16-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-16-1"  
class="td11">LELFunctionDComplex</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-16-2"  
class="td11">pow        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-16-3"  
class="td11">4                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-16-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-16-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-16-6"  
class="td11">expr = pow(aDComplex,bDComplex)  </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-17-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-17-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-17-2"  
class="td11">conj        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-17-3"  
class="td11">4                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-17-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-17-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-17-6"  
class="td11">expr = conj(aComplex)                     </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-18-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-18-1"  
class="td11">LELFunctionBool        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-18-2"  
class="td11">all          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-18-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-18-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-18-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-18-6"  
class="td11">expr = all(aBool)                            </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-19-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-19-1"  
class="td11">                    </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-19-2"  
class="td11">any         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-19-3"  
class="td11">5                     </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-19-4"  
class="td11">Scalar        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-19-5"  
class="td11">1             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-19-6"  
class="td11">expr = any(aBool)                           </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-20-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-20-1"  
class="td11">LatticeExprNode         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-20-2"  
class="td11">amp        </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-20-3"  
class="td11">1,2,3,4              </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-20-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-20-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-20-6"  
class="td11">expr = amp(a,b)                             </td>
</tr><tr  
 style="vertical-align:baseline;" id="TBL-9-21-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-21-1"  
class="td11">LatticeExprNode         </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-21-2"  
class="td11">pa          </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-21-3"  
class="td11">1,2                   </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-21-4"  
class="td11">Scalar,Array</td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-21-5"  
class="td11">2             </td><td  style="text-align:left; white-space:nowrap;" id="TBL-9-21-6"  
class="td11">expr = pa(a,b)                                </td>
</tr><tr 
class="hline"><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td><td><hr /></td></tr><tr  
 style="vertical-align:baseline;" id="TBL-9-22-"><td  style="text-align:left; white-space:nowrap;" id="TBL-9-22-1"  
class="td11">                    </td>
</tr></table></div></div>
 
</body></html> 

                                                                                               


